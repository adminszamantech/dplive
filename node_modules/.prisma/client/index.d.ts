
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model authors
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type authors = $Result.DefaultSelection<Prisma.$authorsPayload>
/**
 * Model bn_ads
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type bn_ads = $Result.DefaultSelection<Prisma.$bn_adsPayload>
/**
 * Model bn_breaking_news
 * 
 */
export type bn_breaking_news = $Result.DefaultSelection<Prisma.$bn_breaking_newsPayload>
/**
 * Model bn_categories
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type bn_categories = $Result.DefaultSelection<Prisma.$bn_categoriesPayload>
/**
 * Model bn_content_positions
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type bn_content_positions = $Result.DefaultSelection<Prisma.$bn_content_positionsPayload>
/**
 * Model bn_contents
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type bn_contents = $Result.DefaultSelection<Prisma.$bn_contentsPayload>
/**
 * Model bn_mobile_ads
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type bn_mobile_ads = $Result.DefaultSelection<Prisma.$bn_mobile_adsPayload>
/**
 * Model bn_position_fixed
 * 
 */
export type bn_position_fixed = $Result.DefaultSelection<Prisma.$bn_position_fixedPayload>
/**
 * Model bn_subcategories
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type bn_subcategories = $Result.DefaultSelection<Prisma.$bn_subcategoriesPayload>
/**
 * Model bn_tags
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type bn_tags = $Result.DefaultSelection<Prisma.$bn_tagsPayload>
/**
 * Model bn_video_categories
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type bn_video_categories = $Result.DefaultSelection<Prisma.$bn_video_categoriesPayload>
/**
 * Model bn_video_positions
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type bn_video_positions = $Result.DefaultSelection<Prisma.$bn_video_positionsPayload>
/**
 * Model bn_videos
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type bn_videos = $Result.DefaultSelection<Prisma.$bn_videosPayload>
/**
 * Model countries
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type countries = $Result.DefaultSelection<Prisma.$countriesPayload>
/**
 * Model districts
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type districts = $Result.DefaultSelection<Prisma.$districtsPayload>
/**
 * Model divisions
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type divisions = $Result.DefaultSelection<Prisma.$divisionsPayload>
/**
 * Model elections
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type elections = $Result.DefaultSelection<Prisma.$electionsPayload>
/**
 * Model epaper_pages
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type epaper_pages = $Result.DefaultSelection<Prisma.$epaper_pagesPayload>
/**
 * Model epapers
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type epapers = $Result.DefaultSelection<Prisma.$epapersPayload>
/**
 * Model magazine_pages
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type magazine_pages = $Result.DefaultSelection<Prisma.$magazine_pagesPayload>
/**
 * Model magazines
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type magazines = $Result.DefaultSelection<Prisma.$magazinesPayload>
/**
 * Model manual_documents
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type manual_documents = $Result.DefaultSelection<Prisma.$manual_documentsPayload>
/**
 * Model manual_photos
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type manual_photos = $Result.DefaultSelection<Prisma.$manual_photosPayload>
/**
 * Model mis_users
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type mis_users = $Result.DefaultSelection<Prisma.$mis_usersPayload>
/**
 * Model monthly_folders
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type monthly_folders = $Result.DefaultSelection<Prisma.$monthly_foldersPayload>
/**
 * Model p_album_positions
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type p_album_positions = $Result.DefaultSelection<Prisma.$p_album_positionsPayload>
/**
 * Model p_albums
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type p_albums = $Result.DefaultSelection<Prisma.$p_albumsPayload>
/**
 * Model p_categories
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type p_categories = $Result.DefaultSelection<Prisma.$p_categoriesPayload>
/**
 * Model p_galleries
 * 
 */
export type p_galleries = $Result.DefaultSelection<Prisma.$p_galleriesPayload>
/**
 * Model p_subcategories
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type p_subcategories = $Result.DefaultSelection<Prisma.$p_subcategoriesPayload>
/**
 * Model site_settings
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type site_settings = $Result.DefaultSelection<Prisma.$site_settingsPayload>
/**
 * Model surveys
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type surveys = $Result.DefaultSelection<Prisma.$surveysPayload>
/**
 * Model upozillas
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type upozillas = $Result.DefaultSelection<Prisma.$upozillasPayload>
/**
 * Model users
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model counter
 * 
 */
export type counter = $Result.DefaultSelection<Prisma.$counterPayload>
/**
 * Model migrations
 * 
 */
export type migrations = $Result.DefaultSelection<Prisma.$migrationsPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Authors
 * const authors = await prisma.authors.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Authors
   * const authors = await prisma.authors.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.authors`: Exposes CRUD operations for the **authors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Authors
    * const authors = await prisma.authors.findMany()
    * ```
    */
  get authors(): Prisma.authorsDelegate<ExtArgs>;

  /**
   * `prisma.bn_ads`: Exposes CRUD operations for the **bn_ads** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bn_ads
    * const bn_ads = await prisma.bn_ads.findMany()
    * ```
    */
  get bn_ads(): Prisma.bn_adsDelegate<ExtArgs>;

  /**
   * `prisma.bn_breaking_news`: Exposes CRUD operations for the **bn_breaking_news** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bn_breaking_news
    * const bn_breaking_news = await prisma.bn_breaking_news.findMany()
    * ```
    */
  get bn_breaking_news(): Prisma.bn_breaking_newsDelegate<ExtArgs>;

  /**
   * `prisma.bn_categories`: Exposes CRUD operations for the **bn_categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bn_categories
    * const bn_categories = await prisma.bn_categories.findMany()
    * ```
    */
  get bn_categories(): Prisma.bn_categoriesDelegate<ExtArgs>;

  /**
   * `prisma.bn_content_positions`: Exposes CRUD operations for the **bn_content_positions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bn_content_positions
    * const bn_content_positions = await prisma.bn_content_positions.findMany()
    * ```
    */
  get bn_content_positions(): Prisma.bn_content_positionsDelegate<ExtArgs>;

  /**
   * `prisma.bn_contents`: Exposes CRUD operations for the **bn_contents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bn_contents
    * const bn_contents = await prisma.bn_contents.findMany()
    * ```
    */
  get bn_contents(): Prisma.bn_contentsDelegate<ExtArgs>;

  /**
   * `prisma.bn_mobile_ads`: Exposes CRUD operations for the **bn_mobile_ads** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bn_mobile_ads
    * const bn_mobile_ads = await prisma.bn_mobile_ads.findMany()
    * ```
    */
  get bn_mobile_ads(): Prisma.bn_mobile_adsDelegate<ExtArgs>;

  /**
   * `prisma.bn_position_fixed`: Exposes CRUD operations for the **bn_position_fixed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bn_position_fixeds
    * const bn_position_fixeds = await prisma.bn_position_fixed.findMany()
    * ```
    */
  get bn_position_fixed(): Prisma.bn_position_fixedDelegate<ExtArgs>;

  /**
   * `prisma.bn_subcategories`: Exposes CRUD operations for the **bn_subcategories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bn_subcategories
    * const bn_subcategories = await prisma.bn_subcategories.findMany()
    * ```
    */
  get bn_subcategories(): Prisma.bn_subcategoriesDelegate<ExtArgs>;

  /**
   * `prisma.bn_tags`: Exposes CRUD operations for the **bn_tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bn_tags
    * const bn_tags = await prisma.bn_tags.findMany()
    * ```
    */
  get bn_tags(): Prisma.bn_tagsDelegate<ExtArgs>;

  /**
   * `prisma.bn_video_categories`: Exposes CRUD operations for the **bn_video_categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bn_video_categories
    * const bn_video_categories = await prisma.bn_video_categories.findMany()
    * ```
    */
  get bn_video_categories(): Prisma.bn_video_categoriesDelegate<ExtArgs>;

  /**
   * `prisma.bn_video_positions`: Exposes CRUD operations for the **bn_video_positions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bn_video_positions
    * const bn_video_positions = await prisma.bn_video_positions.findMany()
    * ```
    */
  get bn_video_positions(): Prisma.bn_video_positionsDelegate<ExtArgs>;

  /**
   * `prisma.bn_videos`: Exposes CRUD operations for the **bn_videos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bn_videos
    * const bn_videos = await prisma.bn_videos.findMany()
    * ```
    */
  get bn_videos(): Prisma.bn_videosDelegate<ExtArgs>;

  /**
   * `prisma.countries`: Exposes CRUD operations for the **countries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.countries.findMany()
    * ```
    */
  get countries(): Prisma.countriesDelegate<ExtArgs>;

  /**
   * `prisma.districts`: Exposes CRUD operations for the **districts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Districts
    * const districts = await prisma.districts.findMany()
    * ```
    */
  get districts(): Prisma.districtsDelegate<ExtArgs>;

  /**
   * `prisma.divisions`: Exposes CRUD operations for the **divisions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Divisions
    * const divisions = await prisma.divisions.findMany()
    * ```
    */
  get divisions(): Prisma.divisionsDelegate<ExtArgs>;

  /**
   * `prisma.elections`: Exposes CRUD operations for the **elections** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Elections
    * const elections = await prisma.elections.findMany()
    * ```
    */
  get elections(): Prisma.electionsDelegate<ExtArgs>;

  /**
   * `prisma.epaper_pages`: Exposes CRUD operations for the **epaper_pages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Epaper_pages
    * const epaper_pages = await prisma.epaper_pages.findMany()
    * ```
    */
  get epaper_pages(): Prisma.epaper_pagesDelegate<ExtArgs>;

  /**
   * `prisma.epapers`: Exposes CRUD operations for the **epapers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Epapers
    * const epapers = await prisma.epapers.findMany()
    * ```
    */
  get epapers(): Prisma.epapersDelegate<ExtArgs>;

  /**
   * `prisma.magazine_pages`: Exposes CRUD operations for the **magazine_pages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Magazine_pages
    * const magazine_pages = await prisma.magazine_pages.findMany()
    * ```
    */
  get magazine_pages(): Prisma.magazine_pagesDelegate<ExtArgs>;

  /**
   * `prisma.magazines`: Exposes CRUD operations for the **magazines** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Magazines
    * const magazines = await prisma.magazines.findMany()
    * ```
    */
  get magazines(): Prisma.magazinesDelegate<ExtArgs>;

  /**
   * `prisma.manual_documents`: Exposes CRUD operations for the **manual_documents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Manual_documents
    * const manual_documents = await prisma.manual_documents.findMany()
    * ```
    */
  get manual_documents(): Prisma.manual_documentsDelegate<ExtArgs>;

  /**
   * `prisma.manual_photos`: Exposes CRUD operations for the **manual_photos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Manual_photos
    * const manual_photos = await prisma.manual_photos.findMany()
    * ```
    */
  get manual_photos(): Prisma.manual_photosDelegate<ExtArgs>;

  /**
   * `prisma.mis_users`: Exposes CRUD operations for the **mis_users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mis_users
    * const mis_users = await prisma.mis_users.findMany()
    * ```
    */
  get mis_users(): Prisma.mis_usersDelegate<ExtArgs>;

  /**
   * `prisma.monthly_folders`: Exposes CRUD operations for the **monthly_folders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Monthly_folders
    * const monthly_folders = await prisma.monthly_folders.findMany()
    * ```
    */
  get monthly_folders(): Prisma.monthly_foldersDelegate<ExtArgs>;

  /**
   * `prisma.p_album_positions`: Exposes CRUD operations for the **p_album_positions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more P_album_positions
    * const p_album_positions = await prisma.p_album_positions.findMany()
    * ```
    */
  get p_album_positions(): Prisma.p_album_positionsDelegate<ExtArgs>;

  /**
   * `prisma.p_albums`: Exposes CRUD operations for the **p_albums** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more P_albums
    * const p_albums = await prisma.p_albums.findMany()
    * ```
    */
  get p_albums(): Prisma.p_albumsDelegate<ExtArgs>;

  /**
   * `prisma.p_categories`: Exposes CRUD operations for the **p_categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more P_categories
    * const p_categories = await prisma.p_categories.findMany()
    * ```
    */
  get p_categories(): Prisma.p_categoriesDelegate<ExtArgs>;

  /**
   * `prisma.p_galleries`: Exposes CRUD operations for the **p_galleries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more P_galleries
    * const p_galleries = await prisma.p_galleries.findMany()
    * ```
    */
  get p_galleries(): Prisma.p_galleriesDelegate<ExtArgs>;

  /**
   * `prisma.p_subcategories`: Exposes CRUD operations for the **p_subcategories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more P_subcategories
    * const p_subcategories = await prisma.p_subcategories.findMany()
    * ```
    */
  get p_subcategories(): Prisma.p_subcategoriesDelegate<ExtArgs>;

  /**
   * `prisma.site_settings`: Exposes CRUD operations for the **site_settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Site_settings
    * const site_settings = await prisma.site_settings.findMany()
    * ```
    */
  get site_settings(): Prisma.site_settingsDelegate<ExtArgs>;

  /**
   * `prisma.surveys`: Exposes CRUD operations for the **surveys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Surveys
    * const surveys = await prisma.surveys.findMany()
    * ```
    */
  get surveys(): Prisma.surveysDelegate<ExtArgs>;

  /**
   * `prisma.upozillas`: Exposes CRUD operations for the **upozillas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Upozillas
    * const upozillas = await prisma.upozillas.findMany()
    * ```
    */
  get upozillas(): Prisma.upozillasDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;

  /**
   * `prisma.counter`: Exposes CRUD operations for the **counter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Counters
    * const counters = await prisma.counter.findMany()
    * ```
    */
  get counter(): Prisma.counterDelegate<ExtArgs>;

  /**
   * `prisma.migrations`: Exposes CRUD operations for the **migrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Migrations
    * const migrations = await prisma.migrations.findMany()
    * ```
    */
  get migrations(): Prisma.migrationsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.8.1
   * Query Engine version: 78caf6feeaed953168c64e15a249c3e9a033ebe2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    authors: 'authors',
    bn_ads: 'bn_ads',
    bn_breaking_news: 'bn_breaking_news',
    bn_categories: 'bn_categories',
    bn_content_positions: 'bn_content_positions',
    bn_contents: 'bn_contents',
    bn_mobile_ads: 'bn_mobile_ads',
    bn_position_fixed: 'bn_position_fixed',
    bn_subcategories: 'bn_subcategories',
    bn_tags: 'bn_tags',
    bn_video_categories: 'bn_video_categories',
    bn_video_positions: 'bn_video_positions',
    bn_videos: 'bn_videos',
    countries: 'countries',
    districts: 'districts',
    divisions: 'divisions',
    elections: 'elections',
    epaper_pages: 'epaper_pages',
    epapers: 'epapers',
    magazine_pages: 'magazine_pages',
    magazines: 'magazines',
    manual_documents: 'manual_documents',
    manual_photos: 'manual_photos',
    mis_users: 'mis_users',
    monthly_folders: 'monthly_folders',
    p_album_positions: 'p_album_positions',
    p_albums: 'p_albums',
    p_categories: 'p_categories',
    p_galleries: 'p_galleries',
    p_subcategories: 'p_subcategories',
    site_settings: 'site_settings',
    surveys: 'surveys',
    upozillas: 'upozillas',
    users: 'users',
    counter: 'counter',
    migrations: 'migrations'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'authors' | 'bn_ads' | 'bn_breaking_news' | 'bn_categories' | 'bn_content_positions' | 'bn_contents' | 'bn_mobile_ads' | 'bn_position_fixed' | 'bn_subcategories' | 'bn_tags' | 'bn_video_categories' | 'bn_video_positions' | 'bn_videos' | 'countries' | 'districts' | 'divisions' | 'elections' | 'epaper_pages' | 'epapers' | 'magazine_pages' | 'magazines' | 'manual_documents' | 'manual_photos' | 'mis_users' | 'monthly_folders' | 'p_album_positions' | 'p_albums' | 'p_categories' | 'p_galleries' | 'p_subcategories' | 'site_settings' | 'surveys' | 'upozillas' | 'users' | 'counter' | 'migrations'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      authors: {
        payload: Prisma.$authorsPayload<ExtArgs>
        fields: Prisma.authorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.authorsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$authorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.authorsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$authorsPayload>
          }
          findFirst: {
            args: Prisma.authorsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$authorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.authorsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$authorsPayload>
          }
          findMany: {
            args: Prisma.authorsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$authorsPayload>[]
          }
          create: {
            args: Prisma.authorsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$authorsPayload>
          }
          createMany: {
            args: Prisma.authorsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.authorsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$authorsPayload>
          }
          update: {
            args: Prisma.authorsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$authorsPayload>
          }
          deleteMany: {
            args: Prisma.authorsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.authorsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.authorsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$authorsPayload>
          }
          aggregate: {
            args: Prisma.AuthorsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAuthors>
          }
          groupBy: {
            args: Prisma.authorsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AuthorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.authorsCountArgs<ExtArgs>,
            result: $Utils.Optional<AuthorsCountAggregateOutputType> | number
          }
        }
      }
      bn_ads: {
        payload: Prisma.$bn_adsPayload<ExtArgs>
        fields: Prisma.bn_adsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bn_adsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_adsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bn_adsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_adsPayload>
          }
          findFirst: {
            args: Prisma.bn_adsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_adsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bn_adsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_adsPayload>
          }
          findMany: {
            args: Prisma.bn_adsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_adsPayload>[]
          }
          create: {
            args: Prisma.bn_adsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_adsPayload>
          }
          createMany: {
            args: Prisma.bn_adsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bn_adsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_adsPayload>
          }
          update: {
            args: Prisma.bn_adsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_adsPayload>
          }
          deleteMany: {
            args: Prisma.bn_adsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bn_adsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bn_adsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_adsPayload>
          }
          aggregate: {
            args: Prisma.Bn_adsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBn_ads>
          }
          groupBy: {
            args: Prisma.bn_adsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bn_adsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bn_adsCountArgs<ExtArgs>,
            result: $Utils.Optional<Bn_adsCountAggregateOutputType> | number
          }
        }
      }
      bn_breaking_news: {
        payload: Prisma.$bn_breaking_newsPayload<ExtArgs>
        fields: Prisma.bn_breaking_newsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bn_breaking_newsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_breaking_newsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bn_breaking_newsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_breaking_newsPayload>
          }
          findFirst: {
            args: Prisma.bn_breaking_newsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_breaking_newsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bn_breaking_newsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_breaking_newsPayload>
          }
          findMany: {
            args: Prisma.bn_breaking_newsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_breaking_newsPayload>[]
          }
          create: {
            args: Prisma.bn_breaking_newsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_breaking_newsPayload>
          }
          createMany: {
            args: Prisma.bn_breaking_newsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bn_breaking_newsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_breaking_newsPayload>
          }
          update: {
            args: Prisma.bn_breaking_newsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_breaking_newsPayload>
          }
          deleteMany: {
            args: Prisma.bn_breaking_newsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bn_breaking_newsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bn_breaking_newsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_breaking_newsPayload>
          }
          aggregate: {
            args: Prisma.Bn_breaking_newsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBn_breaking_news>
          }
          groupBy: {
            args: Prisma.bn_breaking_newsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bn_breaking_newsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bn_breaking_newsCountArgs<ExtArgs>,
            result: $Utils.Optional<Bn_breaking_newsCountAggregateOutputType> | number
          }
        }
      }
      bn_categories: {
        payload: Prisma.$bn_categoriesPayload<ExtArgs>
        fields: Prisma.bn_categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bn_categoriesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bn_categoriesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_categoriesPayload>
          }
          findFirst: {
            args: Prisma.bn_categoriesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bn_categoriesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_categoriesPayload>
          }
          findMany: {
            args: Prisma.bn_categoriesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_categoriesPayload>[]
          }
          create: {
            args: Prisma.bn_categoriesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_categoriesPayload>
          }
          createMany: {
            args: Prisma.bn_categoriesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bn_categoriesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_categoriesPayload>
          }
          update: {
            args: Prisma.bn_categoriesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_categoriesPayload>
          }
          deleteMany: {
            args: Prisma.bn_categoriesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bn_categoriesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bn_categoriesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_categoriesPayload>
          }
          aggregate: {
            args: Prisma.Bn_categoriesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBn_categories>
          }
          groupBy: {
            args: Prisma.bn_categoriesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bn_categoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.bn_categoriesCountArgs<ExtArgs>,
            result: $Utils.Optional<Bn_categoriesCountAggregateOutputType> | number
          }
        }
      }
      bn_content_positions: {
        payload: Prisma.$bn_content_positionsPayload<ExtArgs>
        fields: Prisma.bn_content_positionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bn_content_positionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_content_positionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bn_content_positionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_content_positionsPayload>
          }
          findFirst: {
            args: Prisma.bn_content_positionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_content_positionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bn_content_positionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_content_positionsPayload>
          }
          findMany: {
            args: Prisma.bn_content_positionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_content_positionsPayload>[]
          }
          create: {
            args: Prisma.bn_content_positionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_content_positionsPayload>
          }
          createMany: {
            args: Prisma.bn_content_positionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bn_content_positionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_content_positionsPayload>
          }
          update: {
            args: Prisma.bn_content_positionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_content_positionsPayload>
          }
          deleteMany: {
            args: Prisma.bn_content_positionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bn_content_positionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bn_content_positionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_content_positionsPayload>
          }
          aggregate: {
            args: Prisma.Bn_content_positionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBn_content_positions>
          }
          groupBy: {
            args: Prisma.bn_content_positionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bn_content_positionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bn_content_positionsCountArgs<ExtArgs>,
            result: $Utils.Optional<Bn_content_positionsCountAggregateOutputType> | number
          }
        }
      }
      bn_contents: {
        payload: Prisma.$bn_contentsPayload<ExtArgs>
        fields: Prisma.bn_contentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bn_contentsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_contentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bn_contentsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_contentsPayload>
          }
          findFirst: {
            args: Prisma.bn_contentsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_contentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bn_contentsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_contentsPayload>
          }
          findMany: {
            args: Prisma.bn_contentsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_contentsPayload>[]
          }
          create: {
            args: Prisma.bn_contentsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_contentsPayload>
          }
          createMany: {
            args: Prisma.bn_contentsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bn_contentsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_contentsPayload>
          }
          update: {
            args: Prisma.bn_contentsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_contentsPayload>
          }
          deleteMany: {
            args: Prisma.bn_contentsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bn_contentsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bn_contentsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_contentsPayload>
          }
          aggregate: {
            args: Prisma.Bn_contentsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBn_contents>
          }
          groupBy: {
            args: Prisma.bn_contentsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bn_contentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bn_contentsCountArgs<ExtArgs>,
            result: $Utils.Optional<Bn_contentsCountAggregateOutputType> | number
          }
        }
      }
      bn_mobile_ads: {
        payload: Prisma.$bn_mobile_adsPayload<ExtArgs>
        fields: Prisma.bn_mobile_adsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bn_mobile_adsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_mobile_adsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bn_mobile_adsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_mobile_adsPayload>
          }
          findFirst: {
            args: Prisma.bn_mobile_adsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_mobile_adsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bn_mobile_adsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_mobile_adsPayload>
          }
          findMany: {
            args: Prisma.bn_mobile_adsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_mobile_adsPayload>[]
          }
          create: {
            args: Prisma.bn_mobile_adsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_mobile_adsPayload>
          }
          createMany: {
            args: Prisma.bn_mobile_adsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bn_mobile_adsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_mobile_adsPayload>
          }
          update: {
            args: Prisma.bn_mobile_adsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_mobile_adsPayload>
          }
          deleteMany: {
            args: Prisma.bn_mobile_adsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bn_mobile_adsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bn_mobile_adsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_mobile_adsPayload>
          }
          aggregate: {
            args: Prisma.Bn_mobile_adsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBn_mobile_ads>
          }
          groupBy: {
            args: Prisma.bn_mobile_adsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bn_mobile_adsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bn_mobile_adsCountArgs<ExtArgs>,
            result: $Utils.Optional<Bn_mobile_adsCountAggregateOutputType> | number
          }
        }
      }
      bn_position_fixed: {
        payload: Prisma.$bn_position_fixedPayload<ExtArgs>
        fields: Prisma.bn_position_fixedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bn_position_fixedFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_position_fixedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bn_position_fixedFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_position_fixedPayload>
          }
          findFirst: {
            args: Prisma.bn_position_fixedFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_position_fixedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bn_position_fixedFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_position_fixedPayload>
          }
          findMany: {
            args: Prisma.bn_position_fixedFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_position_fixedPayload>[]
          }
          create: {
            args: Prisma.bn_position_fixedCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_position_fixedPayload>
          }
          createMany: {
            args: Prisma.bn_position_fixedCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bn_position_fixedDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_position_fixedPayload>
          }
          update: {
            args: Prisma.bn_position_fixedUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_position_fixedPayload>
          }
          deleteMany: {
            args: Prisma.bn_position_fixedDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bn_position_fixedUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bn_position_fixedUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_position_fixedPayload>
          }
          aggregate: {
            args: Prisma.Bn_position_fixedAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBn_position_fixed>
          }
          groupBy: {
            args: Prisma.bn_position_fixedGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bn_position_fixedGroupByOutputType>[]
          }
          count: {
            args: Prisma.bn_position_fixedCountArgs<ExtArgs>,
            result: $Utils.Optional<Bn_position_fixedCountAggregateOutputType> | number
          }
        }
      }
      bn_subcategories: {
        payload: Prisma.$bn_subcategoriesPayload<ExtArgs>
        fields: Prisma.bn_subcategoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bn_subcategoriesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_subcategoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bn_subcategoriesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_subcategoriesPayload>
          }
          findFirst: {
            args: Prisma.bn_subcategoriesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_subcategoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bn_subcategoriesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_subcategoriesPayload>
          }
          findMany: {
            args: Prisma.bn_subcategoriesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_subcategoriesPayload>[]
          }
          create: {
            args: Prisma.bn_subcategoriesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_subcategoriesPayload>
          }
          createMany: {
            args: Prisma.bn_subcategoriesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bn_subcategoriesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_subcategoriesPayload>
          }
          update: {
            args: Prisma.bn_subcategoriesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_subcategoriesPayload>
          }
          deleteMany: {
            args: Prisma.bn_subcategoriesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bn_subcategoriesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bn_subcategoriesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_subcategoriesPayload>
          }
          aggregate: {
            args: Prisma.Bn_subcategoriesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBn_subcategories>
          }
          groupBy: {
            args: Prisma.bn_subcategoriesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bn_subcategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.bn_subcategoriesCountArgs<ExtArgs>,
            result: $Utils.Optional<Bn_subcategoriesCountAggregateOutputType> | number
          }
        }
      }
      bn_tags: {
        payload: Prisma.$bn_tagsPayload<ExtArgs>
        fields: Prisma.bn_tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bn_tagsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bn_tagsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_tagsPayload>
          }
          findFirst: {
            args: Prisma.bn_tagsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bn_tagsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_tagsPayload>
          }
          findMany: {
            args: Prisma.bn_tagsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_tagsPayload>[]
          }
          create: {
            args: Prisma.bn_tagsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_tagsPayload>
          }
          createMany: {
            args: Prisma.bn_tagsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bn_tagsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_tagsPayload>
          }
          update: {
            args: Prisma.bn_tagsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_tagsPayload>
          }
          deleteMany: {
            args: Prisma.bn_tagsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bn_tagsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bn_tagsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_tagsPayload>
          }
          aggregate: {
            args: Prisma.Bn_tagsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBn_tags>
          }
          groupBy: {
            args: Prisma.bn_tagsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bn_tagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bn_tagsCountArgs<ExtArgs>,
            result: $Utils.Optional<Bn_tagsCountAggregateOutputType> | number
          }
        }
      }
      bn_video_categories: {
        payload: Prisma.$bn_video_categoriesPayload<ExtArgs>
        fields: Prisma.bn_video_categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bn_video_categoriesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_video_categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bn_video_categoriesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_video_categoriesPayload>
          }
          findFirst: {
            args: Prisma.bn_video_categoriesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_video_categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bn_video_categoriesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_video_categoriesPayload>
          }
          findMany: {
            args: Prisma.bn_video_categoriesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_video_categoriesPayload>[]
          }
          create: {
            args: Prisma.bn_video_categoriesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_video_categoriesPayload>
          }
          createMany: {
            args: Prisma.bn_video_categoriesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bn_video_categoriesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_video_categoriesPayload>
          }
          update: {
            args: Prisma.bn_video_categoriesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_video_categoriesPayload>
          }
          deleteMany: {
            args: Prisma.bn_video_categoriesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bn_video_categoriesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bn_video_categoriesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_video_categoriesPayload>
          }
          aggregate: {
            args: Prisma.Bn_video_categoriesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBn_video_categories>
          }
          groupBy: {
            args: Prisma.bn_video_categoriesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bn_video_categoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.bn_video_categoriesCountArgs<ExtArgs>,
            result: $Utils.Optional<Bn_video_categoriesCountAggregateOutputType> | number
          }
        }
      }
      bn_video_positions: {
        payload: Prisma.$bn_video_positionsPayload<ExtArgs>
        fields: Prisma.bn_video_positionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bn_video_positionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_video_positionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bn_video_positionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_video_positionsPayload>
          }
          findFirst: {
            args: Prisma.bn_video_positionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_video_positionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bn_video_positionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_video_positionsPayload>
          }
          findMany: {
            args: Prisma.bn_video_positionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_video_positionsPayload>[]
          }
          create: {
            args: Prisma.bn_video_positionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_video_positionsPayload>
          }
          createMany: {
            args: Prisma.bn_video_positionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bn_video_positionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_video_positionsPayload>
          }
          update: {
            args: Prisma.bn_video_positionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_video_positionsPayload>
          }
          deleteMany: {
            args: Prisma.bn_video_positionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bn_video_positionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bn_video_positionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_video_positionsPayload>
          }
          aggregate: {
            args: Prisma.Bn_video_positionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBn_video_positions>
          }
          groupBy: {
            args: Prisma.bn_video_positionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bn_video_positionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bn_video_positionsCountArgs<ExtArgs>,
            result: $Utils.Optional<Bn_video_positionsCountAggregateOutputType> | number
          }
        }
      }
      bn_videos: {
        payload: Prisma.$bn_videosPayload<ExtArgs>
        fields: Prisma.bn_videosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bn_videosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_videosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bn_videosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_videosPayload>
          }
          findFirst: {
            args: Prisma.bn_videosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_videosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bn_videosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_videosPayload>
          }
          findMany: {
            args: Prisma.bn_videosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_videosPayload>[]
          }
          create: {
            args: Prisma.bn_videosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_videosPayload>
          }
          createMany: {
            args: Prisma.bn_videosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bn_videosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_videosPayload>
          }
          update: {
            args: Prisma.bn_videosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_videosPayload>
          }
          deleteMany: {
            args: Prisma.bn_videosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bn_videosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bn_videosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bn_videosPayload>
          }
          aggregate: {
            args: Prisma.Bn_videosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBn_videos>
          }
          groupBy: {
            args: Prisma.bn_videosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bn_videosGroupByOutputType>[]
          }
          count: {
            args: Prisma.bn_videosCountArgs<ExtArgs>,
            result: $Utils.Optional<Bn_videosCountAggregateOutputType> | number
          }
        }
      }
      countries: {
        payload: Prisma.$countriesPayload<ExtArgs>
        fields: Prisma.countriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.countriesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$countriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.countriesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>
          }
          findFirst: {
            args: Prisma.countriesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$countriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.countriesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>
          }
          findMany: {
            args: Prisma.countriesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>[]
          }
          create: {
            args: Prisma.countriesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>
          }
          createMany: {
            args: Prisma.countriesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.countriesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>
          }
          update: {
            args: Prisma.countriesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>
          }
          deleteMany: {
            args: Prisma.countriesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.countriesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.countriesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$countriesPayload>
          }
          aggregate: {
            args: Prisma.CountriesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCountries>
          }
          groupBy: {
            args: Prisma.countriesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CountriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.countriesCountArgs<ExtArgs>,
            result: $Utils.Optional<CountriesCountAggregateOutputType> | number
          }
        }
      }
      districts: {
        payload: Prisma.$districtsPayload<ExtArgs>
        fields: Prisma.districtsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.districtsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$districtsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.districtsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>
          }
          findFirst: {
            args: Prisma.districtsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$districtsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.districtsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>
          }
          findMany: {
            args: Prisma.districtsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>[]
          }
          create: {
            args: Prisma.districtsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>
          }
          createMany: {
            args: Prisma.districtsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.districtsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>
          }
          update: {
            args: Prisma.districtsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>
          }
          deleteMany: {
            args: Prisma.districtsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.districtsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.districtsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$districtsPayload>
          }
          aggregate: {
            args: Prisma.DistrictsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDistricts>
          }
          groupBy: {
            args: Prisma.districtsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DistrictsGroupByOutputType>[]
          }
          count: {
            args: Prisma.districtsCountArgs<ExtArgs>,
            result: $Utils.Optional<DistrictsCountAggregateOutputType> | number
          }
        }
      }
      divisions: {
        payload: Prisma.$divisionsPayload<ExtArgs>
        fields: Prisma.divisionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.divisionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$divisionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.divisionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$divisionsPayload>
          }
          findFirst: {
            args: Prisma.divisionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$divisionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.divisionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$divisionsPayload>
          }
          findMany: {
            args: Prisma.divisionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$divisionsPayload>[]
          }
          create: {
            args: Prisma.divisionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$divisionsPayload>
          }
          createMany: {
            args: Prisma.divisionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.divisionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$divisionsPayload>
          }
          update: {
            args: Prisma.divisionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$divisionsPayload>
          }
          deleteMany: {
            args: Prisma.divisionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.divisionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.divisionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$divisionsPayload>
          }
          aggregate: {
            args: Prisma.DivisionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDivisions>
          }
          groupBy: {
            args: Prisma.divisionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DivisionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.divisionsCountArgs<ExtArgs>,
            result: $Utils.Optional<DivisionsCountAggregateOutputType> | number
          }
        }
      }
      elections: {
        payload: Prisma.$electionsPayload<ExtArgs>
        fields: Prisma.electionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.electionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$electionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.electionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$electionsPayload>
          }
          findFirst: {
            args: Prisma.electionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$electionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.electionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$electionsPayload>
          }
          findMany: {
            args: Prisma.electionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$electionsPayload>[]
          }
          create: {
            args: Prisma.electionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$electionsPayload>
          }
          createMany: {
            args: Prisma.electionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.electionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$electionsPayload>
          }
          update: {
            args: Prisma.electionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$electionsPayload>
          }
          deleteMany: {
            args: Prisma.electionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.electionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.electionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$electionsPayload>
          }
          aggregate: {
            args: Prisma.ElectionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateElections>
          }
          groupBy: {
            args: Prisma.electionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ElectionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.electionsCountArgs<ExtArgs>,
            result: $Utils.Optional<ElectionsCountAggregateOutputType> | number
          }
        }
      }
      epaper_pages: {
        payload: Prisma.$epaper_pagesPayload<ExtArgs>
        fields: Prisma.epaper_pagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.epaper_pagesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$epaper_pagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.epaper_pagesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$epaper_pagesPayload>
          }
          findFirst: {
            args: Prisma.epaper_pagesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$epaper_pagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.epaper_pagesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$epaper_pagesPayload>
          }
          findMany: {
            args: Prisma.epaper_pagesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$epaper_pagesPayload>[]
          }
          create: {
            args: Prisma.epaper_pagesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$epaper_pagesPayload>
          }
          createMany: {
            args: Prisma.epaper_pagesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.epaper_pagesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$epaper_pagesPayload>
          }
          update: {
            args: Prisma.epaper_pagesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$epaper_pagesPayload>
          }
          deleteMany: {
            args: Prisma.epaper_pagesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.epaper_pagesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.epaper_pagesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$epaper_pagesPayload>
          }
          aggregate: {
            args: Prisma.Epaper_pagesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEpaper_pages>
          }
          groupBy: {
            args: Prisma.epaper_pagesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Epaper_pagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.epaper_pagesCountArgs<ExtArgs>,
            result: $Utils.Optional<Epaper_pagesCountAggregateOutputType> | number
          }
        }
      }
      epapers: {
        payload: Prisma.$epapersPayload<ExtArgs>
        fields: Prisma.epapersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.epapersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$epapersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.epapersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$epapersPayload>
          }
          findFirst: {
            args: Prisma.epapersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$epapersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.epapersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$epapersPayload>
          }
          findMany: {
            args: Prisma.epapersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$epapersPayload>[]
          }
          create: {
            args: Prisma.epapersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$epapersPayload>
          }
          createMany: {
            args: Prisma.epapersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.epapersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$epapersPayload>
          }
          update: {
            args: Prisma.epapersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$epapersPayload>
          }
          deleteMany: {
            args: Prisma.epapersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.epapersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.epapersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$epapersPayload>
          }
          aggregate: {
            args: Prisma.EpapersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEpapers>
          }
          groupBy: {
            args: Prisma.epapersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EpapersGroupByOutputType>[]
          }
          count: {
            args: Prisma.epapersCountArgs<ExtArgs>,
            result: $Utils.Optional<EpapersCountAggregateOutputType> | number
          }
        }
      }
      magazine_pages: {
        payload: Prisma.$magazine_pagesPayload<ExtArgs>
        fields: Prisma.magazine_pagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.magazine_pagesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazine_pagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.magazine_pagesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazine_pagesPayload>
          }
          findFirst: {
            args: Prisma.magazine_pagesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazine_pagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.magazine_pagesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazine_pagesPayload>
          }
          findMany: {
            args: Prisma.magazine_pagesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazine_pagesPayload>[]
          }
          create: {
            args: Prisma.magazine_pagesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazine_pagesPayload>
          }
          createMany: {
            args: Prisma.magazine_pagesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.magazine_pagesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazine_pagesPayload>
          }
          update: {
            args: Prisma.magazine_pagesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazine_pagesPayload>
          }
          deleteMany: {
            args: Prisma.magazine_pagesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.magazine_pagesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.magazine_pagesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazine_pagesPayload>
          }
          aggregate: {
            args: Prisma.Magazine_pagesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMagazine_pages>
          }
          groupBy: {
            args: Prisma.magazine_pagesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Magazine_pagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.magazine_pagesCountArgs<ExtArgs>,
            result: $Utils.Optional<Magazine_pagesCountAggregateOutputType> | number
          }
        }
      }
      magazines: {
        payload: Prisma.$magazinesPayload<ExtArgs>
        fields: Prisma.magazinesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.magazinesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazinesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.magazinesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazinesPayload>
          }
          findFirst: {
            args: Prisma.magazinesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazinesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.magazinesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazinesPayload>
          }
          findMany: {
            args: Prisma.magazinesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazinesPayload>[]
          }
          create: {
            args: Prisma.magazinesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazinesPayload>
          }
          createMany: {
            args: Prisma.magazinesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.magazinesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazinesPayload>
          }
          update: {
            args: Prisma.magazinesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazinesPayload>
          }
          deleteMany: {
            args: Prisma.magazinesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.magazinesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.magazinesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazinesPayload>
          }
          aggregate: {
            args: Prisma.MagazinesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMagazines>
          }
          groupBy: {
            args: Prisma.magazinesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MagazinesGroupByOutputType>[]
          }
          count: {
            args: Prisma.magazinesCountArgs<ExtArgs>,
            result: $Utils.Optional<MagazinesCountAggregateOutputType> | number
          }
        }
      }
      manual_documents: {
        payload: Prisma.$manual_documentsPayload<ExtArgs>
        fields: Prisma.manual_documentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.manual_documentsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$manual_documentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.manual_documentsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$manual_documentsPayload>
          }
          findFirst: {
            args: Prisma.manual_documentsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$manual_documentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.manual_documentsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$manual_documentsPayload>
          }
          findMany: {
            args: Prisma.manual_documentsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$manual_documentsPayload>[]
          }
          create: {
            args: Prisma.manual_documentsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$manual_documentsPayload>
          }
          createMany: {
            args: Prisma.manual_documentsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.manual_documentsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$manual_documentsPayload>
          }
          update: {
            args: Prisma.manual_documentsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$manual_documentsPayload>
          }
          deleteMany: {
            args: Prisma.manual_documentsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.manual_documentsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.manual_documentsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$manual_documentsPayload>
          }
          aggregate: {
            args: Prisma.Manual_documentsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateManual_documents>
          }
          groupBy: {
            args: Prisma.manual_documentsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Manual_documentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.manual_documentsCountArgs<ExtArgs>,
            result: $Utils.Optional<Manual_documentsCountAggregateOutputType> | number
          }
        }
      }
      manual_photos: {
        payload: Prisma.$manual_photosPayload<ExtArgs>
        fields: Prisma.manual_photosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.manual_photosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$manual_photosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.manual_photosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$manual_photosPayload>
          }
          findFirst: {
            args: Prisma.manual_photosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$manual_photosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.manual_photosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$manual_photosPayload>
          }
          findMany: {
            args: Prisma.manual_photosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$manual_photosPayload>[]
          }
          create: {
            args: Prisma.manual_photosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$manual_photosPayload>
          }
          createMany: {
            args: Prisma.manual_photosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.manual_photosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$manual_photosPayload>
          }
          update: {
            args: Prisma.manual_photosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$manual_photosPayload>
          }
          deleteMany: {
            args: Prisma.manual_photosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.manual_photosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.manual_photosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$manual_photosPayload>
          }
          aggregate: {
            args: Prisma.Manual_photosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateManual_photos>
          }
          groupBy: {
            args: Prisma.manual_photosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Manual_photosGroupByOutputType>[]
          }
          count: {
            args: Prisma.manual_photosCountArgs<ExtArgs>,
            result: $Utils.Optional<Manual_photosCountAggregateOutputType> | number
          }
        }
      }
      mis_users: {
        payload: Prisma.$mis_usersPayload<ExtArgs>
        fields: Prisma.mis_usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mis_usersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mis_usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mis_usersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mis_usersPayload>
          }
          findFirst: {
            args: Prisma.mis_usersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mis_usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mis_usersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mis_usersPayload>
          }
          findMany: {
            args: Prisma.mis_usersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mis_usersPayload>[]
          }
          create: {
            args: Prisma.mis_usersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mis_usersPayload>
          }
          createMany: {
            args: Prisma.mis_usersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.mis_usersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mis_usersPayload>
          }
          update: {
            args: Prisma.mis_usersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mis_usersPayload>
          }
          deleteMany: {
            args: Prisma.mis_usersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.mis_usersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.mis_usersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$mis_usersPayload>
          }
          aggregate: {
            args: Prisma.Mis_usersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMis_users>
          }
          groupBy: {
            args: Prisma.mis_usersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Mis_usersGroupByOutputType>[]
          }
          count: {
            args: Prisma.mis_usersCountArgs<ExtArgs>,
            result: $Utils.Optional<Mis_usersCountAggregateOutputType> | number
          }
        }
      }
      monthly_folders: {
        payload: Prisma.$monthly_foldersPayload<ExtArgs>
        fields: Prisma.monthly_foldersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.monthly_foldersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$monthly_foldersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.monthly_foldersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$monthly_foldersPayload>
          }
          findFirst: {
            args: Prisma.monthly_foldersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$monthly_foldersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.monthly_foldersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$monthly_foldersPayload>
          }
          findMany: {
            args: Prisma.monthly_foldersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$monthly_foldersPayload>[]
          }
          create: {
            args: Prisma.monthly_foldersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$monthly_foldersPayload>
          }
          createMany: {
            args: Prisma.monthly_foldersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.monthly_foldersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$monthly_foldersPayload>
          }
          update: {
            args: Prisma.monthly_foldersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$monthly_foldersPayload>
          }
          deleteMany: {
            args: Prisma.monthly_foldersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.monthly_foldersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.monthly_foldersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$monthly_foldersPayload>
          }
          aggregate: {
            args: Prisma.Monthly_foldersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMonthly_folders>
          }
          groupBy: {
            args: Prisma.monthly_foldersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Monthly_foldersGroupByOutputType>[]
          }
          count: {
            args: Prisma.monthly_foldersCountArgs<ExtArgs>,
            result: $Utils.Optional<Monthly_foldersCountAggregateOutputType> | number
          }
        }
      }
      p_album_positions: {
        payload: Prisma.$p_album_positionsPayload<ExtArgs>
        fields: Prisma.p_album_positionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.p_album_positionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_album_positionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.p_album_positionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_album_positionsPayload>
          }
          findFirst: {
            args: Prisma.p_album_positionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_album_positionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.p_album_positionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_album_positionsPayload>
          }
          findMany: {
            args: Prisma.p_album_positionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_album_positionsPayload>[]
          }
          create: {
            args: Prisma.p_album_positionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_album_positionsPayload>
          }
          createMany: {
            args: Prisma.p_album_positionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.p_album_positionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_album_positionsPayload>
          }
          update: {
            args: Prisma.p_album_positionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_album_positionsPayload>
          }
          deleteMany: {
            args: Prisma.p_album_positionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.p_album_positionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.p_album_positionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_album_positionsPayload>
          }
          aggregate: {
            args: Prisma.P_album_positionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateP_album_positions>
          }
          groupBy: {
            args: Prisma.p_album_positionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<P_album_positionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.p_album_positionsCountArgs<ExtArgs>,
            result: $Utils.Optional<P_album_positionsCountAggregateOutputType> | number
          }
        }
      }
      p_albums: {
        payload: Prisma.$p_albumsPayload<ExtArgs>
        fields: Prisma.p_albumsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.p_albumsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_albumsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.p_albumsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_albumsPayload>
          }
          findFirst: {
            args: Prisma.p_albumsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_albumsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.p_albumsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_albumsPayload>
          }
          findMany: {
            args: Prisma.p_albumsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_albumsPayload>[]
          }
          create: {
            args: Prisma.p_albumsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_albumsPayload>
          }
          createMany: {
            args: Prisma.p_albumsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.p_albumsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_albumsPayload>
          }
          update: {
            args: Prisma.p_albumsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_albumsPayload>
          }
          deleteMany: {
            args: Prisma.p_albumsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.p_albumsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.p_albumsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_albumsPayload>
          }
          aggregate: {
            args: Prisma.P_albumsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateP_albums>
          }
          groupBy: {
            args: Prisma.p_albumsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<P_albumsGroupByOutputType>[]
          }
          count: {
            args: Prisma.p_albumsCountArgs<ExtArgs>,
            result: $Utils.Optional<P_albumsCountAggregateOutputType> | number
          }
        }
      }
      p_categories: {
        payload: Prisma.$p_categoriesPayload<ExtArgs>
        fields: Prisma.p_categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.p_categoriesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.p_categoriesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_categoriesPayload>
          }
          findFirst: {
            args: Prisma.p_categoriesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.p_categoriesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_categoriesPayload>
          }
          findMany: {
            args: Prisma.p_categoriesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_categoriesPayload>[]
          }
          create: {
            args: Prisma.p_categoriesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_categoriesPayload>
          }
          createMany: {
            args: Prisma.p_categoriesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.p_categoriesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_categoriesPayload>
          }
          update: {
            args: Prisma.p_categoriesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_categoriesPayload>
          }
          deleteMany: {
            args: Prisma.p_categoriesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.p_categoriesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.p_categoriesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_categoriesPayload>
          }
          aggregate: {
            args: Prisma.P_categoriesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateP_categories>
          }
          groupBy: {
            args: Prisma.p_categoriesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<P_categoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.p_categoriesCountArgs<ExtArgs>,
            result: $Utils.Optional<P_categoriesCountAggregateOutputType> | number
          }
        }
      }
      p_galleries: {
        payload: Prisma.$p_galleriesPayload<ExtArgs>
        fields: Prisma.p_galleriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.p_galleriesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_galleriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.p_galleriesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_galleriesPayload>
          }
          findFirst: {
            args: Prisma.p_galleriesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_galleriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.p_galleriesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_galleriesPayload>
          }
          findMany: {
            args: Prisma.p_galleriesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_galleriesPayload>[]
          }
          create: {
            args: Prisma.p_galleriesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_galleriesPayload>
          }
          createMany: {
            args: Prisma.p_galleriesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.p_galleriesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_galleriesPayload>
          }
          update: {
            args: Prisma.p_galleriesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_galleriesPayload>
          }
          deleteMany: {
            args: Prisma.p_galleriesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.p_galleriesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.p_galleriesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_galleriesPayload>
          }
          aggregate: {
            args: Prisma.P_galleriesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateP_galleries>
          }
          groupBy: {
            args: Prisma.p_galleriesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<P_galleriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.p_galleriesCountArgs<ExtArgs>,
            result: $Utils.Optional<P_galleriesCountAggregateOutputType> | number
          }
        }
      }
      p_subcategories: {
        payload: Prisma.$p_subcategoriesPayload<ExtArgs>
        fields: Prisma.p_subcategoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.p_subcategoriesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_subcategoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.p_subcategoriesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_subcategoriesPayload>
          }
          findFirst: {
            args: Prisma.p_subcategoriesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_subcategoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.p_subcategoriesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_subcategoriesPayload>
          }
          findMany: {
            args: Prisma.p_subcategoriesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_subcategoriesPayload>[]
          }
          create: {
            args: Prisma.p_subcategoriesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_subcategoriesPayload>
          }
          createMany: {
            args: Prisma.p_subcategoriesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.p_subcategoriesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_subcategoriesPayload>
          }
          update: {
            args: Prisma.p_subcategoriesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_subcategoriesPayload>
          }
          deleteMany: {
            args: Prisma.p_subcategoriesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.p_subcategoriesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.p_subcategoriesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$p_subcategoriesPayload>
          }
          aggregate: {
            args: Prisma.P_subcategoriesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateP_subcategories>
          }
          groupBy: {
            args: Prisma.p_subcategoriesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<P_subcategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.p_subcategoriesCountArgs<ExtArgs>,
            result: $Utils.Optional<P_subcategoriesCountAggregateOutputType> | number
          }
        }
      }
      site_settings: {
        payload: Prisma.$site_settingsPayload<ExtArgs>
        fields: Prisma.site_settingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.site_settingsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$site_settingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.site_settingsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$site_settingsPayload>
          }
          findFirst: {
            args: Prisma.site_settingsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$site_settingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.site_settingsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$site_settingsPayload>
          }
          findMany: {
            args: Prisma.site_settingsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$site_settingsPayload>[]
          }
          create: {
            args: Prisma.site_settingsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$site_settingsPayload>
          }
          createMany: {
            args: Prisma.site_settingsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.site_settingsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$site_settingsPayload>
          }
          update: {
            args: Prisma.site_settingsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$site_settingsPayload>
          }
          deleteMany: {
            args: Prisma.site_settingsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.site_settingsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.site_settingsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$site_settingsPayload>
          }
          aggregate: {
            args: Prisma.Site_settingsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSite_settings>
          }
          groupBy: {
            args: Prisma.site_settingsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Site_settingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.site_settingsCountArgs<ExtArgs>,
            result: $Utils.Optional<Site_settingsCountAggregateOutputType> | number
          }
        }
      }
      surveys: {
        payload: Prisma.$surveysPayload<ExtArgs>
        fields: Prisma.surveysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.surveysFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$surveysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.surveysFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$surveysPayload>
          }
          findFirst: {
            args: Prisma.surveysFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$surveysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.surveysFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$surveysPayload>
          }
          findMany: {
            args: Prisma.surveysFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$surveysPayload>[]
          }
          create: {
            args: Prisma.surveysCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$surveysPayload>
          }
          createMany: {
            args: Prisma.surveysCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.surveysDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$surveysPayload>
          }
          update: {
            args: Prisma.surveysUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$surveysPayload>
          }
          deleteMany: {
            args: Prisma.surveysDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.surveysUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.surveysUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$surveysPayload>
          }
          aggregate: {
            args: Prisma.SurveysAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSurveys>
          }
          groupBy: {
            args: Prisma.surveysGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SurveysGroupByOutputType>[]
          }
          count: {
            args: Prisma.surveysCountArgs<ExtArgs>,
            result: $Utils.Optional<SurveysCountAggregateOutputType> | number
          }
        }
      }
      upozillas: {
        payload: Prisma.$upozillasPayload<ExtArgs>
        fields: Prisma.upozillasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.upozillasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$upozillasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.upozillasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$upozillasPayload>
          }
          findFirst: {
            args: Prisma.upozillasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$upozillasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.upozillasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$upozillasPayload>
          }
          findMany: {
            args: Prisma.upozillasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$upozillasPayload>[]
          }
          create: {
            args: Prisma.upozillasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$upozillasPayload>
          }
          createMany: {
            args: Prisma.upozillasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.upozillasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$upozillasPayload>
          }
          update: {
            args: Prisma.upozillasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$upozillasPayload>
          }
          deleteMany: {
            args: Prisma.upozillasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.upozillasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.upozillasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$upozillasPayload>
          }
          aggregate: {
            args: Prisma.UpozillasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUpozillas>
          }
          groupBy: {
            args: Prisma.upozillasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UpozillasGroupByOutputType>[]
          }
          count: {
            args: Prisma.upozillasCountArgs<ExtArgs>,
            result: $Utils.Optional<UpozillasCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>,
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      counter: {
        payload: Prisma.$counterPayload<ExtArgs>
        fields: Prisma.counterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.counterFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$counterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.counterFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$counterPayload>
          }
          findFirst: {
            args: Prisma.counterFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$counterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.counterFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$counterPayload>
          }
          findMany: {
            args: Prisma.counterFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$counterPayload>[]
          }
          create: {
            args: Prisma.counterCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$counterPayload>
          }
          createMany: {
            args: Prisma.counterCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.counterDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$counterPayload>
          }
          update: {
            args: Prisma.counterUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$counterPayload>
          }
          deleteMany: {
            args: Prisma.counterDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.counterUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.counterUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$counterPayload>
          }
          aggregate: {
            args: Prisma.CounterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCounter>
          }
          groupBy: {
            args: Prisma.counterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CounterGroupByOutputType>[]
          }
          count: {
            args: Prisma.counterCountArgs<ExtArgs>,
            result: $Utils.Optional<CounterCountAggregateOutputType> | number
          }
        }
      }
      migrations: {
        payload: Prisma.$migrationsPayload<ExtArgs>
        fields: Prisma.migrationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.migrationsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.migrationsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          findFirst: {
            args: Prisma.migrationsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.migrationsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          findMany: {
            args: Prisma.migrationsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>[]
          }
          create: {
            args: Prisma.migrationsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          createMany: {
            args: Prisma.migrationsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.migrationsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          update: {
            args: Prisma.migrationsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          deleteMany: {
            args: Prisma.migrationsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.migrationsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.migrationsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          aggregate: {
            args: Prisma.MigrationsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMigrations>
          }
          groupBy: {
            args: Prisma.migrationsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MigrationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.migrationsCountArgs<ExtArgs>,
            result: $Utils.Optional<MigrationsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model authors
   */

  export type AggregateAuthors = {
    _count: AuthorsCountAggregateOutputType | null
    _avg: AuthorsAvgAggregateOutputType | null
    _sum: AuthorsSumAggregateOutputType | null
    _min: AuthorsMinAggregateOutputType | null
    _max: AuthorsMaxAggregateOutputType | null
  }

  export type AuthorsAvgAggregateOutputType = {
    author_id: number | null
    author_type: number | null
    deletable: number | null
  }

  export type AuthorsSumAggregateOutputType = {
    author_id: number | null
    author_type: number | null
    deletable: number | null
  }

  export type AuthorsMinAggregateOutputType = {
    author_id: number | null
    author_type: number | null
    author_name: string | null
    author_name_bn: string | null
    author_slug: string | null
    author_initial: string | null
    author_initial_bn: string | null
    author_bio: string | null
    author_bio_bn: string | null
    img_path: string | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AuthorsMaxAggregateOutputType = {
    author_id: number | null
    author_type: number | null
    author_name: string | null
    author_name_bn: string | null
    author_slug: string | null
    author_initial: string | null
    author_initial_bn: string | null
    author_bio: string | null
    author_bio_bn: string | null
    img_path: string | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AuthorsCountAggregateOutputType = {
    author_id: number
    author_type: number
    author_name: number
    author_name_bn: number
    author_slug: number
    author_initial: number
    author_initial_bn: number
    author_bio: number
    author_bio_bn: number
    img_path: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AuthorsAvgAggregateInputType = {
    author_id?: true
    author_type?: true
    deletable?: true
  }

  export type AuthorsSumAggregateInputType = {
    author_id?: true
    author_type?: true
    deletable?: true
  }

  export type AuthorsMinAggregateInputType = {
    author_id?: true
    author_type?: true
    author_name?: true
    author_name_bn?: true
    author_slug?: true
    author_initial?: true
    author_initial_bn?: true
    author_bio?: true
    author_bio_bn?: true
    img_path?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type AuthorsMaxAggregateInputType = {
    author_id?: true
    author_type?: true
    author_name?: true
    author_name_bn?: true
    author_slug?: true
    author_initial?: true
    author_initial_bn?: true
    author_bio?: true
    author_bio_bn?: true
    img_path?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type AuthorsCountAggregateInputType = {
    author_id?: true
    author_type?: true
    author_name?: true
    author_name_bn?: true
    author_slug?: true
    author_initial?: true
    author_initial_bn?: true
    author_bio?: true
    author_bio_bn?: true
    img_path?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AuthorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which authors to aggregate.
     */
    where?: authorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authors to fetch.
     */
    orderBy?: authorsOrderByWithRelationInput | authorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: authorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned authors
    **/
    _count?: true | AuthorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuthorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuthorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthorsMaxAggregateInputType
  }

  export type GetAuthorsAggregateType<T extends AuthorsAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthors[P]>
      : GetScalarType<T[P], AggregateAuthors[P]>
  }




  export type authorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: authorsWhereInput
    orderBy?: authorsOrderByWithAggregationInput | authorsOrderByWithAggregationInput[]
    by: AuthorsScalarFieldEnum[] | AuthorsScalarFieldEnum
    having?: authorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthorsCountAggregateInputType | true
    _avg?: AuthorsAvgAggregateInputType
    _sum?: AuthorsSumAggregateInputType
    _min?: AuthorsMinAggregateInputType
    _max?: AuthorsMaxAggregateInputType
  }

  export type AuthorsGroupByOutputType = {
    author_id: number
    author_type: number
    author_name: string
    author_name_bn: string
    author_slug: string
    author_initial: string
    author_initial_bn: string
    author_bio: string | null
    author_bio_bn: string | null
    img_path: string | null
    deletable: number
    created_at: Date | null
    updated_at: Date | null
    _count: AuthorsCountAggregateOutputType | null
    _avg: AuthorsAvgAggregateOutputType | null
    _sum: AuthorsSumAggregateOutputType | null
    _min: AuthorsMinAggregateOutputType | null
    _max: AuthorsMaxAggregateOutputType | null
  }

  type GetAuthorsGroupByPayload<T extends authorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthorsGroupByOutputType[P]>
            : GetScalarType<T[P], AuthorsGroupByOutputType[P]>
        }
      >
    >


  export type authorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    author_id?: boolean
    author_type?: boolean
    author_name?: boolean
    author_name_bn?: boolean
    author_slug?: boolean
    author_initial?: boolean
    author_initial_bn?: boolean
    author_bio?: boolean
    author_bio_bn?: boolean
    img_path?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["authors"]>

  export type authorsSelectScalar = {
    author_id?: boolean
    author_type?: boolean
    author_name?: boolean
    author_name_bn?: boolean
    author_slug?: boolean
    author_initial?: boolean
    author_initial_bn?: boolean
    author_bio?: boolean
    author_bio_bn?: boolean
    img_path?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $authorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "authors"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      author_id: number
      author_type: number
      author_name: string
      author_name_bn: string
      author_slug: string
      author_initial: string
      author_initial_bn: string
      author_bio: string | null
      author_bio_bn: string | null
      img_path: string | null
      deletable: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["authors"]>
    composites: {}
  }


  type authorsGetPayload<S extends boolean | null | undefined | authorsDefaultArgs> = $Result.GetResult<Prisma.$authorsPayload, S>

  type authorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<authorsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuthorsCountAggregateInputType | true
    }

  export interface authorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['authors'], meta: { name: 'authors' } }
    /**
     * Find zero or one Authors that matches the filter.
     * @param {authorsFindUniqueArgs} args - Arguments to find a Authors
     * @example
     * // Get one Authors
     * const authors = await prisma.authors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends authorsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, authorsFindUniqueArgs<ExtArgs>>
    ): Prisma__authorsClient<$Result.GetResult<Prisma.$authorsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Authors that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {authorsFindUniqueOrThrowArgs} args - Arguments to find a Authors
     * @example
     * // Get one Authors
     * const authors = await prisma.authors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends authorsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, authorsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__authorsClient<$Result.GetResult<Prisma.$authorsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorsFindFirstArgs} args - Arguments to find a Authors
     * @example
     * // Get one Authors
     * const authors = await prisma.authors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends authorsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, authorsFindFirstArgs<ExtArgs>>
    ): Prisma__authorsClient<$Result.GetResult<Prisma.$authorsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Authors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorsFindFirstOrThrowArgs} args - Arguments to find a Authors
     * @example
     * // Get one Authors
     * const authors = await prisma.authors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends authorsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, authorsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__authorsClient<$Result.GetResult<Prisma.$authorsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Authors
     * const authors = await prisma.authors.findMany()
     * 
     * // Get first 10 Authors
     * const authors = await prisma.authors.findMany({ take: 10 })
     * 
     * // Only select the `author_id`
     * const authorsWithAuthor_idOnly = await prisma.authors.findMany({ select: { author_id: true } })
     * 
    **/
    findMany<T extends authorsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, authorsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$authorsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Authors.
     * @param {authorsCreateArgs} args - Arguments to create a Authors.
     * @example
     * // Create one Authors
     * const Authors = await prisma.authors.create({
     *   data: {
     *     // ... data to create a Authors
     *   }
     * })
     * 
    **/
    create<T extends authorsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, authorsCreateArgs<ExtArgs>>
    ): Prisma__authorsClient<$Result.GetResult<Prisma.$authorsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Authors.
     *     @param {authorsCreateManyArgs} args - Arguments to create many Authors.
     *     @example
     *     // Create many Authors
     *     const authors = await prisma.authors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends authorsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, authorsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Authors.
     * @param {authorsDeleteArgs} args - Arguments to delete one Authors.
     * @example
     * // Delete one Authors
     * const Authors = await prisma.authors.delete({
     *   where: {
     *     // ... filter to delete one Authors
     *   }
     * })
     * 
    **/
    delete<T extends authorsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, authorsDeleteArgs<ExtArgs>>
    ): Prisma__authorsClient<$Result.GetResult<Prisma.$authorsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Authors.
     * @param {authorsUpdateArgs} args - Arguments to update one Authors.
     * @example
     * // Update one Authors
     * const authors = await prisma.authors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends authorsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, authorsUpdateArgs<ExtArgs>>
    ): Prisma__authorsClient<$Result.GetResult<Prisma.$authorsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Authors.
     * @param {authorsDeleteManyArgs} args - Arguments to filter Authors to delete.
     * @example
     * // Delete a few Authors
     * const { count } = await prisma.authors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends authorsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, authorsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Authors
     * const authors = await prisma.authors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends authorsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, authorsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Authors.
     * @param {authorsUpsertArgs} args - Arguments to update or create a Authors.
     * @example
     * // Update or create a Authors
     * const authors = await prisma.authors.upsert({
     *   create: {
     *     // ... data to create a Authors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Authors we want to update
     *   }
     * })
    **/
    upsert<T extends authorsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, authorsUpsertArgs<ExtArgs>>
    ): Prisma__authorsClient<$Result.GetResult<Prisma.$authorsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorsCountArgs} args - Arguments to filter Authors to count.
     * @example
     * // Count the number of Authors
     * const count = await prisma.authors.count({
     *   where: {
     *     // ... the filter for the Authors we want to count
     *   }
     * })
    **/
    count<T extends authorsCountArgs>(
      args?: Subset<T, authorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthorsAggregateArgs>(args: Subset<T, AuthorsAggregateArgs>): Prisma.PrismaPromise<GetAuthorsAggregateType<T>>

    /**
     * Group by Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends authorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: authorsGroupByArgs['orderBy'] }
        : { orderBy?: authorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, authorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the authors model
   */
  readonly fields: authorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for authors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__authorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the authors model
   */ 
  interface authorsFieldRefs {
    readonly author_id: FieldRef<"authors", 'Int'>
    readonly author_type: FieldRef<"authors", 'Int'>
    readonly author_name: FieldRef<"authors", 'String'>
    readonly author_name_bn: FieldRef<"authors", 'String'>
    readonly author_slug: FieldRef<"authors", 'String'>
    readonly author_initial: FieldRef<"authors", 'String'>
    readonly author_initial_bn: FieldRef<"authors", 'String'>
    readonly author_bio: FieldRef<"authors", 'String'>
    readonly author_bio_bn: FieldRef<"authors", 'String'>
    readonly img_path: FieldRef<"authors", 'String'>
    readonly deletable: FieldRef<"authors", 'Int'>
    readonly created_at: FieldRef<"authors", 'DateTime'>
    readonly updated_at: FieldRef<"authors", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * authors findUnique
   */
  export type authorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authors
     */
    select?: authorsSelect<ExtArgs> | null
    /**
     * Filter, which authors to fetch.
     */
    where: authorsWhereUniqueInput
  }


  /**
   * authors findUniqueOrThrow
   */
  export type authorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authors
     */
    select?: authorsSelect<ExtArgs> | null
    /**
     * Filter, which authors to fetch.
     */
    where: authorsWhereUniqueInput
  }


  /**
   * authors findFirst
   */
  export type authorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authors
     */
    select?: authorsSelect<ExtArgs> | null
    /**
     * Filter, which authors to fetch.
     */
    where?: authorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authors to fetch.
     */
    orderBy?: authorsOrderByWithRelationInput | authorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for authors.
     */
    cursor?: authorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of authors.
     */
    distinct?: AuthorsScalarFieldEnum | AuthorsScalarFieldEnum[]
  }


  /**
   * authors findFirstOrThrow
   */
  export type authorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authors
     */
    select?: authorsSelect<ExtArgs> | null
    /**
     * Filter, which authors to fetch.
     */
    where?: authorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authors to fetch.
     */
    orderBy?: authorsOrderByWithRelationInput | authorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for authors.
     */
    cursor?: authorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of authors.
     */
    distinct?: AuthorsScalarFieldEnum | AuthorsScalarFieldEnum[]
  }


  /**
   * authors findMany
   */
  export type authorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authors
     */
    select?: authorsSelect<ExtArgs> | null
    /**
     * Filter, which authors to fetch.
     */
    where?: authorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authors to fetch.
     */
    orderBy?: authorsOrderByWithRelationInput | authorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing authors.
     */
    cursor?: authorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authors.
     */
    skip?: number
    distinct?: AuthorsScalarFieldEnum | AuthorsScalarFieldEnum[]
  }


  /**
   * authors create
   */
  export type authorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authors
     */
    select?: authorsSelect<ExtArgs> | null
    /**
     * The data needed to create a authors.
     */
    data: XOR<authorsCreateInput, authorsUncheckedCreateInput>
  }


  /**
   * authors createMany
   */
  export type authorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many authors.
     */
    data: authorsCreateManyInput | authorsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * authors update
   */
  export type authorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authors
     */
    select?: authorsSelect<ExtArgs> | null
    /**
     * The data needed to update a authors.
     */
    data: XOR<authorsUpdateInput, authorsUncheckedUpdateInput>
    /**
     * Choose, which authors to update.
     */
    where: authorsWhereUniqueInput
  }


  /**
   * authors updateMany
   */
  export type authorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update authors.
     */
    data: XOR<authorsUpdateManyMutationInput, authorsUncheckedUpdateManyInput>
    /**
     * Filter which authors to update
     */
    where?: authorsWhereInput
  }


  /**
   * authors upsert
   */
  export type authorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authors
     */
    select?: authorsSelect<ExtArgs> | null
    /**
     * The filter to search for the authors to update in case it exists.
     */
    where: authorsWhereUniqueInput
    /**
     * In case the authors found by the `where` argument doesn't exist, create a new authors with this data.
     */
    create: XOR<authorsCreateInput, authorsUncheckedCreateInput>
    /**
     * In case the authors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<authorsUpdateInput, authorsUncheckedUpdateInput>
  }


  /**
   * authors delete
   */
  export type authorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authors
     */
    select?: authorsSelect<ExtArgs> | null
    /**
     * Filter which authors to delete.
     */
    where: authorsWhereUniqueInput
  }


  /**
   * authors deleteMany
   */
  export type authorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which authors to delete
     */
    where?: authorsWhereInput
  }


  /**
   * authors without action
   */
  export type authorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authors
     */
    select?: authorsSelect<ExtArgs> | null
  }



  /**
   * Model bn_ads
   */

  export type AggregateBn_ads = {
    _count: Bn_adsCountAggregateOutputType | null
    _avg: Bn_adsAvgAggregateOutputType | null
    _sum: Bn_adsSumAggregateOutputType | null
    _min: Bn_adsMinAggregateOutputType | null
    _max: Bn_adsMaxAggregateOutputType | null
  }

  export type Bn_adsAvgAggregateOutputType = {
    id: number | null
    type: number | null
    page: number | null
    position: number | null
    status: number | null
    deletable: number | null
  }

  export type Bn_adsSumAggregateOutputType = {
    id: number | null
    type: number | null
    page: number | null
    position: number | null
    status: number | null
    deletable: number | null
  }

  export type Bn_adsMinAggregateOutputType = {
    id: number | null
    type: number | null
    page: number | null
    position: number | null
    dfp_header_code: string | null
    code: string | null
    desktop_image_path: string | null
    mobile_image_path: string | null
    external_link: string | null
    start_time: Date | null
    end_time: Date | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_adsMaxAggregateOutputType = {
    id: number | null
    type: number | null
    page: number | null
    position: number | null
    dfp_header_code: string | null
    code: string | null
    desktop_image_path: string | null
    mobile_image_path: string | null
    external_link: string | null
    start_time: Date | null
    end_time: Date | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_adsCountAggregateOutputType = {
    id: number
    type: number
    page: number
    position: number
    dfp_header_code: number
    code: number
    desktop_image_path: number
    mobile_image_path: number
    external_link: number
    start_time: number
    end_time: number
    status: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Bn_adsAvgAggregateInputType = {
    id?: true
    type?: true
    page?: true
    position?: true
    status?: true
    deletable?: true
  }

  export type Bn_adsSumAggregateInputType = {
    id?: true
    type?: true
    page?: true
    position?: true
    status?: true
    deletable?: true
  }

  export type Bn_adsMinAggregateInputType = {
    id?: true
    type?: true
    page?: true
    position?: true
    dfp_header_code?: true
    code?: true
    desktop_image_path?: true
    mobile_image_path?: true
    external_link?: true
    start_time?: true
    end_time?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_adsMaxAggregateInputType = {
    id?: true
    type?: true
    page?: true
    position?: true
    dfp_header_code?: true
    code?: true
    desktop_image_path?: true
    mobile_image_path?: true
    external_link?: true
    start_time?: true
    end_time?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_adsCountAggregateInputType = {
    id?: true
    type?: true
    page?: true
    position?: true
    dfp_header_code?: true
    code?: true
    desktop_image_path?: true
    mobile_image_path?: true
    external_link?: true
    start_time?: true
    end_time?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Bn_adsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_ads to aggregate.
     */
    where?: bn_adsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_ads to fetch.
     */
    orderBy?: bn_adsOrderByWithRelationInput | bn_adsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bn_adsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bn_ads
    **/
    _count?: true | Bn_adsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bn_adsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bn_adsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bn_adsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bn_adsMaxAggregateInputType
  }

  export type GetBn_adsAggregateType<T extends Bn_adsAggregateArgs> = {
        [P in keyof T & keyof AggregateBn_ads]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBn_ads[P]>
      : GetScalarType<T[P], AggregateBn_ads[P]>
  }




  export type bn_adsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bn_adsWhereInput
    orderBy?: bn_adsOrderByWithAggregationInput | bn_adsOrderByWithAggregationInput[]
    by: Bn_adsScalarFieldEnum[] | Bn_adsScalarFieldEnum
    having?: bn_adsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bn_adsCountAggregateInputType | true
    _avg?: Bn_adsAvgAggregateInputType
    _sum?: Bn_adsSumAggregateInputType
    _min?: Bn_adsMinAggregateInputType
    _max?: Bn_adsMaxAggregateInputType
  }

  export type Bn_adsGroupByOutputType = {
    id: number
    type: number | null
    page: number | null
    position: number | null
    dfp_header_code: string | null
    code: string | null
    desktop_image_path: string | null
    mobile_image_path: string | null
    external_link: string | null
    start_time: Date | null
    end_time: Date | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
    _count: Bn_adsCountAggregateOutputType | null
    _avg: Bn_adsAvgAggregateOutputType | null
    _sum: Bn_adsSumAggregateOutputType | null
    _min: Bn_adsMinAggregateOutputType | null
    _max: Bn_adsMaxAggregateOutputType | null
  }

  type GetBn_adsGroupByPayload<T extends bn_adsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bn_adsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bn_adsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bn_adsGroupByOutputType[P]>
            : GetScalarType<T[P], Bn_adsGroupByOutputType[P]>
        }
      >
    >


  export type bn_adsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    page?: boolean
    position?: boolean
    dfp_header_code?: boolean
    code?: boolean
    desktop_image_path?: boolean
    mobile_image_path?: boolean
    external_link?: boolean
    start_time?: boolean
    end_time?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["bn_ads"]>

  export type bn_adsSelectScalar = {
    id?: boolean
    type?: boolean
    page?: boolean
    position?: boolean
    dfp_header_code?: boolean
    code?: boolean
    desktop_image_path?: boolean
    mobile_image_path?: boolean
    external_link?: boolean
    start_time?: boolean
    end_time?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $bn_adsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bn_ads"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: number | null
      page: number | null
      position: number | null
      dfp_header_code: string | null
      code: string | null
      desktop_image_path: string | null
      mobile_image_path: string | null
      external_link: string | null
      start_time: Date | null
      end_time: Date | null
      status: number | null
      deletable: number | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["bn_ads"]>
    composites: {}
  }


  type bn_adsGetPayload<S extends boolean | null | undefined | bn_adsDefaultArgs> = $Result.GetResult<Prisma.$bn_adsPayload, S>

  type bn_adsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bn_adsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bn_adsCountAggregateInputType | true
    }

  export interface bn_adsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bn_ads'], meta: { name: 'bn_ads' } }
    /**
     * Find zero or one Bn_ads that matches the filter.
     * @param {bn_adsFindUniqueArgs} args - Arguments to find a Bn_ads
     * @example
     * // Get one Bn_ads
     * const bn_ads = await prisma.bn_ads.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bn_adsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bn_adsFindUniqueArgs<ExtArgs>>
    ): Prisma__bn_adsClient<$Result.GetResult<Prisma.$bn_adsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bn_ads that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bn_adsFindUniqueOrThrowArgs} args - Arguments to find a Bn_ads
     * @example
     * // Get one Bn_ads
     * const bn_ads = await prisma.bn_ads.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bn_adsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_adsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bn_adsClient<$Result.GetResult<Prisma.$bn_adsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bn_ads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_adsFindFirstArgs} args - Arguments to find a Bn_ads
     * @example
     * // Get one Bn_ads
     * const bn_ads = await prisma.bn_ads.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bn_adsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_adsFindFirstArgs<ExtArgs>>
    ): Prisma__bn_adsClient<$Result.GetResult<Prisma.$bn_adsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bn_ads that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_adsFindFirstOrThrowArgs} args - Arguments to find a Bn_ads
     * @example
     * // Get one Bn_ads
     * const bn_ads = await prisma.bn_ads.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bn_adsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_adsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bn_adsClient<$Result.GetResult<Prisma.$bn_adsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bn_ads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_adsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bn_ads
     * const bn_ads = await prisma.bn_ads.findMany()
     * 
     * // Get first 10 Bn_ads
     * const bn_ads = await prisma.bn_ads.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bn_adsWithIdOnly = await prisma.bn_ads.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends bn_adsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_adsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bn_adsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bn_ads.
     * @param {bn_adsCreateArgs} args - Arguments to create a Bn_ads.
     * @example
     * // Create one Bn_ads
     * const Bn_ads = await prisma.bn_ads.create({
     *   data: {
     *     // ... data to create a Bn_ads
     *   }
     * })
     * 
    **/
    create<T extends bn_adsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_adsCreateArgs<ExtArgs>>
    ): Prisma__bn_adsClient<$Result.GetResult<Prisma.$bn_adsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bn_ads.
     *     @param {bn_adsCreateManyArgs} args - Arguments to create many Bn_ads.
     *     @example
     *     // Create many Bn_ads
     *     const bn_ads = await prisma.bn_ads.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bn_adsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_adsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bn_ads.
     * @param {bn_adsDeleteArgs} args - Arguments to delete one Bn_ads.
     * @example
     * // Delete one Bn_ads
     * const Bn_ads = await prisma.bn_ads.delete({
     *   where: {
     *     // ... filter to delete one Bn_ads
     *   }
     * })
     * 
    **/
    delete<T extends bn_adsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bn_adsDeleteArgs<ExtArgs>>
    ): Prisma__bn_adsClient<$Result.GetResult<Prisma.$bn_adsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bn_ads.
     * @param {bn_adsUpdateArgs} args - Arguments to update one Bn_ads.
     * @example
     * // Update one Bn_ads
     * const bn_ads = await prisma.bn_ads.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bn_adsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_adsUpdateArgs<ExtArgs>>
    ): Prisma__bn_adsClient<$Result.GetResult<Prisma.$bn_adsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bn_ads.
     * @param {bn_adsDeleteManyArgs} args - Arguments to filter Bn_ads to delete.
     * @example
     * // Delete a few Bn_ads
     * const { count } = await prisma.bn_ads.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bn_adsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_adsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bn_ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_adsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bn_ads
     * const bn_ads = await prisma.bn_ads.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bn_adsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bn_adsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bn_ads.
     * @param {bn_adsUpsertArgs} args - Arguments to update or create a Bn_ads.
     * @example
     * // Update or create a Bn_ads
     * const bn_ads = await prisma.bn_ads.upsert({
     *   create: {
     *     // ... data to create a Bn_ads
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bn_ads we want to update
     *   }
     * })
    **/
    upsert<T extends bn_adsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bn_adsUpsertArgs<ExtArgs>>
    ): Prisma__bn_adsClient<$Result.GetResult<Prisma.$bn_adsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bn_ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_adsCountArgs} args - Arguments to filter Bn_ads to count.
     * @example
     * // Count the number of Bn_ads
     * const count = await prisma.bn_ads.count({
     *   where: {
     *     // ... the filter for the Bn_ads we want to count
     *   }
     * })
    **/
    count<T extends bn_adsCountArgs>(
      args?: Subset<T, bn_adsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bn_adsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bn_ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bn_adsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bn_adsAggregateArgs>(args: Subset<T, Bn_adsAggregateArgs>): Prisma.PrismaPromise<GetBn_adsAggregateType<T>>

    /**
     * Group by Bn_ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_adsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bn_adsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bn_adsGroupByArgs['orderBy'] }
        : { orderBy?: bn_adsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bn_adsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBn_adsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bn_ads model
   */
  readonly fields: bn_adsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bn_ads.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bn_adsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bn_ads model
   */ 
  interface bn_adsFieldRefs {
    readonly id: FieldRef<"bn_ads", 'Int'>
    readonly type: FieldRef<"bn_ads", 'Int'>
    readonly page: FieldRef<"bn_ads", 'Int'>
    readonly position: FieldRef<"bn_ads", 'Int'>
    readonly dfp_header_code: FieldRef<"bn_ads", 'String'>
    readonly code: FieldRef<"bn_ads", 'String'>
    readonly desktop_image_path: FieldRef<"bn_ads", 'String'>
    readonly mobile_image_path: FieldRef<"bn_ads", 'String'>
    readonly external_link: FieldRef<"bn_ads", 'String'>
    readonly start_time: FieldRef<"bn_ads", 'DateTime'>
    readonly end_time: FieldRef<"bn_ads", 'DateTime'>
    readonly status: FieldRef<"bn_ads", 'Int'>
    readonly deletable: FieldRef<"bn_ads", 'Int'>
    readonly created_at: FieldRef<"bn_ads", 'DateTime'>
    readonly updated_at: FieldRef<"bn_ads", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * bn_ads findUnique
   */
  export type bn_adsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_ads
     */
    select?: bn_adsSelect<ExtArgs> | null
    /**
     * Filter, which bn_ads to fetch.
     */
    where: bn_adsWhereUniqueInput
  }


  /**
   * bn_ads findUniqueOrThrow
   */
  export type bn_adsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_ads
     */
    select?: bn_adsSelect<ExtArgs> | null
    /**
     * Filter, which bn_ads to fetch.
     */
    where: bn_adsWhereUniqueInput
  }


  /**
   * bn_ads findFirst
   */
  export type bn_adsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_ads
     */
    select?: bn_adsSelect<ExtArgs> | null
    /**
     * Filter, which bn_ads to fetch.
     */
    where?: bn_adsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_ads to fetch.
     */
    orderBy?: bn_adsOrderByWithRelationInput | bn_adsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_ads.
     */
    cursor?: bn_adsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_ads.
     */
    distinct?: Bn_adsScalarFieldEnum | Bn_adsScalarFieldEnum[]
  }


  /**
   * bn_ads findFirstOrThrow
   */
  export type bn_adsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_ads
     */
    select?: bn_adsSelect<ExtArgs> | null
    /**
     * Filter, which bn_ads to fetch.
     */
    where?: bn_adsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_ads to fetch.
     */
    orderBy?: bn_adsOrderByWithRelationInput | bn_adsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_ads.
     */
    cursor?: bn_adsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_ads.
     */
    distinct?: Bn_adsScalarFieldEnum | Bn_adsScalarFieldEnum[]
  }


  /**
   * bn_ads findMany
   */
  export type bn_adsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_ads
     */
    select?: bn_adsSelect<ExtArgs> | null
    /**
     * Filter, which bn_ads to fetch.
     */
    where?: bn_adsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_ads to fetch.
     */
    orderBy?: bn_adsOrderByWithRelationInput | bn_adsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bn_ads.
     */
    cursor?: bn_adsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_ads.
     */
    skip?: number
    distinct?: Bn_adsScalarFieldEnum | Bn_adsScalarFieldEnum[]
  }


  /**
   * bn_ads create
   */
  export type bn_adsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_ads
     */
    select?: bn_adsSelect<ExtArgs> | null
    /**
     * The data needed to create a bn_ads.
     */
    data?: XOR<bn_adsCreateInput, bn_adsUncheckedCreateInput>
  }


  /**
   * bn_ads createMany
   */
  export type bn_adsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bn_ads.
     */
    data: bn_adsCreateManyInput | bn_adsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bn_ads update
   */
  export type bn_adsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_ads
     */
    select?: bn_adsSelect<ExtArgs> | null
    /**
     * The data needed to update a bn_ads.
     */
    data: XOR<bn_adsUpdateInput, bn_adsUncheckedUpdateInput>
    /**
     * Choose, which bn_ads to update.
     */
    where: bn_adsWhereUniqueInput
  }


  /**
   * bn_ads updateMany
   */
  export type bn_adsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bn_ads.
     */
    data: XOR<bn_adsUpdateManyMutationInput, bn_adsUncheckedUpdateManyInput>
    /**
     * Filter which bn_ads to update
     */
    where?: bn_adsWhereInput
  }


  /**
   * bn_ads upsert
   */
  export type bn_adsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_ads
     */
    select?: bn_adsSelect<ExtArgs> | null
    /**
     * The filter to search for the bn_ads to update in case it exists.
     */
    where: bn_adsWhereUniqueInput
    /**
     * In case the bn_ads found by the `where` argument doesn't exist, create a new bn_ads with this data.
     */
    create: XOR<bn_adsCreateInput, bn_adsUncheckedCreateInput>
    /**
     * In case the bn_ads was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bn_adsUpdateInput, bn_adsUncheckedUpdateInput>
  }


  /**
   * bn_ads delete
   */
  export type bn_adsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_ads
     */
    select?: bn_adsSelect<ExtArgs> | null
    /**
     * Filter which bn_ads to delete.
     */
    where: bn_adsWhereUniqueInput
  }


  /**
   * bn_ads deleteMany
   */
  export type bn_adsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_ads to delete
     */
    where?: bn_adsWhereInput
  }


  /**
   * bn_ads without action
   */
  export type bn_adsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_ads
     */
    select?: bn_adsSelect<ExtArgs> | null
  }



  /**
   * Model bn_breaking_news
   */

  export type AggregateBn_breaking_news = {
    _count: Bn_breaking_newsCountAggregateOutputType | null
    _avg: Bn_breaking_newsAvgAggregateOutputType | null
    _sum: Bn_breaking_newsSumAggregateOutputType | null
    _min: Bn_breaking_newsMinAggregateOutputType | null
    _max: Bn_breaking_newsMaxAggregateOutputType | null
  }

  export type Bn_breaking_newsAvgAggregateOutputType = {
    id: number | null
    position: number | null
    hours: number | null
    user_id: number | null
  }

  export type Bn_breaking_newsSumAggregateOutputType = {
    id: number | null
    position: number | null
    hours: number | null
    user_id: number | null
  }

  export type Bn_breaking_newsMinAggregateOutputType = {
    id: number | null
    news_title: string | null
    news_link: string | null
    position: number | null
    hours: number | null
    user_id: number | null
    expired_time: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_breaking_newsMaxAggregateOutputType = {
    id: number | null
    news_title: string | null
    news_link: string | null
    position: number | null
    hours: number | null
    user_id: number | null
    expired_time: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_breaking_newsCountAggregateOutputType = {
    id: number
    news_title: number
    news_link: number
    position: number
    hours: number
    user_id: number
    expired_time: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Bn_breaking_newsAvgAggregateInputType = {
    id?: true
    position?: true
    hours?: true
    user_id?: true
  }

  export type Bn_breaking_newsSumAggregateInputType = {
    id?: true
    position?: true
    hours?: true
    user_id?: true
  }

  export type Bn_breaking_newsMinAggregateInputType = {
    id?: true
    news_title?: true
    news_link?: true
    position?: true
    hours?: true
    user_id?: true
    expired_time?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_breaking_newsMaxAggregateInputType = {
    id?: true
    news_title?: true
    news_link?: true
    position?: true
    hours?: true
    user_id?: true
    expired_time?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_breaking_newsCountAggregateInputType = {
    id?: true
    news_title?: true
    news_link?: true
    position?: true
    hours?: true
    user_id?: true
    expired_time?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Bn_breaking_newsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_breaking_news to aggregate.
     */
    where?: bn_breaking_newsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_breaking_news to fetch.
     */
    orderBy?: bn_breaking_newsOrderByWithRelationInput | bn_breaking_newsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bn_breaking_newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_breaking_news from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_breaking_news.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bn_breaking_news
    **/
    _count?: true | Bn_breaking_newsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bn_breaking_newsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bn_breaking_newsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bn_breaking_newsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bn_breaking_newsMaxAggregateInputType
  }

  export type GetBn_breaking_newsAggregateType<T extends Bn_breaking_newsAggregateArgs> = {
        [P in keyof T & keyof AggregateBn_breaking_news]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBn_breaking_news[P]>
      : GetScalarType<T[P], AggregateBn_breaking_news[P]>
  }




  export type bn_breaking_newsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bn_breaking_newsWhereInput
    orderBy?: bn_breaking_newsOrderByWithAggregationInput | bn_breaking_newsOrderByWithAggregationInput[]
    by: Bn_breaking_newsScalarFieldEnum[] | Bn_breaking_newsScalarFieldEnum
    having?: bn_breaking_newsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bn_breaking_newsCountAggregateInputType | true
    _avg?: Bn_breaking_newsAvgAggregateInputType
    _sum?: Bn_breaking_newsSumAggregateInputType
    _min?: Bn_breaking_newsMinAggregateInputType
    _max?: Bn_breaking_newsMaxAggregateInputType
  }

  export type Bn_breaking_newsGroupByOutputType = {
    id: number
    news_title: string | null
    news_link: string | null
    position: number | null
    hours: number | null
    user_id: number
    expired_time: Date | null
    created_at: Date | null
    updated_at: Date | null
    _count: Bn_breaking_newsCountAggregateOutputType | null
    _avg: Bn_breaking_newsAvgAggregateOutputType | null
    _sum: Bn_breaking_newsSumAggregateOutputType | null
    _min: Bn_breaking_newsMinAggregateOutputType | null
    _max: Bn_breaking_newsMaxAggregateOutputType | null
  }

  type GetBn_breaking_newsGroupByPayload<T extends bn_breaking_newsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bn_breaking_newsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bn_breaking_newsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bn_breaking_newsGroupByOutputType[P]>
            : GetScalarType<T[P], Bn_breaking_newsGroupByOutputType[P]>
        }
      >
    >


  export type bn_breaking_newsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    news_title?: boolean
    news_link?: boolean
    position?: boolean
    hours?: boolean
    user_id?: boolean
    expired_time?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["bn_breaking_news"]>

  export type bn_breaking_newsSelectScalar = {
    id?: boolean
    news_title?: boolean
    news_link?: boolean
    position?: boolean
    hours?: boolean
    user_id?: boolean
    expired_time?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $bn_breaking_newsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bn_breaking_news"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      news_title: string | null
      news_link: string | null
      position: number | null
      hours: number | null
      user_id: number
      expired_time: Date | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["bn_breaking_news"]>
    composites: {}
  }


  type bn_breaking_newsGetPayload<S extends boolean | null | undefined | bn_breaking_newsDefaultArgs> = $Result.GetResult<Prisma.$bn_breaking_newsPayload, S>

  type bn_breaking_newsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bn_breaking_newsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bn_breaking_newsCountAggregateInputType | true
    }

  export interface bn_breaking_newsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bn_breaking_news'], meta: { name: 'bn_breaking_news' } }
    /**
     * Find zero or one Bn_breaking_news that matches the filter.
     * @param {bn_breaking_newsFindUniqueArgs} args - Arguments to find a Bn_breaking_news
     * @example
     * // Get one Bn_breaking_news
     * const bn_breaking_news = await prisma.bn_breaking_news.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bn_breaking_newsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bn_breaking_newsFindUniqueArgs<ExtArgs>>
    ): Prisma__bn_breaking_newsClient<$Result.GetResult<Prisma.$bn_breaking_newsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bn_breaking_news that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bn_breaking_newsFindUniqueOrThrowArgs} args - Arguments to find a Bn_breaking_news
     * @example
     * // Get one Bn_breaking_news
     * const bn_breaking_news = await prisma.bn_breaking_news.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bn_breaking_newsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_breaking_newsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bn_breaking_newsClient<$Result.GetResult<Prisma.$bn_breaking_newsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bn_breaking_news that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_breaking_newsFindFirstArgs} args - Arguments to find a Bn_breaking_news
     * @example
     * // Get one Bn_breaking_news
     * const bn_breaking_news = await prisma.bn_breaking_news.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bn_breaking_newsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_breaking_newsFindFirstArgs<ExtArgs>>
    ): Prisma__bn_breaking_newsClient<$Result.GetResult<Prisma.$bn_breaking_newsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bn_breaking_news that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_breaking_newsFindFirstOrThrowArgs} args - Arguments to find a Bn_breaking_news
     * @example
     * // Get one Bn_breaking_news
     * const bn_breaking_news = await prisma.bn_breaking_news.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bn_breaking_newsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_breaking_newsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bn_breaking_newsClient<$Result.GetResult<Prisma.$bn_breaking_newsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bn_breaking_news that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_breaking_newsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bn_breaking_news
     * const bn_breaking_news = await prisma.bn_breaking_news.findMany()
     * 
     * // Get first 10 Bn_breaking_news
     * const bn_breaking_news = await prisma.bn_breaking_news.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bn_breaking_newsWithIdOnly = await prisma.bn_breaking_news.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends bn_breaking_newsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_breaking_newsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bn_breaking_newsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bn_breaking_news.
     * @param {bn_breaking_newsCreateArgs} args - Arguments to create a Bn_breaking_news.
     * @example
     * // Create one Bn_breaking_news
     * const Bn_breaking_news = await prisma.bn_breaking_news.create({
     *   data: {
     *     // ... data to create a Bn_breaking_news
     *   }
     * })
     * 
    **/
    create<T extends bn_breaking_newsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_breaking_newsCreateArgs<ExtArgs>>
    ): Prisma__bn_breaking_newsClient<$Result.GetResult<Prisma.$bn_breaking_newsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bn_breaking_news.
     *     @param {bn_breaking_newsCreateManyArgs} args - Arguments to create many Bn_breaking_news.
     *     @example
     *     // Create many Bn_breaking_news
     *     const bn_breaking_news = await prisma.bn_breaking_news.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bn_breaking_newsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_breaking_newsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bn_breaking_news.
     * @param {bn_breaking_newsDeleteArgs} args - Arguments to delete one Bn_breaking_news.
     * @example
     * // Delete one Bn_breaking_news
     * const Bn_breaking_news = await prisma.bn_breaking_news.delete({
     *   where: {
     *     // ... filter to delete one Bn_breaking_news
     *   }
     * })
     * 
    **/
    delete<T extends bn_breaking_newsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bn_breaking_newsDeleteArgs<ExtArgs>>
    ): Prisma__bn_breaking_newsClient<$Result.GetResult<Prisma.$bn_breaking_newsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bn_breaking_news.
     * @param {bn_breaking_newsUpdateArgs} args - Arguments to update one Bn_breaking_news.
     * @example
     * // Update one Bn_breaking_news
     * const bn_breaking_news = await prisma.bn_breaking_news.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bn_breaking_newsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_breaking_newsUpdateArgs<ExtArgs>>
    ): Prisma__bn_breaking_newsClient<$Result.GetResult<Prisma.$bn_breaking_newsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bn_breaking_news.
     * @param {bn_breaking_newsDeleteManyArgs} args - Arguments to filter Bn_breaking_news to delete.
     * @example
     * // Delete a few Bn_breaking_news
     * const { count } = await prisma.bn_breaking_news.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bn_breaking_newsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_breaking_newsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bn_breaking_news.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_breaking_newsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bn_breaking_news
     * const bn_breaking_news = await prisma.bn_breaking_news.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bn_breaking_newsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bn_breaking_newsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bn_breaking_news.
     * @param {bn_breaking_newsUpsertArgs} args - Arguments to update or create a Bn_breaking_news.
     * @example
     * // Update or create a Bn_breaking_news
     * const bn_breaking_news = await prisma.bn_breaking_news.upsert({
     *   create: {
     *     // ... data to create a Bn_breaking_news
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bn_breaking_news we want to update
     *   }
     * })
    **/
    upsert<T extends bn_breaking_newsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bn_breaking_newsUpsertArgs<ExtArgs>>
    ): Prisma__bn_breaking_newsClient<$Result.GetResult<Prisma.$bn_breaking_newsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bn_breaking_news.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_breaking_newsCountArgs} args - Arguments to filter Bn_breaking_news to count.
     * @example
     * // Count the number of Bn_breaking_news
     * const count = await prisma.bn_breaking_news.count({
     *   where: {
     *     // ... the filter for the Bn_breaking_news we want to count
     *   }
     * })
    **/
    count<T extends bn_breaking_newsCountArgs>(
      args?: Subset<T, bn_breaking_newsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bn_breaking_newsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bn_breaking_news.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bn_breaking_newsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bn_breaking_newsAggregateArgs>(args: Subset<T, Bn_breaking_newsAggregateArgs>): Prisma.PrismaPromise<GetBn_breaking_newsAggregateType<T>>

    /**
     * Group by Bn_breaking_news.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_breaking_newsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bn_breaking_newsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bn_breaking_newsGroupByArgs['orderBy'] }
        : { orderBy?: bn_breaking_newsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bn_breaking_newsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBn_breaking_newsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bn_breaking_news model
   */
  readonly fields: bn_breaking_newsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bn_breaking_news.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bn_breaking_newsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bn_breaking_news model
   */ 
  interface bn_breaking_newsFieldRefs {
    readonly id: FieldRef<"bn_breaking_news", 'Int'>
    readonly news_title: FieldRef<"bn_breaking_news", 'String'>
    readonly news_link: FieldRef<"bn_breaking_news", 'String'>
    readonly position: FieldRef<"bn_breaking_news", 'Int'>
    readonly hours: FieldRef<"bn_breaking_news", 'Int'>
    readonly user_id: FieldRef<"bn_breaking_news", 'Int'>
    readonly expired_time: FieldRef<"bn_breaking_news", 'DateTime'>
    readonly created_at: FieldRef<"bn_breaking_news", 'DateTime'>
    readonly updated_at: FieldRef<"bn_breaking_news", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * bn_breaking_news findUnique
   */
  export type bn_breaking_newsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_breaking_news
     */
    select?: bn_breaking_newsSelect<ExtArgs> | null
    /**
     * Filter, which bn_breaking_news to fetch.
     */
    where: bn_breaking_newsWhereUniqueInput
  }


  /**
   * bn_breaking_news findUniqueOrThrow
   */
  export type bn_breaking_newsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_breaking_news
     */
    select?: bn_breaking_newsSelect<ExtArgs> | null
    /**
     * Filter, which bn_breaking_news to fetch.
     */
    where: bn_breaking_newsWhereUniqueInput
  }


  /**
   * bn_breaking_news findFirst
   */
  export type bn_breaking_newsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_breaking_news
     */
    select?: bn_breaking_newsSelect<ExtArgs> | null
    /**
     * Filter, which bn_breaking_news to fetch.
     */
    where?: bn_breaking_newsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_breaking_news to fetch.
     */
    orderBy?: bn_breaking_newsOrderByWithRelationInput | bn_breaking_newsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_breaking_news.
     */
    cursor?: bn_breaking_newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_breaking_news from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_breaking_news.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_breaking_news.
     */
    distinct?: Bn_breaking_newsScalarFieldEnum | Bn_breaking_newsScalarFieldEnum[]
  }


  /**
   * bn_breaking_news findFirstOrThrow
   */
  export type bn_breaking_newsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_breaking_news
     */
    select?: bn_breaking_newsSelect<ExtArgs> | null
    /**
     * Filter, which bn_breaking_news to fetch.
     */
    where?: bn_breaking_newsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_breaking_news to fetch.
     */
    orderBy?: bn_breaking_newsOrderByWithRelationInput | bn_breaking_newsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_breaking_news.
     */
    cursor?: bn_breaking_newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_breaking_news from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_breaking_news.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_breaking_news.
     */
    distinct?: Bn_breaking_newsScalarFieldEnum | Bn_breaking_newsScalarFieldEnum[]
  }


  /**
   * bn_breaking_news findMany
   */
  export type bn_breaking_newsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_breaking_news
     */
    select?: bn_breaking_newsSelect<ExtArgs> | null
    /**
     * Filter, which bn_breaking_news to fetch.
     */
    where?: bn_breaking_newsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_breaking_news to fetch.
     */
    orderBy?: bn_breaking_newsOrderByWithRelationInput | bn_breaking_newsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bn_breaking_news.
     */
    cursor?: bn_breaking_newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_breaking_news from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_breaking_news.
     */
    skip?: number
    distinct?: Bn_breaking_newsScalarFieldEnum | Bn_breaking_newsScalarFieldEnum[]
  }


  /**
   * bn_breaking_news create
   */
  export type bn_breaking_newsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_breaking_news
     */
    select?: bn_breaking_newsSelect<ExtArgs> | null
    /**
     * The data needed to create a bn_breaking_news.
     */
    data: XOR<bn_breaking_newsCreateInput, bn_breaking_newsUncheckedCreateInput>
  }


  /**
   * bn_breaking_news createMany
   */
  export type bn_breaking_newsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bn_breaking_news.
     */
    data: bn_breaking_newsCreateManyInput | bn_breaking_newsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bn_breaking_news update
   */
  export type bn_breaking_newsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_breaking_news
     */
    select?: bn_breaking_newsSelect<ExtArgs> | null
    /**
     * The data needed to update a bn_breaking_news.
     */
    data: XOR<bn_breaking_newsUpdateInput, bn_breaking_newsUncheckedUpdateInput>
    /**
     * Choose, which bn_breaking_news to update.
     */
    where: bn_breaking_newsWhereUniqueInput
  }


  /**
   * bn_breaking_news updateMany
   */
  export type bn_breaking_newsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bn_breaking_news.
     */
    data: XOR<bn_breaking_newsUpdateManyMutationInput, bn_breaking_newsUncheckedUpdateManyInput>
    /**
     * Filter which bn_breaking_news to update
     */
    where?: bn_breaking_newsWhereInput
  }


  /**
   * bn_breaking_news upsert
   */
  export type bn_breaking_newsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_breaking_news
     */
    select?: bn_breaking_newsSelect<ExtArgs> | null
    /**
     * The filter to search for the bn_breaking_news to update in case it exists.
     */
    where: bn_breaking_newsWhereUniqueInput
    /**
     * In case the bn_breaking_news found by the `where` argument doesn't exist, create a new bn_breaking_news with this data.
     */
    create: XOR<bn_breaking_newsCreateInput, bn_breaking_newsUncheckedCreateInput>
    /**
     * In case the bn_breaking_news was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bn_breaking_newsUpdateInput, bn_breaking_newsUncheckedUpdateInput>
  }


  /**
   * bn_breaking_news delete
   */
  export type bn_breaking_newsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_breaking_news
     */
    select?: bn_breaking_newsSelect<ExtArgs> | null
    /**
     * Filter which bn_breaking_news to delete.
     */
    where: bn_breaking_newsWhereUniqueInput
  }


  /**
   * bn_breaking_news deleteMany
   */
  export type bn_breaking_newsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_breaking_news to delete
     */
    where?: bn_breaking_newsWhereInput
  }


  /**
   * bn_breaking_news without action
   */
  export type bn_breaking_newsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_breaking_news
     */
    select?: bn_breaking_newsSelect<ExtArgs> | null
  }



  /**
   * Model bn_categories
   */

  export type AggregateBn_categories = {
    _count: Bn_categoriesCountAggregateOutputType | null
    _avg: Bn_categoriesAvgAggregateOutputType | null
    _sum: Bn_categoriesSumAggregateOutputType | null
    _min: Bn_categoriesMinAggregateOutputType | null
    _max: Bn_categoriesMaxAggregateOutputType | null
  }

  export type Bn_categoriesAvgAggregateOutputType = {
    cat_id: number | null
    cat_type: number | null
    cat_position: number | null
    top_menu: number | null
    footer_menu: number | null
    status: number | null
    deletable: number | null
  }

  export type Bn_categoriesSumAggregateOutputType = {
    cat_id: number | null
    cat_type: number | null
    cat_position: number | null
    top_menu: number | null
    footer_menu: number | null
    status: number | null
    deletable: number | null
  }

  export type Bn_categoriesMinAggregateOutputType = {
    cat_id: number | null
    cat_type: number | null
    cat_name: string | null
    cat_name_bn: string | null
    cat_slug: string | null
    cat_title: string | null
    cat_meta_keyword: string | null
    cat_meta_description: string | null
    cat_position: number | null
    top_menu: number | null
    footer_menu: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_categoriesMaxAggregateOutputType = {
    cat_id: number | null
    cat_type: number | null
    cat_name: string | null
    cat_name_bn: string | null
    cat_slug: string | null
    cat_title: string | null
    cat_meta_keyword: string | null
    cat_meta_description: string | null
    cat_position: number | null
    top_menu: number | null
    footer_menu: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_categoriesCountAggregateOutputType = {
    cat_id: number
    cat_type: number
    cat_name: number
    cat_name_bn: number
    cat_slug: number
    cat_title: number
    cat_meta_keyword: number
    cat_meta_description: number
    cat_position: number
    top_menu: number
    footer_menu: number
    status: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Bn_categoriesAvgAggregateInputType = {
    cat_id?: true
    cat_type?: true
    cat_position?: true
    top_menu?: true
    footer_menu?: true
    status?: true
    deletable?: true
  }

  export type Bn_categoriesSumAggregateInputType = {
    cat_id?: true
    cat_type?: true
    cat_position?: true
    top_menu?: true
    footer_menu?: true
    status?: true
    deletable?: true
  }

  export type Bn_categoriesMinAggregateInputType = {
    cat_id?: true
    cat_type?: true
    cat_name?: true
    cat_name_bn?: true
    cat_slug?: true
    cat_title?: true
    cat_meta_keyword?: true
    cat_meta_description?: true
    cat_position?: true
    top_menu?: true
    footer_menu?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_categoriesMaxAggregateInputType = {
    cat_id?: true
    cat_type?: true
    cat_name?: true
    cat_name_bn?: true
    cat_slug?: true
    cat_title?: true
    cat_meta_keyword?: true
    cat_meta_description?: true
    cat_position?: true
    top_menu?: true
    footer_menu?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_categoriesCountAggregateInputType = {
    cat_id?: true
    cat_type?: true
    cat_name?: true
    cat_name_bn?: true
    cat_slug?: true
    cat_title?: true
    cat_meta_keyword?: true
    cat_meta_description?: true
    cat_position?: true
    top_menu?: true
    footer_menu?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Bn_categoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_categories to aggregate.
     */
    where?: bn_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_categories to fetch.
     */
    orderBy?: bn_categoriesOrderByWithRelationInput | bn_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bn_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bn_categories
    **/
    _count?: true | Bn_categoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bn_categoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bn_categoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bn_categoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bn_categoriesMaxAggregateInputType
  }

  export type GetBn_categoriesAggregateType<T extends Bn_categoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateBn_categories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBn_categories[P]>
      : GetScalarType<T[P], AggregateBn_categories[P]>
  }




  export type bn_categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bn_categoriesWhereInput
    orderBy?: bn_categoriesOrderByWithAggregationInput | bn_categoriesOrderByWithAggregationInput[]
    by: Bn_categoriesScalarFieldEnum[] | Bn_categoriesScalarFieldEnum
    having?: bn_categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bn_categoriesCountAggregateInputType | true
    _avg?: Bn_categoriesAvgAggregateInputType
    _sum?: Bn_categoriesSumAggregateInputType
    _min?: Bn_categoriesMinAggregateInputType
    _max?: Bn_categoriesMaxAggregateInputType
  }

  export type Bn_categoriesGroupByOutputType = {
    cat_id: number
    cat_type: number
    cat_name: string
    cat_name_bn: string
    cat_slug: string
    cat_title: string | null
    cat_meta_keyword: string | null
    cat_meta_description: string | null
    cat_position: number
    top_menu: number
    footer_menu: number
    status: number
    deletable: number
    created_at: Date | null
    updated_at: Date | null
    _count: Bn_categoriesCountAggregateOutputType | null
    _avg: Bn_categoriesAvgAggregateOutputType | null
    _sum: Bn_categoriesSumAggregateOutputType | null
    _min: Bn_categoriesMinAggregateOutputType | null
    _max: Bn_categoriesMaxAggregateOutputType | null
  }

  type GetBn_categoriesGroupByPayload<T extends bn_categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bn_categoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bn_categoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bn_categoriesGroupByOutputType[P]>
            : GetScalarType<T[P], Bn_categoriesGroupByOutputType[P]>
        }
      >
    >


  export type bn_categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cat_id?: boolean
    cat_type?: boolean
    cat_name?: boolean
    cat_name_bn?: boolean
    cat_slug?: boolean
    cat_title?: boolean
    cat_meta_keyword?: boolean
    cat_meta_description?: boolean
    cat_position?: boolean
    top_menu?: boolean
    footer_menu?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["bn_categories"]>

  export type bn_categoriesSelectScalar = {
    cat_id?: boolean
    cat_type?: boolean
    cat_name?: boolean
    cat_name_bn?: boolean
    cat_slug?: boolean
    cat_title?: boolean
    cat_meta_keyword?: boolean
    cat_meta_description?: boolean
    cat_position?: boolean
    top_menu?: boolean
    footer_menu?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $bn_categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bn_categories"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      cat_id: number
      cat_type: number
      cat_name: string
      cat_name_bn: string
      cat_slug: string
      cat_title: string | null
      cat_meta_keyword: string | null
      cat_meta_description: string | null
      cat_position: number
      top_menu: number
      footer_menu: number
      status: number
      deletable: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["bn_categories"]>
    composites: {}
  }


  type bn_categoriesGetPayload<S extends boolean | null | undefined | bn_categoriesDefaultArgs> = $Result.GetResult<Prisma.$bn_categoriesPayload, S>

  type bn_categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bn_categoriesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bn_categoriesCountAggregateInputType | true
    }

  export interface bn_categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bn_categories'], meta: { name: 'bn_categories' } }
    /**
     * Find zero or one Bn_categories that matches the filter.
     * @param {bn_categoriesFindUniqueArgs} args - Arguments to find a Bn_categories
     * @example
     * // Get one Bn_categories
     * const bn_categories = await prisma.bn_categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bn_categoriesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bn_categoriesFindUniqueArgs<ExtArgs>>
    ): Prisma__bn_categoriesClient<$Result.GetResult<Prisma.$bn_categoriesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bn_categories that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bn_categoriesFindUniqueOrThrowArgs} args - Arguments to find a Bn_categories
     * @example
     * // Get one Bn_categories
     * const bn_categories = await prisma.bn_categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bn_categoriesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_categoriesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bn_categoriesClient<$Result.GetResult<Prisma.$bn_categoriesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bn_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_categoriesFindFirstArgs} args - Arguments to find a Bn_categories
     * @example
     * // Get one Bn_categories
     * const bn_categories = await prisma.bn_categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bn_categoriesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_categoriesFindFirstArgs<ExtArgs>>
    ): Prisma__bn_categoriesClient<$Result.GetResult<Prisma.$bn_categoriesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bn_categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_categoriesFindFirstOrThrowArgs} args - Arguments to find a Bn_categories
     * @example
     * // Get one Bn_categories
     * const bn_categories = await prisma.bn_categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bn_categoriesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_categoriesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bn_categoriesClient<$Result.GetResult<Prisma.$bn_categoriesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bn_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_categoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bn_categories
     * const bn_categories = await prisma.bn_categories.findMany()
     * 
     * // Get first 10 Bn_categories
     * const bn_categories = await prisma.bn_categories.findMany({ take: 10 })
     * 
     * // Only select the `cat_id`
     * const bn_categoriesWithCat_idOnly = await prisma.bn_categories.findMany({ select: { cat_id: true } })
     * 
    **/
    findMany<T extends bn_categoriesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_categoriesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bn_categoriesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bn_categories.
     * @param {bn_categoriesCreateArgs} args - Arguments to create a Bn_categories.
     * @example
     * // Create one Bn_categories
     * const Bn_categories = await prisma.bn_categories.create({
     *   data: {
     *     // ... data to create a Bn_categories
     *   }
     * })
     * 
    **/
    create<T extends bn_categoriesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_categoriesCreateArgs<ExtArgs>>
    ): Prisma__bn_categoriesClient<$Result.GetResult<Prisma.$bn_categoriesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bn_categories.
     *     @param {bn_categoriesCreateManyArgs} args - Arguments to create many Bn_categories.
     *     @example
     *     // Create many Bn_categories
     *     const bn_categories = await prisma.bn_categories.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bn_categoriesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_categoriesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bn_categories.
     * @param {bn_categoriesDeleteArgs} args - Arguments to delete one Bn_categories.
     * @example
     * // Delete one Bn_categories
     * const Bn_categories = await prisma.bn_categories.delete({
     *   where: {
     *     // ... filter to delete one Bn_categories
     *   }
     * })
     * 
    **/
    delete<T extends bn_categoriesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bn_categoriesDeleteArgs<ExtArgs>>
    ): Prisma__bn_categoriesClient<$Result.GetResult<Prisma.$bn_categoriesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bn_categories.
     * @param {bn_categoriesUpdateArgs} args - Arguments to update one Bn_categories.
     * @example
     * // Update one Bn_categories
     * const bn_categories = await prisma.bn_categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bn_categoriesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_categoriesUpdateArgs<ExtArgs>>
    ): Prisma__bn_categoriesClient<$Result.GetResult<Prisma.$bn_categoriesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bn_categories.
     * @param {bn_categoriesDeleteManyArgs} args - Arguments to filter Bn_categories to delete.
     * @example
     * // Delete a few Bn_categories
     * const { count } = await prisma.bn_categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bn_categoriesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_categoriesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bn_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bn_categories
     * const bn_categories = await prisma.bn_categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bn_categoriesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bn_categoriesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bn_categories.
     * @param {bn_categoriesUpsertArgs} args - Arguments to update or create a Bn_categories.
     * @example
     * // Update or create a Bn_categories
     * const bn_categories = await prisma.bn_categories.upsert({
     *   create: {
     *     // ... data to create a Bn_categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bn_categories we want to update
     *   }
     * })
    **/
    upsert<T extends bn_categoriesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bn_categoriesUpsertArgs<ExtArgs>>
    ): Prisma__bn_categoriesClient<$Result.GetResult<Prisma.$bn_categoriesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bn_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_categoriesCountArgs} args - Arguments to filter Bn_categories to count.
     * @example
     * // Count the number of Bn_categories
     * const count = await prisma.bn_categories.count({
     *   where: {
     *     // ... the filter for the Bn_categories we want to count
     *   }
     * })
    **/
    count<T extends bn_categoriesCountArgs>(
      args?: Subset<T, bn_categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bn_categoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bn_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bn_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bn_categoriesAggregateArgs>(args: Subset<T, Bn_categoriesAggregateArgs>): Prisma.PrismaPromise<GetBn_categoriesAggregateType<T>>

    /**
     * Group by Bn_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bn_categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bn_categoriesGroupByArgs['orderBy'] }
        : { orderBy?: bn_categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bn_categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBn_categoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bn_categories model
   */
  readonly fields: bn_categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bn_categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bn_categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bn_categories model
   */ 
  interface bn_categoriesFieldRefs {
    readonly cat_id: FieldRef<"bn_categories", 'Int'>
    readonly cat_type: FieldRef<"bn_categories", 'Int'>
    readonly cat_name: FieldRef<"bn_categories", 'String'>
    readonly cat_name_bn: FieldRef<"bn_categories", 'String'>
    readonly cat_slug: FieldRef<"bn_categories", 'String'>
    readonly cat_title: FieldRef<"bn_categories", 'String'>
    readonly cat_meta_keyword: FieldRef<"bn_categories", 'String'>
    readonly cat_meta_description: FieldRef<"bn_categories", 'String'>
    readonly cat_position: FieldRef<"bn_categories", 'Int'>
    readonly top_menu: FieldRef<"bn_categories", 'Int'>
    readonly footer_menu: FieldRef<"bn_categories", 'Int'>
    readonly status: FieldRef<"bn_categories", 'Int'>
    readonly deletable: FieldRef<"bn_categories", 'Int'>
    readonly created_at: FieldRef<"bn_categories", 'DateTime'>
    readonly updated_at: FieldRef<"bn_categories", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * bn_categories findUnique
   */
  export type bn_categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_categories
     */
    select?: bn_categoriesSelect<ExtArgs> | null
    /**
     * Filter, which bn_categories to fetch.
     */
    where: bn_categoriesWhereUniqueInput
  }


  /**
   * bn_categories findUniqueOrThrow
   */
  export type bn_categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_categories
     */
    select?: bn_categoriesSelect<ExtArgs> | null
    /**
     * Filter, which bn_categories to fetch.
     */
    where: bn_categoriesWhereUniqueInput
  }


  /**
   * bn_categories findFirst
   */
  export type bn_categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_categories
     */
    select?: bn_categoriesSelect<ExtArgs> | null
    /**
     * Filter, which bn_categories to fetch.
     */
    where?: bn_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_categories to fetch.
     */
    orderBy?: bn_categoriesOrderByWithRelationInput | bn_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_categories.
     */
    cursor?: bn_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_categories.
     */
    distinct?: Bn_categoriesScalarFieldEnum | Bn_categoriesScalarFieldEnum[]
  }


  /**
   * bn_categories findFirstOrThrow
   */
  export type bn_categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_categories
     */
    select?: bn_categoriesSelect<ExtArgs> | null
    /**
     * Filter, which bn_categories to fetch.
     */
    where?: bn_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_categories to fetch.
     */
    orderBy?: bn_categoriesOrderByWithRelationInput | bn_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_categories.
     */
    cursor?: bn_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_categories.
     */
    distinct?: Bn_categoriesScalarFieldEnum | Bn_categoriesScalarFieldEnum[]
  }


  /**
   * bn_categories findMany
   */
  export type bn_categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_categories
     */
    select?: bn_categoriesSelect<ExtArgs> | null
    /**
     * Filter, which bn_categories to fetch.
     */
    where?: bn_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_categories to fetch.
     */
    orderBy?: bn_categoriesOrderByWithRelationInput | bn_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bn_categories.
     */
    cursor?: bn_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_categories.
     */
    skip?: number
    distinct?: Bn_categoriesScalarFieldEnum | Bn_categoriesScalarFieldEnum[]
  }


  /**
   * bn_categories create
   */
  export type bn_categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_categories
     */
    select?: bn_categoriesSelect<ExtArgs> | null
    /**
     * The data needed to create a bn_categories.
     */
    data: XOR<bn_categoriesCreateInput, bn_categoriesUncheckedCreateInput>
  }


  /**
   * bn_categories createMany
   */
  export type bn_categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bn_categories.
     */
    data: bn_categoriesCreateManyInput | bn_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bn_categories update
   */
  export type bn_categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_categories
     */
    select?: bn_categoriesSelect<ExtArgs> | null
    /**
     * The data needed to update a bn_categories.
     */
    data: XOR<bn_categoriesUpdateInput, bn_categoriesUncheckedUpdateInput>
    /**
     * Choose, which bn_categories to update.
     */
    where: bn_categoriesWhereUniqueInput
  }


  /**
   * bn_categories updateMany
   */
  export type bn_categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bn_categories.
     */
    data: XOR<bn_categoriesUpdateManyMutationInput, bn_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which bn_categories to update
     */
    where?: bn_categoriesWhereInput
  }


  /**
   * bn_categories upsert
   */
  export type bn_categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_categories
     */
    select?: bn_categoriesSelect<ExtArgs> | null
    /**
     * The filter to search for the bn_categories to update in case it exists.
     */
    where: bn_categoriesWhereUniqueInput
    /**
     * In case the bn_categories found by the `where` argument doesn't exist, create a new bn_categories with this data.
     */
    create: XOR<bn_categoriesCreateInput, bn_categoriesUncheckedCreateInput>
    /**
     * In case the bn_categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bn_categoriesUpdateInput, bn_categoriesUncheckedUpdateInput>
  }


  /**
   * bn_categories delete
   */
  export type bn_categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_categories
     */
    select?: bn_categoriesSelect<ExtArgs> | null
    /**
     * Filter which bn_categories to delete.
     */
    where: bn_categoriesWhereUniqueInput
  }


  /**
   * bn_categories deleteMany
   */
  export type bn_categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_categories to delete
     */
    where?: bn_categoriesWhereInput
  }


  /**
   * bn_categories without action
   */
  export type bn_categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_categories
     */
    select?: bn_categoriesSelect<ExtArgs> | null
  }



  /**
   * Model bn_content_positions
   */

  export type AggregateBn_content_positions = {
    _count: Bn_content_positionsCountAggregateOutputType | null
    _avg: Bn_content_positionsAvgAggregateOutputType | null
    _sum: Bn_content_positionsSumAggregateOutputType | null
    _min: Bn_content_positionsMinAggregateOutputType | null
    _max: Bn_content_positionsMaxAggregateOutputType | null
  }

  export type Bn_content_positionsAvgAggregateOutputType = {
    position_id: number | null
    cat_id: number | null
    special_cat_id: number | null
    subcat_id: number | null
    total_content: number | null
    status: number | null
    deletable: number | null
  }

  export type Bn_content_positionsSumAggregateOutputType = {
    position_id: number | null
    cat_id: number | null
    special_cat_id: number | null
    subcat_id: number | null
    total_content: number | null
    status: number | null
    deletable: number | null
  }

  export type Bn_content_positionsMinAggregateOutputType = {
    position_id: number | null
    position_name: string | null
    position_slug: string | null
    cat_id: number | null
    special_cat_id: number | null
    subcat_id: number | null
    content_ids: string | null
    total_content: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_content_positionsMaxAggregateOutputType = {
    position_id: number | null
    position_name: string | null
    position_slug: string | null
    cat_id: number | null
    special_cat_id: number | null
    subcat_id: number | null
    content_ids: string | null
    total_content: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_content_positionsCountAggregateOutputType = {
    position_id: number
    position_name: number
    position_slug: number
    cat_id: number
    special_cat_id: number
    subcat_id: number
    content_ids: number
    total_content: number
    status: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Bn_content_positionsAvgAggregateInputType = {
    position_id?: true
    cat_id?: true
    special_cat_id?: true
    subcat_id?: true
    total_content?: true
    status?: true
    deletable?: true
  }

  export type Bn_content_positionsSumAggregateInputType = {
    position_id?: true
    cat_id?: true
    special_cat_id?: true
    subcat_id?: true
    total_content?: true
    status?: true
    deletable?: true
  }

  export type Bn_content_positionsMinAggregateInputType = {
    position_id?: true
    position_name?: true
    position_slug?: true
    cat_id?: true
    special_cat_id?: true
    subcat_id?: true
    content_ids?: true
    total_content?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_content_positionsMaxAggregateInputType = {
    position_id?: true
    position_name?: true
    position_slug?: true
    cat_id?: true
    special_cat_id?: true
    subcat_id?: true
    content_ids?: true
    total_content?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_content_positionsCountAggregateInputType = {
    position_id?: true
    position_name?: true
    position_slug?: true
    cat_id?: true
    special_cat_id?: true
    subcat_id?: true
    content_ids?: true
    total_content?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Bn_content_positionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_content_positions to aggregate.
     */
    where?: bn_content_positionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_content_positions to fetch.
     */
    orderBy?: bn_content_positionsOrderByWithRelationInput | bn_content_positionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bn_content_positionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_content_positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_content_positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bn_content_positions
    **/
    _count?: true | Bn_content_positionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bn_content_positionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bn_content_positionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bn_content_positionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bn_content_positionsMaxAggregateInputType
  }

  export type GetBn_content_positionsAggregateType<T extends Bn_content_positionsAggregateArgs> = {
        [P in keyof T & keyof AggregateBn_content_positions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBn_content_positions[P]>
      : GetScalarType<T[P], AggregateBn_content_positions[P]>
  }




  export type bn_content_positionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bn_content_positionsWhereInput
    orderBy?: bn_content_positionsOrderByWithAggregationInput | bn_content_positionsOrderByWithAggregationInput[]
    by: Bn_content_positionsScalarFieldEnum[] | Bn_content_positionsScalarFieldEnum
    having?: bn_content_positionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bn_content_positionsCountAggregateInputType | true
    _avg?: Bn_content_positionsAvgAggregateInputType
    _sum?: Bn_content_positionsSumAggregateInputType
    _min?: Bn_content_positionsMinAggregateInputType
    _max?: Bn_content_positionsMaxAggregateInputType
  }

  export type Bn_content_positionsGroupByOutputType = {
    position_id: number
    position_name: string
    position_slug: string
    cat_id: number | null
    special_cat_id: number | null
    subcat_id: number | null
    content_ids: string | null
    total_content: number | null
    status: number
    deletable: number
    created_at: Date | null
    updated_at: Date | null
    _count: Bn_content_positionsCountAggregateOutputType | null
    _avg: Bn_content_positionsAvgAggregateOutputType | null
    _sum: Bn_content_positionsSumAggregateOutputType | null
    _min: Bn_content_positionsMinAggregateOutputType | null
    _max: Bn_content_positionsMaxAggregateOutputType | null
  }

  type GetBn_content_positionsGroupByPayload<T extends bn_content_positionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bn_content_positionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bn_content_positionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bn_content_positionsGroupByOutputType[P]>
            : GetScalarType<T[P], Bn_content_positionsGroupByOutputType[P]>
        }
      >
    >


  export type bn_content_positionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    position_id?: boolean
    position_name?: boolean
    position_slug?: boolean
    cat_id?: boolean
    special_cat_id?: boolean
    subcat_id?: boolean
    content_ids?: boolean
    total_content?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["bn_content_positions"]>

  export type bn_content_positionsSelectScalar = {
    position_id?: boolean
    position_name?: boolean
    position_slug?: boolean
    cat_id?: boolean
    special_cat_id?: boolean
    subcat_id?: boolean
    content_ids?: boolean
    total_content?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $bn_content_positionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bn_content_positions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      position_id: number
      position_name: string
      position_slug: string
      cat_id: number | null
      special_cat_id: number | null
      subcat_id: number | null
      content_ids: string | null
      total_content: number | null
      status: number
      deletable: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["bn_content_positions"]>
    composites: {}
  }


  type bn_content_positionsGetPayload<S extends boolean | null | undefined | bn_content_positionsDefaultArgs> = $Result.GetResult<Prisma.$bn_content_positionsPayload, S>

  type bn_content_positionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bn_content_positionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bn_content_positionsCountAggregateInputType | true
    }

  export interface bn_content_positionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bn_content_positions'], meta: { name: 'bn_content_positions' } }
    /**
     * Find zero or one Bn_content_positions that matches the filter.
     * @param {bn_content_positionsFindUniqueArgs} args - Arguments to find a Bn_content_positions
     * @example
     * // Get one Bn_content_positions
     * const bn_content_positions = await prisma.bn_content_positions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bn_content_positionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bn_content_positionsFindUniqueArgs<ExtArgs>>
    ): Prisma__bn_content_positionsClient<$Result.GetResult<Prisma.$bn_content_positionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bn_content_positions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bn_content_positionsFindUniqueOrThrowArgs} args - Arguments to find a Bn_content_positions
     * @example
     * // Get one Bn_content_positions
     * const bn_content_positions = await prisma.bn_content_positions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bn_content_positionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_content_positionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bn_content_positionsClient<$Result.GetResult<Prisma.$bn_content_positionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bn_content_positions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_content_positionsFindFirstArgs} args - Arguments to find a Bn_content_positions
     * @example
     * // Get one Bn_content_positions
     * const bn_content_positions = await prisma.bn_content_positions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bn_content_positionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_content_positionsFindFirstArgs<ExtArgs>>
    ): Prisma__bn_content_positionsClient<$Result.GetResult<Prisma.$bn_content_positionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bn_content_positions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_content_positionsFindFirstOrThrowArgs} args - Arguments to find a Bn_content_positions
     * @example
     * // Get one Bn_content_positions
     * const bn_content_positions = await prisma.bn_content_positions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bn_content_positionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_content_positionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bn_content_positionsClient<$Result.GetResult<Prisma.$bn_content_positionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bn_content_positions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_content_positionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bn_content_positions
     * const bn_content_positions = await prisma.bn_content_positions.findMany()
     * 
     * // Get first 10 Bn_content_positions
     * const bn_content_positions = await prisma.bn_content_positions.findMany({ take: 10 })
     * 
     * // Only select the `position_id`
     * const bn_content_positionsWithPosition_idOnly = await prisma.bn_content_positions.findMany({ select: { position_id: true } })
     * 
    **/
    findMany<T extends bn_content_positionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_content_positionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bn_content_positionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bn_content_positions.
     * @param {bn_content_positionsCreateArgs} args - Arguments to create a Bn_content_positions.
     * @example
     * // Create one Bn_content_positions
     * const Bn_content_positions = await prisma.bn_content_positions.create({
     *   data: {
     *     // ... data to create a Bn_content_positions
     *   }
     * })
     * 
    **/
    create<T extends bn_content_positionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_content_positionsCreateArgs<ExtArgs>>
    ): Prisma__bn_content_positionsClient<$Result.GetResult<Prisma.$bn_content_positionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bn_content_positions.
     *     @param {bn_content_positionsCreateManyArgs} args - Arguments to create many Bn_content_positions.
     *     @example
     *     // Create many Bn_content_positions
     *     const bn_content_positions = await prisma.bn_content_positions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bn_content_positionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_content_positionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bn_content_positions.
     * @param {bn_content_positionsDeleteArgs} args - Arguments to delete one Bn_content_positions.
     * @example
     * // Delete one Bn_content_positions
     * const Bn_content_positions = await prisma.bn_content_positions.delete({
     *   where: {
     *     // ... filter to delete one Bn_content_positions
     *   }
     * })
     * 
    **/
    delete<T extends bn_content_positionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bn_content_positionsDeleteArgs<ExtArgs>>
    ): Prisma__bn_content_positionsClient<$Result.GetResult<Prisma.$bn_content_positionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bn_content_positions.
     * @param {bn_content_positionsUpdateArgs} args - Arguments to update one Bn_content_positions.
     * @example
     * // Update one Bn_content_positions
     * const bn_content_positions = await prisma.bn_content_positions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bn_content_positionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_content_positionsUpdateArgs<ExtArgs>>
    ): Prisma__bn_content_positionsClient<$Result.GetResult<Prisma.$bn_content_positionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bn_content_positions.
     * @param {bn_content_positionsDeleteManyArgs} args - Arguments to filter Bn_content_positions to delete.
     * @example
     * // Delete a few Bn_content_positions
     * const { count } = await prisma.bn_content_positions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bn_content_positionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_content_positionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bn_content_positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_content_positionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bn_content_positions
     * const bn_content_positions = await prisma.bn_content_positions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bn_content_positionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bn_content_positionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bn_content_positions.
     * @param {bn_content_positionsUpsertArgs} args - Arguments to update or create a Bn_content_positions.
     * @example
     * // Update or create a Bn_content_positions
     * const bn_content_positions = await prisma.bn_content_positions.upsert({
     *   create: {
     *     // ... data to create a Bn_content_positions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bn_content_positions we want to update
     *   }
     * })
    **/
    upsert<T extends bn_content_positionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bn_content_positionsUpsertArgs<ExtArgs>>
    ): Prisma__bn_content_positionsClient<$Result.GetResult<Prisma.$bn_content_positionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bn_content_positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_content_positionsCountArgs} args - Arguments to filter Bn_content_positions to count.
     * @example
     * // Count the number of Bn_content_positions
     * const count = await prisma.bn_content_positions.count({
     *   where: {
     *     // ... the filter for the Bn_content_positions we want to count
     *   }
     * })
    **/
    count<T extends bn_content_positionsCountArgs>(
      args?: Subset<T, bn_content_positionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bn_content_positionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bn_content_positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bn_content_positionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bn_content_positionsAggregateArgs>(args: Subset<T, Bn_content_positionsAggregateArgs>): Prisma.PrismaPromise<GetBn_content_positionsAggregateType<T>>

    /**
     * Group by Bn_content_positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_content_positionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bn_content_positionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bn_content_positionsGroupByArgs['orderBy'] }
        : { orderBy?: bn_content_positionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bn_content_positionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBn_content_positionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bn_content_positions model
   */
  readonly fields: bn_content_positionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bn_content_positions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bn_content_positionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bn_content_positions model
   */ 
  interface bn_content_positionsFieldRefs {
    readonly position_id: FieldRef<"bn_content_positions", 'Int'>
    readonly position_name: FieldRef<"bn_content_positions", 'String'>
    readonly position_slug: FieldRef<"bn_content_positions", 'String'>
    readonly cat_id: FieldRef<"bn_content_positions", 'Int'>
    readonly special_cat_id: FieldRef<"bn_content_positions", 'Int'>
    readonly subcat_id: FieldRef<"bn_content_positions", 'Int'>
    readonly content_ids: FieldRef<"bn_content_positions", 'String'>
    readonly total_content: FieldRef<"bn_content_positions", 'Int'>
    readonly status: FieldRef<"bn_content_positions", 'Int'>
    readonly deletable: FieldRef<"bn_content_positions", 'Int'>
    readonly created_at: FieldRef<"bn_content_positions", 'DateTime'>
    readonly updated_at: FieldRef<"bn_content_positions", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * bn_content_positions findUnique
   */
  export type bn_content_positionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_content_positions
     */
    select?: bn_content_positionsSelect<ExtArgs> | null
    /**
     * Filter, which bn_content_positions to fetch.
     */
    where: bn_content_positionsWhereUniqueInput
  }


  /**
   * bn_content_positions findUniqueOrThrow
   */
  export type bn_content_positionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_content_positions
     */
    select?: bn_content_positionsSelect<ExtArgs> | null
    /**
     * Filter, which bn_content_positions to fetch.
     */
    where: bn_content_positionsWhereUniqueInput
  }


  /**
   * bn_content_positions findFirst
   */
  export type bn_content_positionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_content_positions
     */
    select?: bn_content_positionsSelect<ExtArgs> | null
    /**
     * Filter, which bn_content_positions to fetch.
     */
    where?: bn_content_positionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_content_positions to fetch.
     */
    orderBy?: bn_content_positionsOrderByWithRelationInput | bn_content_positionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_content_positions.
     */
    cursor?: bn_content_positionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_content_positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_content_positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_content_positions.
     */
    distinct?: Bn_content_positionsScalarFieldEnum | Bn_content_positionsScalarFieldEnum[]
  }


  /**
   * bn_content_positions findFirstOrThrow
   */
  export type bn_content_positionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_content_positions
     */
    select?: bn_content_positionsSelect<ExtArgs> | null
    /**
     * Filter, which bn_content_positions to fetch.
     */
    where?: bn_content_positionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_content_positions to fetch.
     */
    orderBy?: bn_content_positionsOrderByWithRelationInput | bn_content_positionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_content_positions.
     */
    cursor?: bn_content_positionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_content_positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_content_positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_content_positions.
     */
    distinct?: Bn_content_positionsScalarFieldEnum | Bn_content_positionsScalarFieldEnum[]
  }


  /**
   * bn_content_positions findMany
   */
  export type bn_content_positionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_content_positions
     */
    select?: bn_content_positionsSelect<ExtArgs> | null
    /**
     * Filter, which bn_content_positions to fetch.
     */
    where?: bn_content_positionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_content_positions to fetch.
     */
    orderBy?: bn_content_positionsOrderByWithRelationInput | bn_content_positionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bn_content_positions.
     */
    cursor?: bn_content_positionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_content_positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_content_positions.
     */
    skip?: number
    distinct?: Bn_content_positionsScalarFieldEnum | Bn_content_positionsScalarFieldEnum[]
  }


  /**
   * bn_content_positions create
   */
  export type bn_content_positionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_content_positions
     */
    select?: bn_content_positionsSelect<ExtArgs> | null
    /**
     * The data needed to create a bn_content_positions.
     */
    data: XOR<bn_content_positionsCreateInput, bn_content_positionsUncheckedCreateInput>
  }


  /**
   * bn_content_positions createMany
   */
  export type bn_content_positionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bn_content_positions.
     */
    data: bn_content_positionsCreateManyInput | bn_content_positionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bn_content_positions update
   */
  export type bn_content_positionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_content_positions
     */
    select?: bn_content_positionsSelect<ExtArgs> | null
    /**
     * The data needed to update a bn_content_positions.
     */
    data: XOR<bn_content_positionsUpdateInput, bn_content_positionsUncheckedUpdateInput>
    /**
     * Choose, which bn_content_positions to update.
     */
    where: bn_content_positionsWhereUniqueInput
  }


  /**
   * bn_content_positions updateMany
   */
  export type bn_content_positionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bn_content_positions.
     */
    data: XOR<bn_content_positionsUpdateManyMutationInput, bn_content_positionsUncheckedUpdateManyInput>
    /**
     * Filter which bn_content_positions to update
     */
    where?: bn_content_positionsWhereInput
  }


  /**
   * bn_content_positions upsert
   */
  export type bn_content_positionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_content_positions
     */
    select?: bn_content_positionsSelect<ExtArgs> | null
    /**
     * The filter to search for the bn_content_positions to update in case it exists.
     */
    where: bn_content_positionsWhereUniqueInput
    /**
     * In case the bn_content_positions found by the `where` argument doesn't exist, create a new bn_content_positions with this data.
     */
    create: XOR<bn_content_positionsCreateInput, bn_content_positionsUncheckedCreateInput>
    /**
     * In case the bn_content_positions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bn_content_positionsUpdateInput, bn_content_positionsUncheckedUpdateInput>
  }


  /**
   * bn_content_positions delete
   */
  export type bn_content_positionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_content_positions
     */
    select?: bn_content_positionsSelect<ExtArgs> | null
    /**
     * Filter which bn_content_positions to delete.
     */
    where: bn_content_positionsWhereUniqueInput
  }


  /**
   * bn_content_positions deleteMany
   */
  export type bn_content_positionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_content_positions to delete
     */
    where?: bn_content_positionsWhereInput
  }


  /**
   * bn_content_positions without action
   */
  export type bn_content_positionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_content_positions
     */
    select?: bn_content_positionsSelect<ExtArgs> | null
  }



  /**
   * Model bn_contents
   */

  export type AggregateBn_contents = {
    _count: Bn_contentsCountAggregateOutputType | null
    _avg: Bn_contentsAvgAggregateOutputType | null
    _sum: Bn_contentsSumAggregateOutputType | null
    _min: Bn_contentsMinAggregateOutputType | null
    _max: Bn_contentsMaxAggregateOutputType | null
  }

  export type Bn_contentsAvgAggregateOutputType = {
    content_id: number | null
    content_type: number | null
    cat_id: number | null
    subcat_id: number | null
    special_cat_id: number | null
    country_id: number | null
    division_id: number | null
    district_id: number | null
    upozilla_id: number | null
    video_type: number | null
    uploader_id: number | null
    reporter_id: number | null
    status: number | null
    scroll: number | null
    total_hit: number | null
    deletable: number | null
  }

  export type Bn_contentsSumAggregateOutputType = {
    content_id: number | null
    content_type: number | null
    cat_id: number | null
    subcat_id: number | null
    special_cat_id: number | null
    country_id: number | null
    division_id: number | null
    district_id: number | null
    upozilla_id: number | null
    video_type: number | null
    uploader_id: number | null
    reporter_id: number | null
    status: number | null
    scroll: number | null
    total_hit: number | null
    deletable: number | null
  }

  export type Bn_contentsMinAggregateOutputType = {
    content_id: number | null
    content_type: number | null
    cat_id: number | null
    subcat_id: number | null
    special_cat_id: number | null
    country_id: number | null
    division_id: number | null
    district_id: number | null
    upozilla_id: number | null
    content_heading: string | null
    content_sub_heading: string | null
    author_slugs: string | null
    author_name: string | null
    content_brief: string | null
    content_details: string | null
    img_xs_path: string | null
    img_sm_path: string | null
    img_sm_caption: string | null
    img_bg_path: string | null
    og_image: string | null
    img_bg_caption: string | null
    related_ids: string | null
    photo_ids: string | null
    video_type: number | null
    video_id: string | null
    uploader_id: number | null
    reporter_id: number | null
    tags: string | null
    meta_keywords: string | null
    timeline_tag: string | null
    podcast_id: string | null
    status: number | null
    scroll: number | null
    total_hit: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_contentsMaxAggregateOutputType = {
    content_id: number | null
    content_type: number | null
    cat_id: number | null
    subcat_id: number | null
    special_cat_id: number | null
    country_id: number | null
    division_id: number | null
    district_id: number | null
    upozilla_id: number | null
    content_heading: string | null
    content_sub_heading: string | null
    author_slugs: string | null
    author_name: string | null
    content_brief: string | null
    content_details: string | null
    img_xs_path: string | null
    img_sm_path: string | null
    img_sm_caption: string | null
    img_bg_path: string | null
    og_image: string | null
    img_bg_caption: string | null
    related_ids: string | null
    photo_ids: string | null
    video_type: number | null
    video_id: string | null
    uploader_id: number | null
    reporter_id: number | null
    tags: string | null
    meta_keywords: string | null
    timeline_tag: string | null
    podcast_id: string | null
    status: number | null
    scroll: number | null
    total_hit: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_contentsCountAggregateOutputType = {
    content_id: number
    content_type: number
    cat_id: number
    subcat_id: number
    special_cat_id: number
    country_id: number
    division_id: number
    district_id: number
    upozilla_id: number
    content_heading: number
    content_sub_heading: number
    author_slugs: number
    author_name: number
    content_brief: number
    content_details: number
    img_xs_path: number
    img_sm_path: number
    img_sm_caption: number
    img_bg_path: number
    og_image: number
    img_bg_caption: number
    related_ids: number
    photo_ids: number
    video_type: number
    video_id: number
    uploader_id: number
    reporter_id: number
    tags: number
    meta_keywords: number
    timeline_tag: number
    podcast_id: number
    status: number
    scroll: number
    total_hit: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Bn_contentsAvgAggregateInputType = {
    content_id?: true
    content_type?: true
    cat_id?: true
    subcat_id?: true
    special_cat_id?: true
    country_id?: true
    division_id?: true
    district_id?: true
    upozilla_id?: true
    video_type?: true
    uploader_id?: true
    reporter_id?: true
    status?: true
    scroll?: true
    total_hit?: true
    deletable?: true
  }

  export type Bn_contentsSumAggregateInputType = {
    content_id?: true
    content_type?: true
    cat_id?: true
    subcat_id?: true
    special_cat_id?: true
    country_id?: true
    division_id?: true
    district_id?: true
    upozilla_id?: true
    video_type?: true
    uploader_id?: true
    reporter_id?: true
    status?: true
    scroll?: true
    total_hit?: true
    deletable?: true
  }

  export type Bn_contentsMinAggregateInputType = {
    content_id?: true
    content_type?: true
    cat_id?: true
    subcat_id?: true
    special_cat_id?: true
    country_id?: true
    division_id?: true
    district_id?: true
    upozilla_id?: true
    content_heading?: true
    content_sub_heading?: true
    author_slugs?: true
    author_name?: true
    content_brief?: true
    content_details?: true
    img_xs_path?: true
    img_sm_path?: true
    img_sm_caption?: true
    img_bg_path?: true
    og_image?: true
    img_bg_caption?: true
    related_ids?: true
    photo_ids?: true
    video_type?: true
    video_id?: true
    uploader_id?: true
    reporter_id?: true
    tags?: true
    meta_keywords?: true
    timeline_tag?: true
    podcast_id?: true
    status?: true
    scroll?: true
    total_hit?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_contentsMaxAggregateInputType = {
    content_id?: true
    content_type?: true
    cat_id?: true
    subcat_id?: true
    special_cat_id?: true
    country_id?: true
    division_id?: true
    district_id?: true
    upozilla_id?: true
    content_heading?: true
    content_sub_heading?: true
    author_slugs?: true
    author_name?: true
    content_brief?: true
    content_details?: true
    img_xs_path?: true
    img_sm_path?: true
    img_sm_caption?: true
    img_bg_path?: true
    og_image?: true
    img_bg_caption?: true
    related_ids?: true
    photo_ids?: true
    video_type?: true
    video_id?: true
    uploader_id?: true
    reporter_id?: true
    tags?: true
    meta_keywords?: true
    timeline_tag?: true
    podcast_id?: true
    status?: true
    scroll?: true
    total_hit?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_contentsCountAggregateInputType = {
    content_id?: true
    content_type?: true
    cat_id?: true
    subcat_id?: true
    special_cat_id?: true
    country_id?: true
    division_id?: true
    district_id?: true
    upozilla_id?: true
    content_heading?: true
    content_sub_heading?: true
    author_slugs?: true
    author_name?: true
    content_brief?: true
    content_details?: true
    img_xs_path?: true
    img_sm_path?: true
    img_sm_caption?: true
    img_bg_path?: true
    og_image?: true
    img_bg_caption?: true
    related_ids?: true
    photo_ids?: true
    video_type?: true
    video_id?: true
    uploader_id?: true
    reporter_id?: true
    tags?: true
    meta_keywords?: true
    timeline_tag?: true
    podcast_id?: true
    status?: true
    scroll?: true
    total_hit?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Bn_contentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_contents to aggregate.
     */
    where?: bn_contentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_contents to fetch.
     */
    orderBy?: bn_contentsOrderByWithRelationInput | bn_contentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bn_contentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bn_contents
    **/
    _count?: true | Bn_contentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bn_contentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bn_contentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bn_contentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bn_contentsMaxAggregateInputType
  }

  export type GetBn_contentsAggregateType<T extends Bn_contentsAggregateArgs> = {
        [P in keyof T & keyof AggregateBn_contents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBn_contents[P]>
      : GetScalarType<T[P], AggregateBn_contents[P]>
  }




  export type bn_contentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bn_contentsWhereInput
    orderBy?: bn_contentsOrderByWithAggregationInput | bn_contentsOrderByWithAggregationInput[]
    by: Bn_contentsScalarFieldEnum[] | Bn_contentsScalarFieldEnum
    having?: bn_contentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bn_contentsCountAggregateInputType | true
    _avg?: Bn_contentsAvgAggregateInputType
    _sum?: Bn_contentsSumAggregateInputType
    _min?: Bn_contentsMinAggregateInputType
    _max?: Bn_contentsMaxAggregateInputType
  }

  export type Bn_contentsGroupByOutputType = {
    content_id: number
    content_type: number
    cat_id: number
    subcat_id: number
    special_cat_id: number
    country_id: number
    division_id: number
    district_id: number
    upozilla_id: number
    content_heading: string
    content_sub_heading: string | null
    author_slugs: string | null
    author_name: string | null
    content_brief: string | null
    content_details: string
    img_xs_path: string | null
    img_sm_path: string | null
    img_sm_caption: string | null
    img_bg_path: string | null
    og_image: string | null
    img_bg_caption: string | null
    related_ids: string | null
    photo_ids: string | null
    video_type: number | null
    video_id: string | null
    uploader_id: number
    reporter_id: number | null
    tags: string | null
    meta_keywords: string | null
    timeline_tag: string | null
    podcast_id: string | null
    status: number
    scroll: number
    total_hit: number
    deletable: number
    created_at: Date | null
    updated_at: Date | null
    _count: Bn_contentsCountAggregateOutputType | null
    _avg: Bn_contentsAvgAggregateOutputType | null
    _sum: Bn_contentsSumAggregateOutputType | null
    _min: Bn_contentsMinAggregateOutputType | null
    _max: Bn_contentsMaxAggregateOutputType | null
  }

  type GetBn_contentsGroupByPayload<T extends bn_contentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bn_contentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bn_contentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bn_contentsGroupByOutputType[P]>
            : GetScalarType<T[P], Bn_contentsGroupByOutputType[P]>
        }
      >
    >


  export type bn_contentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    content_id?: boolean
    content_type?: boolean
    cat_id?: boolean
    subcat_id?: boolean
    special_cat_id?: boolean
    country_id?: boolean
    division_id?: boolean
    district_id?: boolean
    upozilla_id?: boolean
    content_heading?: boolean
    content_sub_heading?: boolean
    author_slugs?: boolean
    author_name?: boolean
    content_brief?: boolean
    content_details?: boolean
    img_xs_path?: boolean
    img_sm_path?: boolean
    img_sm_caption?: boolean
    img_bg_path?: boolean
    og_image?: boolean
    img_bg_caption?: boolean
    related_ids?: boolean
    photo_ids?: boolean
    video_type?: boolean
    video_id?: boolean
    uploader_id?: boolean
    reporter_id?: boolean
    tags?: boolean
    meta_keywords?: boolean
    timeline_tag?: boolean
    podcast_id?: boolean
    status?: boolean
    scroll?: boolean
    total_hit?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["bn_contents"]>

  export type bn_contentsSelectScalar = {
    content_id?: boolean
    content_type?: boolean
    cat_id?: boolean
    subcat_id?: boolean
    special_cat_id?: boolean
    country_id?: boolean
    division_id?: boolean
    district_id?: boolean
    upozilla_id?: boolean
    content_heading?: boolean
    content_sub_heading?: boolean
    author_slugs?: boolean
    author_name?: boolean
    content_brief?: boolean
    content_details?: boolean
    img_xs_path?: boolean
    img_sm_path?: boolean
    img_sm_caption?: boolean
    img_bg_path?: boolean
    og_image?: boolean
    img_bg_caption?: boolean
    related_ids?: boolean
    photo_ids?: boolean
    video_type?: boolean
    video_id?: boolean
    uploader_id?: boolean
    reporter_id?: boolean
    tags?: boolean
    meta_keywords?: boolean
    timeline_tag?: boolean
    podcast_id?: boolean
    status?: boolean
    scroll?: boolean
    total_hit?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $bn_contentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bn_contents"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      content_id: number
      content_type: number
      cat_id: number
      subcat_id: number
      special_cat_id: number
      country_id: number
      division_id: number
      district_id: number
      upozilla_id: number
      content_heading: string
      content_sub_heading: string | null
      author_slugs: string | null
      author_name: string | null
      content_brief: string | null
      content_details: string
      img_xs_path: string | null
      img_sm_path: string | null
      img_sm_caption: string | null
      img_bg_path: string | null
      og_image: string | null
      img_bg_caption: string | null
      related_ids: string | null
      photo_ids: string | null
      video_type: number | null
      video_id: string | null
      uploader_id: number
      reporter_id: number | null
      tags: string | null
      meta_keywords: string | null
      timeline_tag: string | null
      podcast_id: string | null
      status: number
      scroll: number
      total_hit: number
      deletable: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["bn_contents"]>
    composites: {}
  }


  type bn_contentsGetPayload<S extends boolean | null | undefined | bn_contentsDefaultArgs> = $Result.GetResult<Prisma.$bn_contentsPayload, S>

  type bn_contentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bn_contentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bn_contentsCountAggregateInputType | true
    }

  export interface bn_contentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bn_contents'], meta: { name: 'bn_contents' } }
    /**
     * Find zero or one Bn_contents that matches the filter.
     * @param {bn_contentsFindUniqueArgs} args - Arguments to find a Bn_contents
     * @example
     * // Get one Bn_contents
     * const bn_contents = await prisma.bn_contents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bn_contentsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bn_contentsFindUniqueArgs<ExtArgs>>
    ): Prisma__bn_contentsClient<$Result.GetResult<Prisma.$bn_contentsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bn_contents that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bn_contentsFindUniqueOrThrowArgs} args - Arguments to find a Bn_contents
     * @example
     * // Get one Bn_contents
     * const bn_contents = await prisma.bn_contents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bn_contentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_contentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bn_contentsClient<$Result.GetResult<Prisma.$bn_contentsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bn_contents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_contentsFindFirstArgs} args - Arguments to find a Bn_contents
     * @example
     * // Get one Bn_contents
     * const bn_contents = await prisma.bn_contents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bn_contentsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_contentsFindFirstArgs<ExtArgs>>
    ): Prisma__bn_contentsClient<$Result.GetResult<Prisma.$bn_contentsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bn_contents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_contentsFindFirstOrThrowArgs} args - Arguments to find a Bn_contents
     * @example
     * // Get one Bn_contents
     * const bn_contents = await prisma.bn_contents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bn_contentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_contentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bn_contentsClient<$Result.GetResult<Prisma.$bn_contentsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bn_contents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_contentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bn_contents
     * const bn_contents = await prisma.bn_contents.findMany()
     * 
     * // Get first 10 Bn_contents
     * const bn_contents = await prisma.bn_contents.findMany({ take: 10 })
     * 
     * // Only select the `content_id`
     * const bn_contentsWithContent_idOnly = await prisma.bn_contents.findMany({ select: { content_id: true } })
     * 
    **/
    findMany<T extends bn_contentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_contentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bn_contentsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bn_contents.
     * @param {bn_contentsCreateArgs} args - Arguments to create a Bn_contents.
     * @example
     * // Create one Bn_contents
     * const Bn_contents = await prisma.bn_contents.create({
     *   data: {
     *     // ... data to create a Bn_contents
     *   }
     * })
     * 
    **/
    create<T extends bn_contentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_contentsCreateArgs<ExtArgs>>
    ): Prisma__bn_contentsClient<$Result.GetResult<Prisma.$bn_contentsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bn_contents.
     *     @param {bn_contentsCreateManyArgs} args - Arguments to create many Bn_contents.
     *     @example
     *     // Create many Bn_contents
     *     const bn_contents = await prisma.bn_contents.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bn_contentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_contentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bn_contents.
     * @param {bn_contentsDeleteArgs} args - Arguments to delete one Bn_contents.
     * @example
     * // Delete one Bn_contents
     * const Bn_contents = await prisma.bn_contents.delete({
     *   where: {
     *     // ... filter to delete one Bn_contents
     *   }
     * })
     * 
    **/
    delete<T extends bn_contentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bn_contentsDeleteArgs<ExtArgs>>
    ): Prisma__bn_contentsClient<$Result.GetResult<Prisma.$bn_contentsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bn_contents.
     * @param {bn_contentsUpdateArgs} args - Arguments to update one Bn_contents.
     * @example
     * // Update one Bn_contents
     * const bn_contents = await prisma.bn_contents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bn_contentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_contentsUpdateArgs<ExtArgs>>
    ): Prisma__bn_contentsClient<$Result.GetResult<Prisma.$bn_contentsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bn_contents.
     * @param {bn_contentsDeleteManyArgs} args - Arguments to filter Bn_contents to delete.
     * @example
     * // Delete a few Bn_contents
     * const { count } = await prisma.bn_contents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bn_contentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_contentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bn_contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_contentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bn_contents
     * const bn_contents = await prisma.bn_contents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bn_contentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bn_contentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bn_contents.
     * @param {bn_contentsUpsertArgs} args - Arguments to update or create a Bn_contents.
     * @example
     * // Update or create a Bn_contents
     * const bn_contents = await prisma.bn_contents.upsert({
     *   create: {
     *     // ... data to create a Bn_contents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bn_contents we want to update
     *   }
     * })
    **/
    upsert<T extends bn_contentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bn_contentsUpsertArgs<ExtArgs>>
    ): Prisma__bn_contentsClient<$Result.GetResult<Prisma.$bn_contentsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bn_contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_contentsCountArgs} args - Arguments to filter Bn_contents to count.
     * @example
     * // Count the number of Bn_contents
     * const count = await prisma.bn_contents.count({
     *   where: {
     *     // ... the filter for the Bn_contents we want to count
     *   }
     * })
    **/
    count<T extends bn_contentsCountArgs>(
      args?: Subset<T, bn_contentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bn_contentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bn_contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bn_contentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bn_contentsAggregateArgs>(args: Subset<T, Bn_contentsAggregateArgs>): Prisma.PrismaPromise<GetBn_contentsAggregateType<T>>

    /**
     * Group by Bn_contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_contentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bn_contentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bn_contentsGroupByArgs['orderBy'] }
        : { orderBy?: bn_contentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bn_contentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBn_contentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bn_contents model
   */
  readonly fields: bn_contentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bn_contents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bn_contentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bn_contents model
   */ 
  interface bn_contentsFieldRefs {
    readonly content_id: FieldRef<"bn_contents", 'Int'>
    readonly content_type: FieldRef<"bn_contents", 'Int'>
    readonly cat_id: FieldRef<"bn_contents", 'Int'>
    readonly subcat_id: FieldRef<"bn_contents", 'Int'>
    readonly special_cat_id: FieldRef<"bn_contents", 'Int'>
    readonly country_id: FieldRef<"bn_contents", 'Int'>
    readonly division_id: FieldRef<"bn_contents", 'Int'>
    readonly district_id: FieldRef<"bn_contents", 'Int'>
    readonly upozilla_id: FieldRef<"bn_contents", 'Int'>
    readonly content_heading: FieldRef<"bn_contents", 'String'>
    readonly content_sub_heading: FieldRef<"bn_contents", 'String'>
    readonly author_slugs: FieldRef<"bn_contents", 'String'>
    readonly author_name: FieldRef<"bn_contents", 'String'>
    readonly content_brief: FieldRef<"bn_contents", 'String'>
    readonly content_details: FieldRef<"bn_contents", 'String'>
    readonly img_xs_path: FieldRef<"bn_contents", 'String'>
    readonly img_sm_path: FieldRef<"bn_contents", 'String'>
    readonly img_sm_caption: FieldRef<"bn_contents", 'String'>
    readonly img_bg_path: FieldRef<"bn_contents", 'String'>
    readonly og_image: FieldRef<"bn_contents", 'String'>
    readonly img_bg_caption: FieldRef<"bn_contents", 'String'>
    readonly related_ids: FieldRef<"bn_contents", 'String'>
    readonly photo_ids: FieldRef<"bn_contents", 'String'>
    readonly video_type: FieldRef<"bn_contents", 'Int'>
    readonly video_id: FieldRef<"bn_contents", 'String'>
    readonly uploader_id: FieldRef<"bn_contents", 'Int'>
    readonly reporter_id: FieldRef<"bn_contents", 'Int'>
    readonly tags: FieldRef<"bn_contents", 'String'>
    readonly meta_keywords: FieldRef<"bn_contents", 'String'>
    readonly timeline_tag: FieldRef<"bn_contents", 'String'>
    readonly podcast_id: FieldRef<"bn_contents", 'String'>
    readonly status: FieldRef<"bn_contents", 'Int'>
    readonly scroll: FieldRef<"bn_contents", 'Int'>
    readonly total_hit: FieldRef<"bn_contents", 'Int'>
    readonly deletable: FieldRef<"bn_contents", 'Int'>
    readonly created_at: FieldRef<"bn_contents", 'DateTime'>
    readonly updated_at: FieldRef<"bn_contents", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * bn_contents findUnique
   */
  export type bn_contentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_contents
     */
    select?: bn_contentsSelect<ExtArgs> | null
    /**
     * Filter, which bn_contents to fetch.
     */
    where: bn_contentsWhereUniqueInput
  }


  /**
   * bn_contents findUniqueOrThrow
   */
  export type bn_contentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_contents
     */
    select?: bn_contentsSelect<ExtArgs> | null
    /**
     * Filter, which bn_contents to fetch.
     */
    where: bn_contentsWhereUniqueInput
  }


  /**
   * bn_contents findFirst
   */
  export type bn_contentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_contents
     */
    select?: bn_contentsSelect<ExtArgs> | null
    /**
     * Filter, which bn_contents to fetch.
     */
    where?: bn_contentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_contents to fetch.
     */
    orderBy?: bn_contentsOrderByWithRelationInput | bn_contentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_contents.
     */
    cursor?: bn_contentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_contents.
     */
    distinct?: Bn_contentsScalarFieldEnum | Bn_contentsScalarFieldEnum[]
  }


  /**
   * bn_contents findFirstOrThrow
   */
  export type bn_contentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_contents
     */
    select?: bn_contentsSelect<ExtArgs> | null
    /**
     * Filter, which bn_contents to fetch.
     */
    where?: bn_contentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_contents to fetch.
     */
    orderBy?: bn_contentsOrderByWithRelationInput | bn_contentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_contents.
     */
    cursor?: bn_contentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_contents.
     */
    distinct?: Bn_contentsScalarFieldEnum | Bn_contentsScalarFieldEnum[]
  }


  /**
   * bn_contents findMany
   */
  export type bn_contentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_contents
     */
    select?: bn_contentsSelect<ExtArgs> | null
    /**
     * Filter, which bn_contents to fetch.
     */
    where?: bn_contentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_contents to fetch.
     */
    orderBy?: bn_contentsOrderByWithRelationInput | bn_contentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bn_contents.
     */
    cursor?: bn_contentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_contents.
     */
    skip?: number
    distinct?: Bn_contentsScalarFieldEnum | Bn_contentsScalarFieldEnum[]
  }


  /**
   * bn_contents create
   */
  export type bn_contentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_contents
     */
    select?: bn_contentsSelect<ExtArgs> | null
    /**
     * The data needed to create a bn_contents.
     */
    data: XOR<bn_contentsCreateInput, bn_contentsUncheckedCreateInput>
  }


  /**
   * bn_contents createMany
   */
  export type bn_contentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bn_contents.
     */
    data: bn_contentsCreateManyInput | bn_contentsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bn_contents update
   */
  export type bn_contentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_contents
     */
    select?: bn_contentsSelect<ExtArgs> | null
    /**
     * The data needed to update a bn_contents.
     */
    data: XOR<bn_contentsUpdateInput, bn_contentsUncheckedUpdateInput>
    /**
     * Choose, which bn_contents to update.
     */
    where: bn_contentsWhereUniqueInput
  }


  /**
   * bn_contents updateMany
   */
  export type bn_contentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bn_contents.
     */
    data: XOR<bn_contentsUpdateManyMutationInput, bn_contentsUncheckedUpdateManyInput>
    /**
     * Filter which bn_contents to update
     */
    where?: bn_contentsWhereInput
  }


  /**
   * bn_contents upsert
   */
  export type bn_contentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_contents
     */
    select?: bn_contentsSelect<ExtArgs> | null
    /**
     * The filter to search for the bn_contents to update in case it exists.
     */
    where: bn_contentsWhereUniqueInput
    /**
     * In case the bn_contents found by the `where` argument doesn't exist, create a new bn_contents with this data.
     */
    create: XOR<bn_contentsCreateInput, bn_contentsUncheckedCreateInput>
    /**
     * In case the bn_contents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bn_contentsUpdateInput, bn_contentsUncheckedUpdateInput>
  }


  /**
   * bn_contents delete
   */
  export type bn_contentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_contents
     */
    select?: bn_contentsSelect<ExtArgs> | null
    /**
     * Filter which bn_contents to delete.
     */
    where: bn_contentsWhereUniqueInput
  }


  /**
   * bn_contents deleteMany
   */
  export type bn_contentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_contents to delete
     */
    where?: bn_contentsWhereInput
  }


  /**
   * bn_contents without action
   */
  export type bn_contentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_contents
     */
    select?: bn_contentsSelect<ExtArgs> | null
  }



  /**
   * Model bn_mobile_ads
   */

  export type AggregateBn_mobile_ads = {
    _count: Bn_mobile_adsCountAggregateOutputType | null
    _avg: Bn_mobile_adsAvgAggregateOutputType | null
    _sum: Bn_mobile_adsSumAggregateOutputType | null
    _min: Bn_mobile_adsMinAggregateOutputType | null
    _max: Bn_mobile_adsMaxAggregateOutputType | null
  }

  export type Bn_mobile_adsAvgAggregateOutputType = {
    id: number | null
    type: number | null
    page: number | null
    position: number | null
    status: number | null
    deletable: number | null
  }

  export type Bn_mobile_adsSumAggregateOutputType = {
    id: number | null
    type: number | null
    page: number | null
    position: number | null
    status: number | null
    deletable: number | null
  }

  export type Bn_mobile_adsMinAggregateOutputType = {
    id: number | null
    type: number | null
    page: number | null
    position: number | null
    dfp_header_code: string | null
    code: string | null
    mobile_image_path: string | null
    external_link: string | null
    start_time: Date | null
    end_time: Date | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_mobile_adsMaxAggregateOutputType = {
    id: number | null
    type: number | null
    page: number | null
    position: number | null
    dfp_header_code: string | null
    code: string | null
    mobile_image_path: string | null
    external_link: string | null
    start_time: Date | null
    end_time: Date | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_mobile_adsCountAggregateOutputType = {
    id: number
    type: number
    page: number
    position: number
    dfp_header_code: number
    code: number
    mobile_image_path: number
    external_link: number
    start_time: number
    end_time: number
    status: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Bn_mobile_adsAvgAggregateInputType = {
    id?: true
    type?: true
    page?: true
    position?: true
    status?: true
    deletable?: true
  }

  export type Bn_mobile_adsSumAggregateInputType = {
    id?: true
    type?: true
    page?: true
    position?: true
    status?: true
    deletable?: true
  }

  export type Bn_mobile_adsMinAggregateInputType = {
    id?: true
    type?: true
    page?: true
    position?: true
    dfp_header_code?: true
    code?: true
    mobile_image_path?: true
    external_link?: true
    start_time?: true
    end_time?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_mobile_adsMaxAggregateInputType = {
    id?: true
    type?: true
    page?: true
    position?: true
    dfp_header_code?: true
    code?: true
    mobile_image_path?: true
    external_link?: true
    start_time?: true
    end_time?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_mobile_adsCountAggregateInputType = {
    id?: true
    type?: true
    page?: true
    position?: true
    dfp_header_code?: true
    code?: true
    mobile_image_path?: true
    external_link?: true
    start_time?: true
    end_time?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Bn_mobile_adsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_mobile_ads to aggregate.
     */
    where?: bn_mobile_adsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_mobile_ads to fetch.
     */
    orderBy?: bn_mobile_adsOrderByWithRelationInput | bn_mobile_adsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bn_mobile_adsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_mobile_ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_mobile_ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bn_mobile_ads
    **/
    _count?: true | Bn_mobile_adsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bn_mobile_adsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bn_mobile_adsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bn_mobile_adsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bn_mobile_adsMaxAggregateInputType
  }

  export type GetBn_mobile_adsAggregateType<T extends Bn_mobile_adsAggregateArgs> = {
        [P in keyof T & keyof AggregateBn_mobile_ads]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBn_mobile_ads[P]>
      : GetScalarType<T[P], AggregateBn_mobile_ads[P]>
  }




  export type bn_mobile_adsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bn_mobile_adsWhereInput
    orderBy?: bn_mobile_adsOrderByWithAggregationInput | bn_mobile_adsOrderByWithAggregationInput[]
    by: Bn_mobile_adsScalarFieldEnum[] | Bn_mobile_adsScalarFieldEnum
    having?: bn_mobile_adsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bn_mobile_adsCountAggregateInputType | true
    _avg?: Bn_mobile_adsAvgAggregateInputType
    _sum?: Bn_mobile_adsSumAggregateInputType
    _min?: Bn_mobile_adsMinAggregateInputType
    _max?: Bn_mobile_adsMaxAggregateInputType
  }

  export type Bn_mobile_adsGroupByOutputType = {
    id: number
    type: number | null
    page: number | null
    position: number | null
    dfp_header_code: string | null
    code: string | null
    mobile_image_path: string | null
    external_link: string | null
    start_time: Date | null
    end_time: Date | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
    _count: Bn_mobile_adsCountAggregateOutputType | null
    _avg: Bn_mobile_adsAvgAggregateOutputType | null
    _sum: Bn_mobile_adsSumAggregateOutputType | null
    _min: Bn_mobile_adsMinAggregateOutputType | null
    _max: Bn_mobile_adsMaxAggregateOutputType | null
  }

  type GetBn_mobile_adsGroupByPayload<T extends bn_mobile_adsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bn_mobile_adsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bn_mobile_adsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bn_mobile_adsGroupByOutputType[P]>
            : GetScalarType<T[P], Bn_mobile_adsGroupByOutputType[P]>
        }
      >
    >


  export type bn_mobile_adsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    page?: boolean
    position?: boolean
    dfp_header_code?: boolean
    code?: boolean
    mobile_image_path?: boolean
    external_link?: boolean
    start_time?: boolean
    end_time?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["bn_mobile_ads"]>

  export type bn_mobile_adsSelectScalar = {
    id?: boolean
    type?: boolean
    page?: boolean
    position?: boolean
    dfp_header_code?: boolean
    code?: boolean
    mobile_image_path?: boolean
    external_link?: boolean
    start_time?: boolean
    end_time?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $bn_mobile_adsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bn_mobile_ads"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: number | null
      page: number | null
      position: number | null
      dfp_header_code: string | null
      code: string | null
      mobile_image_path: string | null
      external_link: string | null
      start_time: Date | null
      end_time: Date | null
      status: number | null
      deletable: number | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["bn_mobile_ads"]>
    composites: {}
  }


  type bn_mobile_adsGetPayload<S extends boolean | null | undefined | bn_mobile_adsDefaultArgs> = $Result.GetResult<Prisma.$bn_mobile_adsPayload, S>

  type bn_mobile_adsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bn_mobile_adsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bn_mobile_adsCountAggregateInputType | true
    }

  export interface bn_mobile_adsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bn_mobile_ads'], meta: { name: 'bn_mobile_ads' } }
    /**
     * Find zero or one Bn_mobile_ads that matches the filter.
     * @param {bn_mobile_adsFindUniqueArgs} args - Arguments to find a Bn_mobile_ads
     * @example
     * // Get one Bn_mobile_ads
     * const bn_mobile_ads = await prisma.bn_mobile_ads.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bn_mobile_adsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bn_mobile_adsFindUniqueArgs<ExtArgs>>
    ): Prisma__bn_mobile_adsClient<$Result.GetResult<Prisma.$bn_mobile_adsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bn_mobile_ads that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bn_mobile_adsFindUniqueOrThrowArgs} args - Arguments to find a Bn_mobile_ads
     * @example
     * // Get one Bn_mobile_ads
     * const bn_mobile_ads = await prisma.bn_mobile_ads.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bn_mobile_adsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_mobile_adsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bn_mobile_adsClient<$Result.GetResult<Prisma.$bn_mobile_adsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bn_mobile_ads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_mobile_adsFindFirstArgs} args - Arguments to find a Bn_mobile_ads
     * @example
     * // Get one Bn_mobile_ads
     * const bn_mobile_ads = await prisma.bn_mobile_ads.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bn_mobile_adsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_mobile_adsFindFirstArgs<ExtArgs>>
    ): Prisma__bn_mobile_adsClient<$Result.GetResult<Prisma.$bn_mobile_adsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bn_mobile_ads that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_mobile_adsFindFirstOrThrowArgs} args - Arguments to find a Bn_mobile_ads
     * @example
     * // Get one Bn_mobile_ads
     * const bn_mobile_ads = await prisma.bn_mobile_ads.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bn_mobile_adsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_mobile_adsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bn_mobile_adsClient<$Result.GetResult<Prisma.$bn_mobile_adsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bn_mobile_ads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_mobile_adsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bn_mobile_ads
     * const bn_mobile_ads = await prisma.bn_mobile_ads.findMany()
     * 
     * // Get first 10 Bn_mobile_ads
     * const bn_mobile_ads = await prisma.bn_mobile_ads.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bn_mobile_adsWithIdOnly = await prisma.bn_mobile_ads.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends bn_mobile_adsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_mobile_adsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bn_mobile_adsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bn_mobile_ads.
     * @param {bn_mobile_adsCreateArgs} args - Arguments to create a Bn_mobile_ads.
     * @example
     * // Create one Bn_mobile_ads
     * const Bn_mobile_ads = await prisma.bn_mobile_ads.create({
     *   data: {
     *     // ... data to create a Bn_mobile_ads
     *   }
     * })
     * 
    **/
    create<T extends bn_mobile_adsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_mobile_adsCreateArgs<ExtArgs>>
    ): Prisma__bn_mobile_adsClient<$Result.GetResult<Prisma.$bn_mobile_adsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bn_mobile_ads.
     *     @param {bn_mobile_adsCreateManyArgs} args - Arguments to create many Bn_mobile_ads.
     *     @example
     *     // Create many Bn_mobile_ads
     *     const bn_mobile_ads = await prisma.bn_mobile_ads.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bn_mobile_adsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_mobile_adsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bn_mobile_ads.
     * @param {bn_mobile_adsDeleteArgs} args - Arguments to delete one Bn_mobile_ads.
     * @example
     * // Delete one Bn_mobile_ads
     * const Bn_mobile_ads = await prisma.bn_mobile_ads.delete({
     *   where: {
     *     // ... filter to delete one Bn_mobile_ads
     *   }
     * })
     * 
    **/
    delete<T extends bn_mobile_adsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bn_mobile_adsDeleteArgs<ExtArgs>>
    ): Prisma__bn_mobile_adsClient<$Result.GetResult<Prisma.$bn_mobile_adsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bn_mobile_ads.
     * @param {bn_mobile_adsUpdateArgs} args - Arguments to update one Bn_mobile_ads.
     * @example
     * // Update one Bn_mobile_ads
     * const bn_mobile_ads = await prisma.bn_mobile_ads.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bn_mobile_adsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_mobile_adsUpdateArgs<ExtArgs>>
    ): Prisma__bn_mobile_adsClient<$Result.GetResult<Prisma.$bn_mobile_adsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bn_mobile_ads.
     * @param {bn_mobile_adsDeleteManyArgs} args - Arguments to filter Bn_mobile_ads to delete.
     * @example
     * // Delete a few Bn_mobile_ads
     * const { count } = await prisma.bn_mobile_ads.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bn_mobile_adsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_mobile_adsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bn_mobile_ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_mobile_adsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bn_mobile_ads
     * const bn_mobile_ads = await prisma.bn_mobile_ads.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bn_mobile_adsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bn_mobile_adsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bn_mobile_ads.
     * @param {bn_mobile_adsUpsertArgs} args - Arguments to update or create a Bn_mobile_ads.
     * @example
     * // Update or create a Bn_mobile_ads
     * const bn_mobile_ads = await prisma.bn_mobile_ads.upsert({
     *   create: {
     *     // ... data to create a Bn_mobile_ads
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bn_mobile_ads we want to update
     *   }
     * })
    **/
    upsert<T extends bn_mobile_adsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bn_mobile_adsUpsertArgs<ExtArgs>>
    ): Prisma__bn_mobile_adsClient<$Result.GetResult<Prisma.$bn_mobile_adsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bn_mobile_ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_mobile_adsCountArgs} args - Arguments to filter Bn_mobile_ads to count.
     * @example
     * // Count the number of Bn_mobile_ads
     * const count = await prisma.bn_mobile_ads.count({
     *   where: {
     *     // ... the filter for the Bn_mobile_ads we want to count
     *   }
     * })
    **/
    count<T extends bn_mobile_adsCountArgs>(
      args?: Subset<T, bn_mobile_adsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bn_mobile_adsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bn_mobile_ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bn_mobile_adsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bn_mobile_adsAggregateArgs>(args: Subset<T, Bn_mobile_adsAggregateArgs>): Prisma.PrismaPromise<GetBn_mobile_adsAggregateType<T>>

    /**
     * Group by Bn_mobile_ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_mobile_adsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bn_mobile_adsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bn_mobile_adsGroupByArgs['orderBy'] }
        : { orderBy?: bn_mobile_adsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bn_mobile_adsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBn_mobile_adsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bn_mobile_ads model
   */
  readonly fields: bn_mobile_adsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bn_mobile_ads.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bn_mobile_adsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bn_mobile_ads model
   */ 
  interface bn_mobile_adsFieldRefs {
    readonly id: FieldRef<"bn_mobile_ads", 'Int'>
    readonly type: FieldRef<"bn_mobile_ads", 'Int'>
    readonly page: FieldRef<"bn_mobile_ads", 'Int'>
    readonly position: FieldRef<"bn_mobile_ads", 'Int'>
    readonly dfp_header_code: FieldRef<"bn_mobile_ads", 'String'>
    readonly code: FieldRef<"bn_mobile_ads", 'String'>
    readonly mobile_image_path: FieldRef<"bn_mobile_ads", 'String'>
    readonly external_link: FieldRef<"bn_mobile_ads", 'String'>
    readonly start_time: FieldRef<"bn_mobile_ads", 'DateTime'>
    readonly end_time: FieldRef<"bn_mobile_ads", 'DateTime'>
    readonly status: FieldRef<"bn_mobile_ads", 'Int'>
    readonly deletable: FieldRef<"bn_mobile_ads", 'Int'>
    readonly created_at: FieldRef<"bn_mobile_ads", 'DateTime'>
    readonly updated_at: FieldRef<"bn_mobile_ads", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * bn_mobile_ads findUnique
   */
  export type bn_mobile_adsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_mobile_ads
     */
    select?: bn_mobile_adsSelect<ExtArgs> | null
    /**
     * Filter, which bn_mobile_ads to fetch.
     */
    where: bn_mobile_adsWhereUniqueInput
  }


  /**
   * bn_mobile_ads findUniqueOrThrow
   */
  export type bn_mobile_adsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_mobile_ads
     */
    select?: bn_mobile_adsSelect<ExtArgs> | null
    /**
     * Filter, which bn_mobile_ads to fetch.
     */
    where: bn_mobile_adsWhereUniqueInput
  }


  /**
   * bn_mobile_ads findFirst
   */
  export type bn_mobile_adsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_mobile_ads
     */
    select?: bn_mobile_adsSelect<ExtArgs> | null
    /**
     * Filter, which bn_mobile_ads to fetch.
     */
    where?: bn_mobile_adsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_mobile_ads to fetch.
     */
    orderBy?: bn_mobile_adsOrderByWithRelationInput | bn_mobile_adsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_mobile_ads.
     */
    cursor?: bn_mobile_adsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_mobile_ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_mobile_ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_mobile_ads.
     */
    distinct?: Bn_mobile_adsScalarFieldEnum | Bn_mobile_adsScalarFieldEnum[]
  }


  /**
   * bn_mobile_ads findFirstOrThrow
   */
  export type bn_mobile_adsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_mobile_ads
     */
    select?: bn_mobile_adsSelect<ExtArgs> | null
    /**
     * Filter, which bn_mobile_ads to fetch.
     */
    where?: bn_mobile_adsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_mobile_ads to fetch.
     */
    orderBy?: bn_mobile_adsOrderByWithRelationInput | bn_mobile_adsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_mobile_ads.
     */
    cursor?: bn_mobile_adsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_mobile_ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_mobile_ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_mobile_ads.
     */
    distinct?: Bn_mobile_adsScalarFieldEnum | Bn_mobile_adsScalarFieldEnum[]
  }


  /**
   * bn_mobile_ads findMany
   */
  export type bn_mobile_adsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_mobile_ads
     */
    select?: bn_mobile_adsSelect<ExtArgs> | null
    /**
     * Filter, which bn_mobile_ads to fetch.
     */
    where?: bn_mobile_adsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_mobile_ads to fetch.
     */
    orderBy?: bn_mobile_adsOrderByWithRelationInput | bn_mobile_adsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bn_mobile_ads.
     */
    cursor?: bn_mobile_adsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_mobile_ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_mobile_ads.
     */
    skip?: number
    distinct?: Bn_mobile_adsScalarFieldEnum | Bn_mobile_adsScalarFieldEnum[]
  }


  /**
   * bn_mobile_ads create
   */
  export type bn_mobile_adsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_mobile_ads
     */
    select?: bn_mobile_adsSelect<ExtArgs> | null
    /**
     * The data needed to create a bn_mobile_ads.
     */
    data?: XOR<bn_mobile_adsCreateInput, bn_mobile_adsUncheckedCreateInput>
  }


  /**
   * bn_mobile_ads createMany
   */
  export type bn_mobile_adsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bn_mobile_ads.
     */
    data: bn_mobile_adsCreateManyInput | bn_mobile_adsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bn_mobile_ads update
   */
  export type bn_mobile_adsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_mobile_ads
     */
    select?: bn_mobile_adsSelect<ExtArgs> | null
    /**
     * The data needed to update a bn_mobile_ads.
     */
    data: XOR<bn_mobile_adsUpdateInput, bn_mobile_adsUncheckedUpdateInput>
    /**
     * Choose, which bn_mobile_ads to update.
     */
    where: bn_mobile_adsWhereUniqueInput
  }


  /**
   * bn_mobile_ads updateMany
   */
  export type bn_mobile_adsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bn_mobile_ads.
     */
    data: XOR<bn_mobile_adsUpdateManyMutationInput, bn_mobile_adsUncheckedUpdateManyInput>
    /**
     * Filter which bn_mobile_ads to update
     */
    where?: bn_mobile_adsWhereInput
  }


  /**
   * bn_mobile_ads upsert
   */
  export type bn_mobile_adsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_mobile_ads
     */
    select?: bn_mobile_adsSelect<ExtArgs> | null
    /**
     * The filter to search for the bn_mobile_ads to update in case it exists.
     */
    where: bn_mobile_adsWhereUniqueInput
    /**
     * In case the bn_mobile_ads found by the `where` argument doesn't exist, create a new bn_mobile_ads with this data.
     */
    create: XOR<bn_mobile_adsCreateInput, bn_mobile_adsUncheckedCreateInput>
    /**
     * In case the bn_mobile_ads was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bn_mobile_adsUpdateInput, bn_mobile_adsUncheckedUpdateInput>
  }


  /**
   * bn_mobile_ads delete
   */
  export type bn_mobile_adsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_mobile_ads
     */
    select?: bn_mobile_adsSelect<ExtArgs> | null
    /**
     * Filter which bn_mobile_ads to delete.
     */
    where: bn_mobile_adsWhereUniqueInput
  }


  /**
   * bn_mobile_ads deleteMany
   */
  export type bn_mobile_adsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_mobile_ads to delete
     */
    where?: bn_mobile_adsWhereInput
  }


  /**
   * bn_mobile_ads without action
   */
  export type bn_mobile_adsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_mobile_ads
     */
    select?: bn_mobile_adsSelect<ExtArgs> | null
  }



  /**
   * Model bn_position_fixed
   */

  export type AggregateBn_position_fixed = {
    _count: Bn_position_fixedCountAggregateOutputType | null
    _avg: Bn_position_fixedAvgAggregateOutputType | null
    _sum: Bn_position_fixedSumAggregateOutputType | null
    _min: Bn_position_fixedMinAggregateOutputType | null
    _max: Bn_position_fixedMaxAggregateOutputType | null
  }

  export type Bn_position_fixedAvgAggregateOutputType = {
    id: number | null
    position_number: number | null
    news_id: number | null
    is_fixed: number | null
  }

  export type Bn_position_fixedSumAggregateOutputType = {
    id: number | null
    position_number: number | null
    news_id: number | null
    is_fixed: number | null
  }

  export type Bn_position_fixedMinAggregateOutputType = {
    id: number | null
    position_number: number | null
    news_id: number | null
    is_fixed: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_position_fixedMaxAggregateOutputType = {
    id: number | null
    position_number: number | null
    news_id: number | null
    is_fixed: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_position_fixedCountAggregateOutputType = {
    id: number
    position_number: number
    news_id: number
    is_fixed: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Bn_position_fixedAvgAggregateInputType = {
    id?: true
    position_number?: true
    news_id?: true
    is_fixed?: true
  }

  export type Bn_position_fixedSumAggregateInputType = {
    id?: true
    position_number?: true
    news_id?: true
    is_fixed?: true
  }

  export type Bn_position_fixedMinAggregateInputType = {
    id?: true
    position_number?: true
    news_id?: true
    is_fixed?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_position_fixedMaxAggregateInputType = {
    id?: true
    position_number?: true
    news_id?: true
    is_fixed?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_position_fixedCountAggregateInputType = {
    id?: true
    position_number?: true
    news_id?: true
    is_fixed?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Bn_position_fixedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_position_fixed to aggregate.
     */
    where?: bn_position_fixedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_position_fixeds to fetch.
     */
    orderBy?: bn_position_fixedOrderByWithRelationInput | bn_position_fixedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bn_position_fixedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_position_fixeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_position_fixeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bn_position_fixeds
    **/
    _count?: true | Bn_position_fixedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bn_position_fixedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bn_position_fixedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bn_position_fixedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bn_position_fixedMaxAggregateInputType
  }

  export type GetBn_position_fixedAggregateType<T extends Bn_position_fixedAggregateArgs> = {
        [P in keyof T & keyof AggregateBn_position_fixed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBn_position_fixed[P]>
      : GetScalarType<T[P], AggregateBn_position_fixed[P]>
  }




  export type bn_position_fixedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bn_position_fixedWhereInput
    orderBy?: bn_position_fixedOrderByWithAggregationInput | bn_position_fixedOrderByWithAggregationInput[]
    by: Bn_position_fixedScalarFieldEnum[] | Bn_position_fixedScalarFieldEnum
    having?: bn_position_fixedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bn_position_fixedCountAggregateInputType | true
    _avg?: Bn_position_fixedAvgAggregateInputType
    _sum?: Bn_position_fixedSumAggregateInputType
    _min?: Bn_position_fixedMinAggregateInputType
    _max?: Bn_position_fixedMaxAggregateInputType
  }

  export type Bn_position_fixedGroupByOutputType = {
    id: number
    position_number: number | null
    news_id: number | null
    is_fixed: number | null
    created_at: Date | null
    updated_at: Date | null
    _count: Bn_position_fixedCountAggregateOutputType | null
    _avg: Bn_position_fixedAvgAggregateOutputType | null
    _sum: Bn_position_fixedSumAggregateOutputType | null
    _min: Bn_position_fixedMinAggregateOutputType | null
    _max: Bn_position_fixedMaxAggregateOutputType | null
  }

  type GetBn_position_fixedGroupByPayload<T extends bn_position_fixedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bn_position_fixedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bn_position_fixedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bn_position_fixedGroupByOutputType[P]>
            : GetScalarType<T[P], Bn_position_fixedGroupByOutputType[P]>
        }
      >
    >


  export type bn_position_fixedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    position_number?: boolean
    news_id?: boolean
    is_fixed?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["bn_position_fixed"]>

  export type bn_position_fixedSelectScalar = {
    id?: boolean
    position_number?: boolean
    news_id?: boolean
    is_fixed?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $bn_position_fixedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bn_position_fixed"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      position_number: number | null
      news_id: number | null
      is_fixed: number | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["bn_position_fixed"]>
    composites: {}
  }


  type bn_position_fixedGetPayload<S extends boolean | null | undefined | bn_position_fixedDefaultArgs> = $Result.GetResult<Prisma.$bn_position_fixedPayload, S>

  type bn_position_fixedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bn_position_fixedFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bn_position_fixedCountAggregateInputType | true
    }

  export interface bn_position_fixedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bn_position_fixed'], meta: { name: 'bn_position_fixed' } }
    /**
     * Find zero or one Bn_position_fixed that matches the filter.
     * @param {bn_position_fixedFindUniqueArgs} args - Arguments to find a Bn_position_fixed
     * @example
     * // Get one Bn_position_fixed
     * const bn_position_fixed = await prisma.bn_position_fixed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bn_position_fixedFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bn_position_fixedFindUniqueArgs<ExtArgs>>
    ): Prisma__bn_position_fixedClient<$Result.GetResult<Prisma.$bn_position_fixedPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bn_position_fixed that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bn_position_fixedFindUniqueOrThrowArgs} args - Arguments to find a Bn_position_fixed
     * @example
     * // Get one Bn_position_fixed
     * const bn_position_fixed = await prisma.bn_position_fixed.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bn_position_fixedFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_position_fixedFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bn_position_fixedClient<$Result.GetResult<Prisma.$bn_position_fixedPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bn_position_fixed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_position_fixedFindFirstArgs} args - Arguments to find a Bn_position_fixed
     * @example
     * // Get one Bn_position_fixed
     * const bn_position_fixed = await prisma.bn_position_fixed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bn_position_fixedFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_position_fixedFindFirstArgs<ExtArgs>>
    ): Prisma__bn_position_fixedClient<$Result.GetResult<Prisma.$bn_position_fixedPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bn_position_fixed that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_position_fixedFindFirstOrThrowArgs} args - Arguments to find a Bn_position_fixed
     * @example
     * // Get one Bn_position_fixed
     * const bn_position_fixed = await prisma.bn_position_fixed.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bn_position_fixedFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_position_fixedFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bn_position_fixedClient<$Result.GetResult<Prisma.$bn_position_fixedPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bn_position_fixeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_position_fixedFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bn_position_fixeds
     * const bn_position_fixeds = await prisma.bn_position_fixed.findMany()
     * 
     * // Get first 10 Bn_position_fixeds
     * const bn_position_fixeds = await prisma.bn_position_fixed.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bn_position_fixedWithIdOnly = await prisma.bn_position_fixed.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends bn_position_fixedFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_position_fixedFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bn_position_fixedPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bn_position_fixed.
     * @param {bn_position_fixedCreateArgs} args - Arguments to create a Bn_position_fixed.
     * @example
     * // Create one Bn_position_fixed
     * const Bn_position_fixed = await prisma.bn_position_fixed.create({
     *   data: {
     *     // ... data to create a Bn_position_fixed
     *   }
     * })
     * 
    **/
    create<T extends bn_position_fixedCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_position_fixedCreateArgs<ExtArgs>>
    ): Prisma__bn_position_fixedClient<$Result.GetResult<Prisma.$bn_position_fixedPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bn_position_fixeds.
     *     @param {bn_position_fixedCreateManyArgs} args - Arguments to create many Bn_position_fixeds.
     *     @example
     *     // Create many Bn_position_fixeds
     *     const bn_position_fixed = await prisma.bn_position_fixed.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bn_position_fixedCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_position_fixedCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bn_position_fixed.
     * @param {bn_position_fixedDeleteArgs} args - Arguments to delete one Bn_position_fixed.
     * @example
     * // Delete one Bn_position_fixed
     * const Bn_position_fixed = await prisma.bn_position_fixed.delete({
     *   where: {
     *     // ... filter to delete one Bn_position_fixed
     *   }
     * })
     * 
    **/
    delete<T extends bn_position_fixedDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bn_position_fixedDeleteArgs<ExtArgs>>
    ): Prisma__bn_position_fixedClient<$Result.GetResult<Prisma.$bn_position_fixedPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bn_position_fixed.
     * @param {bn_position_fixedUpdateArgs} args - Arguments to update one Bn_position_fixed.
     * @example
     * // Update one Bn_position_fixed
     * const bn_position_fixed = await prisma.bn_position_fixed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bn_position_fixedUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_position_fixedUpdateArgs<ExtArgs>>
    ): Prisma__bn_position_fixedClient<$Result.GetResult<Prisma.$bn_position_fixedPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bn_position_fixeds.
     * @param {bn_position_fixedDeleteManyArgs} args - Arguments to filter Bn_position_fixeds to delete.
     * @example
     * // Delete a few Bn_position_fixeds
     * const { count } = await prisma.bn_position_fixed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bn_position_fixedDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_position_fixedDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bn_position_fixeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_position_fixedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bn_position_fixeds
     * const bn_position_fixed = await prisma.bn_position_fixed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bn_position_fixedUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bn_position_fixedUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bn_position_fixed.
     * @param {bn_position_fixedUpsertArgs} args - Arguments to update or create a Bn_position_fixed.
     * @example
     * // Update or create a Bn_position_fixed
     * const bn_position_fixed = await prisma.bn_position_fixed.upsert({
     *   create: {
     *     // ... data to create a Bn_position_fixed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bn_position_fixed we want to update
     *   }
     * })
    **/
    upsert<T extends bn_position_fixedUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bn_position_fixedUpsertArgs<ExtArgs>>
    ): Prisma__bn_position_fixedClient<$Result.GetResult<Prisma.$bn_position_fixedPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bn_position_fixeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_position_fixedCountArgs} args - Arguments to filter Bn_position_fixeds to count.
     * @example
     * // Count the number of Bn_position_fixeds
     * const count = await prisma.bn_position_fixed.count({
     *   where: {
     *     // ... the filter for the Bn_position_fixeds we want to count
     *   }
     * })
    **/
    count<T extends bn_position_fixedCountArgs>(
      args?: Subset<T, bn_position_fixedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bn_position_fixedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bn_position_fixed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bn_position_fixedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bn_position_fixedAggregateArgs>(args: Subset<T, Bn_position_fixedAggregateArgs>): Prisma.PrismaPromise<GetBn_position_fixedAggregateType<T>>

    /**
     * Group by Bn_position_fixed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_position_fixedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bn_position_fixedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bn_position_fixedGroupByArgs['orderBy'] }
        : { orderBy?: bn_position_fixedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bn_position_fixedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBn_position_fixedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bn_position_fixed model
   */
  readonly fields: bn_position_fixedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bn_position_fixed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bn_position_fixedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bn_position_fixed model
   */ 
  interface bn_position_fixedFieldRefs {
    readonly id: FieldRef<"bn_position_fixed", 'Int'>
    readonly position_number: FieldRef<"bn_position_fixed", 'Int'>
    readonly news_id: FieldRef<"bn_position_fixed", 'Int'>
    readonly is_fixed: FieldRef<"bn_position_fixed", 'Int'>
    readonly created_at: FieldRef<"bn_position_fixed", 'DateTime'>
    readonly updated_at: FieldRef<"bn_position_fixed", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * bn_position_fixed findUnique
   */
  export type bn_position_fixedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_position_fixed
     */
    select?: bn_position_fixedSelect<ExtArgs> | null
    /**
     * Filter, which bn_position_fixed to fetch.
     */
    where: bn_position_fixedWhereUniqueInput
  }


  /**
   * bn_position_fixed findUniqueOrThrow
   */
  export type bn_position_fixedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_position_fixed
     */
    select?: bn_position_fixedSelect<ExtArgs> | null
    /**
     * Filter, which bn_position_fixed to fetch.
     */
    where: bn_position_fixedWhereUniqueInput
  }


  /**
   * bn_position_fixed findFirst
   */
  export type bn_position_fixedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_position_fixed
     */
    select?: bn_position_fixedSelect<ExtArgs> | null
    /**
     * Filter, which bn_position_fixed to fetch.
     */
    where?: bn_position_fixedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_position_fixeds to fetch.
     */
    orderBy?: bn_position_fixedOrderByWithRelationInput | bn_position_fixedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_position_fixeds.
     */
    cursor?: bn_position_fixedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_position_fixeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_position_fixeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_position_fixeds.
     */
    distinct?: Bn_position_fixedScalarFieldEnum | Bn_position_fixedScalarFieldEnum[]
  }


  /**
   * bn_position_fixed findFirstOrThrow
   */
  export type bn_position_fixedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_position_fixed
     */
    select?: bn_position_fixedSelect<ExtArgs> | null
    /**
     * Filter, which bn_position_fixed to fetch.
     */
    where?: bn_position_fixedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_position_fixeds to fetch.
     */
    orderBy?: bn_position_fixedOrderByWithRelationInput | bn_position_fixedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_position_fixeds.
     */
    cursor?: bn_position_fixedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_position_fixeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_position_fixeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_position_fixeds.
     */
    distinct?: Bn_position_fixedScalarFieldEnum | Bn_position_fixedScalarFieldEnum[]
  }


  /**
   * bn_position_fixed findMany
   */
  export type bn_position_fixedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_position_fixed
     */
    select?: bn_position_fixedSelect<ExtArgs> | null
    /**
     * Filter, which bn_position_fixeds to fetch.
     */
    where?: bn_position_fixedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_position_fixeds to fetch.
     */
    orderBy?: bn_position_fixedOrderByWithRelationInput | bn_position_fixedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bn_position_fixeds.
     */
    cursor?: bn_position_fixedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_position_fixeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_position_fixeds.
     */
    skip?: number
    distinct?: Bn_position_fixedScalarFieldEnum | Bn_position_fixedScalarFieldEnum[]
  }


  /**
   * bn_position_fixed create
   */
  export type bn_position_fixedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_position_fixed
     */
    select?: bn_position_fixedSelect<ExtArgs> | null
    /**
     * The data needed to create a bn_position_fixed.
     */
    data?: XOR<bn_position_fixedCreateInput, bn_position_fixedUncheckedCreateInput>
  }


  /**
   * bn_position_fixed createMany
   */
  export type bn_position_fixedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bn_position_fixeds.
     */
    data: bn_position_fixedCreateManyInput | bn_position_fixedCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bn_position_fixed update
   */
  export type bn_position_fixedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_position_fixed
     */
    select?: bn_position_fixedSelect<ExtArgs> | null
    /**
     * The data needed to update a bn_position_fixed.
     */
    data: XOR<bn_position_fixedUpdateInput, bn_position_fixedUncheckedUpdateInput>
    /**
     * Choose, which bn_position_fixed to update.
     */
    where: bn_position_fixedWhereUniqueInput
  }


  /**
   * bn_position_fixed updateMany
   */
  export type bn_position_fixedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bn_position_fixeds.
     */
    data: XOR<bn_position_fixedUpdateManyMutationInput, bn_position_fixedUncheckedUpdateManyInput>
    /**
     * Filter which bn_position_fixeds to update
     */
    where?: bn_position_fixedWhereInput
  }


  /**
   * bn_position_fixed upsert
   */
  export type bn_position_fixedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_position_fixed
     */
    select?: bn_position_fixedSelect<ExtArgs> | null
    /**
     * The filter to search for the bn_position_fixed to update in case it exists.
     */
    where: bn_position_fixedWhereUniqueInput
    /**
     * In case the bn_position_fixed found by the `where` argument doesn't exist, create a new bn_position_fixed with this data.
     */
    create: XOR<bn_position_fixedCreateInput, bn_position_fixedUncheckedCreateInput>
    /**
     * In case the bn_position_fixed was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bn_position_fixedUpdateInput, bn_position_fixedUncheckedUpdateInput>
  }


  /**
   * bn_position_fixed delete
   */
  export type bn_position_fixedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_position_fixed
     */
    select?: bn_position_fixedSelect<ExtArgs> | null
    /**
     * Filter which bn_position_fixed to delete.
     */
    where: bn_position_fixedWhereUniqueInput
  }


  /**
   * bn_position_fixed deleteMany
   */
  export type bn_position_fixedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_position_fixeds to delete
     */
    where?: bn_position_fixedWhereInput
  }


  /**
   * bn_position_fixed without action
   */
  export type bn_position_fixedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_position_fixed
     */
    select?: bn_position_fixedSelect<ExtArgs> | null
  }



  /**
   * Model bn_subcategories
   */

  export type AggregateBn_subcategories = {
    _count: Bn_subcategoriesCountAggregateOutputType | null
    _avg: Bn_subcategoriesAvgAggregateOutputType | null
    _sum: Bn_subcategoriesSumAggregateOutputType | null
    _min: Bn_subcategoriesMinAggregateOutputType | null
    _max: Bn_subcategoriesMaxAggregateOutputType | null
  }

  export type Bn_subcategoriesAvgAggregateOutputType = {
    subcat_id: number | null
    cat_id: number | null
    subcat_position: number | null
    status: number | null
    deletable: number | null
  }

  export type Bn_subcategoriesSumAggregateOutputType = {
    subcat_id: number | null
    cat_id: number | null
    subcat_position: number | null
    status: number | null
    deletable: number | null
  }

  export type Bn_subcategoriesMinAggregateOutputType = {
    subcat_id: number | null
    cat_id: number | null
    subcat_name: string | null
    subcat_name_bn: string | null
    subcat_slug: string | null
    subcat_meta_keyword: string | null
    subcat_meta_description: string | null
    subcat_position: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_subcategoriesMaxAggregateOutputType = {
    subcat_id: number | null
    cat_id: number | null
    subcat_name: string | null
    subcat_name_bn: string | null
    subcat_slug: string | null
    subcat_meta_keyword: string | null
    subcat_meta_description: string | null
    subcat_position: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_subcategoriesCountAggregateOutputType = {
    subcat_id: number
    cat_id: number
    subcat_name: number
    subcat_name_bn: number
    subcat_slug: number
    subcat_meta_keyword: number
    subcat_meta_description: number
    subcat_position: number
    status: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Bn_subcategoriesAvgAggregateInputType = {
    subcat_id?: true
    cat_id?: true
    subcat_position?: true
    status?: true
    deletable?: true
  }

  export type Bn_subcategoriesSumAggregateInputType = {
    subcat_id?: true
    cat_id?: true
    subcat_position?: true
    status?: true
    deletable?: true
  }

  export type Bn_subcategoriesMinAggregateInputType = {
    subcat_id?: true
    cat_id?: true
    subcat_name?: true
    subcat_name_bn?: true
    subcat_slug?: true
    subcat_meta_keyword?: true
    subcat_meta_description?: true
    subcat_position?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_subcategoriesMaxAggregateInputType = {
    subcat_id?: true
    cat_id?: true
    subcat_name?: true
    subcat_name_bn?: true
    subcat_slug?: true
    subcat_meta_keyword?: true
    subcat_meta_description?: true
    subcat_position?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_subcategoriesCountAggregateInputType = {
    subcat_id?: true
    cat_id?: true
    subcat_name?: true
    subcat_name_bn?: true
    subcat_slug?: true
    subcat_meta_keyword?: true
    subcat_meta_description?: true
    subcat_position?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Bn_subcategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_subcategories to aggregate.
     */
    where?: bn_subcategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_subcategories to fetch.
     */
    orderBy?: bn_subcategoriesOrderByWithRelationInput | bn_subcategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bn_subcategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_subcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bn_subcategories
    **/
    _count?: true | Bn_subcategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bn_subcategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bn_subcategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bn_subcategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bn_subcategoriesMaxAggregateInputType
  }

  export type GetBn_subcategoriesAggregateType<T extends Bn_subcategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateBn_subcategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBn_subcategories[P]>
      : GetScalarType<T[P], AggregateBn_subcategories[P]>
  }




  export type bn_subcategoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bn_subcategoriesWhereInput
    orderBy?: bn_subcategoriesOrderByWithAggregationInput | bn_subcategoriesOrderByWithAggregationInput[]
    by: Bn_subcategoriesScalarFieldEnum[] | Bn_subcategoriesScalarFieldEnum
    having?: bn_subcategoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bn_subcategoriesCountAggregateInputType | true
    _avg?: Bn_subcategoriesAvgAggregateInputType
    _sum?: Bn_subcategoriesSumAggregateInputType
    _min?: Bn_subcategoriesMinAggregateInputType
    _max?: Bn_subcategoriesMaxAggregateInputType
  }

  export type Bn_subcategoriesGroupByOutputType = {
    subcat_id: number
    cat_id: number
    subcat_name: string
    subcat_name_bn: string
    subcat_slug: string
    subcat_meta_keyword: string | null
    subcat_meta_description: string | null
    subcat_position: number
    status: number
    deletable: number
    created_at: Date | null
    updated_at: Date | null
    _count: Bn_subcategoriesCountAggregateOutputType | null
    _avg: Bn_subcategoriesAvgAggregateOutputType | null
    _sum: Bn_subcategoriesSumAggregateOutputType | null
    _min: Bn_subcategoriesMinAggregateOutputType | null
    _max: Bn_subcategoriesMaxAggregateOutputType | null
  }

  type GetBn_subcategoriesGroupByPayload<T extends bn_subcategoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bn_subcategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bn_subcategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bn_subcategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], Bn_subcategoriesGroupByOutputType[P]>
        }
      >
    >


  export type bn_subcategoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subcat_id?: boolean
    cat_id?: boolean
    subcat_name?: boolean
    subcat_name_bn?: boolean
    subcat_slug?: boolean
    subcat_meta_keyword?: boolean
    subcat_meta_description?: boolean
    subcat_position?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["bn_subcategories"]>

  export type bn_subcategoriesSelectScalar = {
    subcat_id?: boolean
    cat_id?: boolean
    subcat_name?: boolean
    subcat_name_bn?: boolean
    subcat_slug?: boolean
    subcat_meta_keyword?: boolean
    subcat_meta_description?: boolean
    subcat_position?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $bn_subcategoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bn_subcategories"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      subcat_id: number
      cat_id: number
      subcat_name: string
      subcat_name_bn: string
      subcat_slug: string
      subcat_meta_keyword: string | null
      subcat_meta_description: string | null
      subcat_position: number
      status: number
      deletable: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["bn_subcategories"]>
    composites: {}
  }


  type bn_subcategoriesGetPayload<S extends boolean | null | undefined | bn_subcategoriesDefaultArgs> = $Result.GetResult<Prisma.$bn_subcategoriesPayload, S>

  type bn_subcategoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bn_subcategoriesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bn_subcategoriesCountAggregateInputType | true
    }

  export interface bn_subcategoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bn_subcategories'], meta: { name: 'bn_subcategories' } }
    /**
     * Find zero or one Bn_subcategories that matches the filter.
     * @param {bn_subcategoriesFindUniqueArgs} args - Arguments to find a Bn_subcategories
     * @example
     * // Get one Bn_subcategories
     * const bn_subcategories = await prisma.bn_subcategories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bn_subcategoriesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bn_subcategoriesFindUniqueArgs<ExtArgs>>
    ): Prisma__bn_subcategoriesClient<$Result.GetResult<Prisma.$bn_subcategoriesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bn_subcategories that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bn_subcategoriesFindUniqueOrThrowArgs} args - Arguments to find a Bn_subcategories
     * @example
     * // Get one Bn_subcategories
     * const bn_subcategories = await prisma.bn_subcategories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bn_subcategoriesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_subcategoriesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bn_subcategoriesClient<$Result.GetResult<Prisma.$bn_subcategoriesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bn_subcategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_subcategoriesFindFirstArgs} args - Arguments to find a Bn_subcategories
     * @example
     * // Get one Bn_subcategories
     * const bn_subcategories = await prisma.bn_subcategories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bn_subcategoriesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_subcategoriesFindFirstArgs<ExtArgs>>
    ): Prisma__bn_subcategoriesClient<$Result.GetResult<Prisma.$bn_subcategoriesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bn_subcategories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_subcategoriesFindFirstOrThrowArgs} args - Arguments to find a Bn_subcategories
     * @example
     * // Get one Bn_subcategories
     * const bn_subcategories = await prisma.bn_subcategories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bn_subcategoriesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_subcategoriesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bn_subcategoriesClient<$Result.GetResult<Prisma.$bn_subcategoriesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bn_subcategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_subcategoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bn_subcategories
     * const bn_subcategories = await prisma.bn_subcategories.findMany()
     * 
     * // Get first 10 Bn_subcategories
     * const bn_subcategories = await prisma.bn_subcategories.findMany({ take: 10 })
     * 
     * // Only select the `subcat_id`
     * const bn_subcategoriesWithSubcat_idOnly = await prisma.bn_subcategories.findMany({ select: { subcat_id: true } })
     * 
    **/
    findMany<T extends bn_subcategoriesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_subcategoriesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bn_subcategoriesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bn_subcategories.
     * @param {bn_subcategoriesCreateArgs} args - Arguments to create a Bn_subcategories.
     * @example
     * // Create one Bn_subcategories
     * const Bn_subcategories = await prisma.bn_subcategories.create({
     *   data: {
     *     // ... data to create a Bn_subcategories
     *   }
     * })
     * 
    **/
    create<T extends bn_subcategoriesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_subcategoriesCreateArgs<ExtArgs>>
    ): Prisma__bn_subcategoriesClient<$Result.GetResult<Prisma.$bn_subcategoriesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bn_subcategories.
     *     @param {bn_subcategoriesCreateManyArgs} args - Arguments to create many Bn_subcategories.
     *     @example
     *     // Create many Bn_subcategories
     *     const bn_subcategories = await prisma.bn_subcategories.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bn_subcategoriesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_subcategoriesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bn_subcategories.
     * @param {bn_subcategoriesDeleteArgs} args - Arguments to delete one Bn_subcategories.
     * @example
     * // Delete one Bn_subcategories
     * const Bn_subcategories = await prisma.bn_subcategories.delete({
     *   where: {
     *     // ... filter to delete one Bn_subcategories
     *   }
     * })
     * 
    **/
    delete<T extends bn_subcategoriesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bn_subcategoriesDeleteArgs<ExtArgs>>
    ): Prisma__bn_subcategoriesClient<$Result.GetResult<Prisma.$bn_subcategoriesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bn_subcategories.
     * @param {bn_subcategoriesUpdateArgs} args - Arguments to update one Bn_subcategories.
     * @example
     * // Update one Bn_subcategories
     * const bn_subcategories = await prisma.bn_subcategories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bn_subcategoriesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_subcategoriesUpdateArgs<ExtArgs>>
    ): Prisma__bn_subcategoriesClient<$Result.GetResult<Prisma.$bn_subcategoriesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bn_subcategories.
     * @param {bn_subcategoriesDeleteManyArgs} args - Arguments to filter Bn_subcategories to delete.
     * @example
     * // Delete a few Bn_subcategories
     * const { count } = await prisma.bn_subcategories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bn_subcategoriesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_subcategoriesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bn_subcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_subcategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bn_subcategories
     * const bn_subcategories = await prisma.bn_subcategories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bn_subcategoriesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bn_subcategoriesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bn_subcategories.
     * @param {bn_subcategoriesUpsertArgs} args - Arguments to update or create a Bn_subcategories.
     * @example
     * // Update or create a Bn_subcategories
     * const bn_subcategories = await prisma.bn_subcategories.upsert({
     *   create: {
     *     // ... data to create a Bn_subcategories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bn_subcategories we want to update
     *   }
     * })
    **/
    upsert<T extends bn_subcategoriesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bn_subcategoriesUpsertArgs<ExtArgs>>
    ): Prisma__bn_subcategoriesClient<$Result.GetResult<Prisma.$bn_subcategoriesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bn_subcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_subcategoriesCountArgs} args - Arguments to filter Bn_subcategories to count.
     * @example
     * // Count the number of Bn_subcategories
     * const count = await prisma.bn_subcategories.count({
     *   where: {
     *     // ... the filter for the Bn_subcategories we want to count
     *   }
     * })
    **/
    count<T extends bn_subcategoriesCountArgs>(
      args?: Subset<T, bn_subcategoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bn_subcategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bn_subcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bn_subcategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bn_subcategoriesAggregateArgs>(args: Subset<T, Bn_subcategoriesAggregateArgs>): Prisma.PrismaPromise<GetBn_subcategoriesAggregateType<T>>

    /**
     * Group by Bn_subcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_subcategoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bn_subcategoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bn_subcategoriesGroupByArgs['orderBy'] }
        : { orderBy?: bn_subcategoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bn_subcategoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBn_subcategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bn_subcategories model
   */
  readonly fields: bn_subcategoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bn_subcategories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bn_subcategoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bn_subcategories model
   */ 
  interface bn_subcategoriesFieldRefs {
    readonly subcat_id: FieldRef<"bn_subcategories", 'Int'>
    readonly cat_id: FieldRef<"bn_subcategories", 'Int'>
    readonly subcat_name: FieldRef<"bn_subcategories", 'String'>
    readonly subcat_name_bn: FieldRef<"bn_subcategories", 'String'>
    readonly subcat_slug: FieldRef<"bn_subcategories", 'String'>
    readonly subcat_meta_keyword: FieldRef<"bn_subcategories", 'String'>
    readonly subcat_meta_description: FieldRef<"bn_subcategories", 'String'>
    readonly subcat_position: FieldRef<"bn_subcategories", 'Int'>
    readonly status: FieldRef<"bn_subcategories", 'Int'>
    readonly deletable: FieldRef<"bn_subcategories", 'Int'>
    readonly created_at: FieldRef<"bn_subcategories", 'DateTime'>
    readonly updated_at: FieldRef<"bn_subcategories", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * bn_subcategories findUnique
   */
  export type bn_subcategoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_subcategories
     */
    select?: bn_subcategoriesSelect<ExtArgs> | null
    /**
     * Filter, which bn_subcategories to fetch.
     */
    where: bn_subcategoriesWhereUniqueInput
  }


  /**
   * bn_subcategories findUniqueOrThrow
   */
  export type bn_subcategoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_subcategories
     */
    select?: bn_subcategoriesSelect<ExtArgs> | null
    /**
     * Filter, which bn_subcategories to fetch.
     */
    where: bn_subcategoriesWhereUniqueInput
  }


  /**
   * bn_subcategories findFirst
   */
  export type bn_subcategoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_subcategories
     */
    select?: bn_subcategoriesSelect<ExtArgs> | null
    /**
     * Filter, which bn_subcategories to fetch.
     */
    where?: bn_subcategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_subcategories to fetch.
     */
    orderBy?: bn_subcategoriesOrderByWithRelationInput | bn_subcategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_subcategories.
     */
    cursor?: bn_subcategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_subcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_subcategories.
     */
    distinct?: Bn_subcategoriesScalarFieldEnum | Bn_subcategoriesScalarFieldEnum[]
  }


  /**
   * bn_subcategories findFirstOrThrow
   */
  export type bn_subcategoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_subcategories
     */
    select?: bn_subcategoriesSelect<ExtArgs> | null
    /**
     * Filter, which bn_subcategories to fetch.
     */
    where?: bn_subcategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_subcategories to fetch.
     */
    orderBy?: bn_subcategoriesOrderByWithRelationInput | bn_subcategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_subcategories.
     */
    cursor?: bn_subcategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_subcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_subcategories.
     */
    distinct?: Bn_subcategoriesScalarFieldEnum | Bn_subcategoriesScalarFieldEnum[]
  }


  /**
   * bn_subcategories findMany
   */
  export type bn_subcategoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_subcategories
     */
    select?: bn_subcategoriesSelect<ExtArgs> | null
    /**
     * Filter, which bn_subcategories to fetch.
     */
    where?: bn_subcategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_subcategories to fetch.
     */
    orderBy?: bn_subcategoriesOrderByWithRelationInput | bn_subcategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bn_subcategories.
     */
    cursor?: bn_subcategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_subcategories.
     */
    skip?: number
    distinct?: Bn_subcategoriesScalarFieldEnum | Bn_subcategoriesScalarFieldEnum[]
  }


  /**
   * bn_subcategories create
   */
  export type bn_subcategoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_subcategories
     */
    select?: bn_subcategoriesSelect<ExtArgs> | null
    /**
     * The data needed to create a bn_subcategories.
     */
    data: XOR<bn_subcategoriesCreateInput, bn_subcategoriesUncheckedCreateInput>
  }


  /**
   * bn_subcategories createMany
   */
  export type bn_subcategoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bn_subcategories.
     */
    data: bn_subcategoriesCreateManyInput | bn_subcategoriesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bn_subcategories update
   */
  export type bn_subcategoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_subcategories
     */
    select?: bn_subcategoriesSelect<ExtArgs> | null
    /**
     * The data needed to update a bn_subcategories.
     */
    data: XOR<bn_subcategoriesUpdateInput, bn_subcategoriesUncheckedUpdateInput>
    /**
     * Choose, which bn_subcategories to update.
     */
    where: bn_subcategoriesWhereUniqueInput
  }


  /**
   * bn_subcategories updateMany
   */
  export type bn_subcategoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bn_subcategories.
     */
    data: XOR<bn_subcategoriesUpdateManyMutationInput, bn_subcategoriesUncheckedUpdateManyInput>
    /**
     * Filter which bn_subcategories to update
     */
    where?: bn_subcategoriesWhereInput
  }


  /**
   * bn_subcategories upsert
   */
  export type bn_subcategoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_subcategories
     */
    select?: bn_subcategoriesSelect<ExtArgs> | null
    /**
     * The filter to search for the bn_subcategories to update in case it exists.
     */
    where: bn_subcategoriesWhereUniqueInput
    /**
     * In case the bn_subcategories found by the `where` argument doesn't exist, create a new bn_subcategories with this data.
     */
    create: XOR<bn_subcategoriesCreateInput, bn_subcategoriesUncheckedCreateInput>
    /**
     * In case the bn_subcategories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bn_subcategoriesUpdateInput, bn_subcategoriesUncheckedUpdateInput>
  }


  /**
   * bn_subcategories delete
   */
  export type bn_subcategoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_subcategories
     */
    select?: bn_subcategoriesSelect<ExtArgs> | null
    /**
     * Filter which bn_subcategories to delete.
     */
    where: bn_subcategoriesWhereUniqueInput
  }


  /**
   * bn_subcategories deleteMany
   */
  export type bn_subcategoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_subcategories to delete
     */
    where?: bn_subcategoriesWhereInput
  }


  /**
   * bn_subcategories without action
   */
  export type bn_subcategoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_subcategories
     */
    select?: bn_subcategoriesSelect<ExtArgs> | null
  }



  /**
   * Model bn_tags
   */

  export type AggregateBn_tags = {
    _count: Bn_tagsCountAggregateOutputType | null
    _avg: Bn_tagsAvgAggregateOutputType | null
    _sum: Bn_tagsSumAggregateOutputType | null
    _min: Bn_tagsMinAggregateOutputType | null
    _max: Bn_tagsMaxAggregateOutputType | null
  }

  export type Bn_tagsAvgAggregateOutputType = {
    tag_id: number | null
    tag_type: number | null
    approval: number | null
    deletable: number | null
  }

  export type Bn_tagsSumAggregateOutputType = {
    tag_id: number | null
    tag_type: number | null
    approval: number | null
    deletable: number | null
  }

  export type Bn_tagsMinAggregateOutputType = {
    tag_id: number | null
    tag_type: number | null
    tag_name: string | null
    tag_slug: string | null
    description: string | null
    img_path: string | null
    approval: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_tagsMaxAggregateOutputType = {
    tag_id: number | null
    tag_type: number | null
    tag_name: string | null
    tag_slug: string | null
    description: string | null
    img_path: string | null
    approval: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_tagsCountAggregateOutputType = {
    tag_id: number
    tag_type: number
    tag_name: number
    tag_slug: number
    description: number
    img_path: number
    approval: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Bn_tagsAvgAggregateInputType = {
    tag_id?: true
    tag_type?: true
    approval?: true
    deletable?: true
  }

  export type Bn_tagsSumAggregateInputType = {
    tag_id?: true
    tag_type?: true
    approval?: true
    deletable?: true
  }

  export type Bn_tagsMinAggregateInputType = {
    tag_id?: true
    tag_type?: true
    tag_name?: true
    tag_slug?: true
    description?: true
    img_path?: true
    approval?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_tagsMaxAggregateInputType = {
    tag_id?: true
    tag_type?: true
    tag_name?: true
    tag_slug?: true
    description?: true
    img_path?: true
    approval?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_tagsCountAggregateInputType = {
    tag_id?: true
    tag_type?: true
    tag_name?: true
    tag_slug?: true
    description?: true
    img_path?: true
    approval?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Bn_tagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_tags to aggregate.
     */
    where?: bn_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_tags to fetch.
     */
    orderBy?: bn_tagsOrderByWithRelationInput | bn_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bn_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bn_tags
    **/
    _count?: true | Bn_tagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bn_tagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bn_tagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bn_tagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bn_tagsMaxAggregateInputType
  }

  export type GetBn_tagsAggregateType<T extends Bn_tagsAggregateArgs> = {
        [P in keyof T & keyof AggregateBn_tags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBn_tags[P]>
      : GetScalarType<T[P], AggregateBn_tags[P]>
  }




  export type bn_tagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bn_tagsWhereInput
    orderBy?: bn_tagsOrderByWithAggregationInput | bn_tagsOrderByWithAggregationInput[]
    by: Bn_tagsScalarFieldEnum[] | Bn_tagsScalarFieldEnum
    having?: bn_tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bn_tagsCountAggregateInputType | true
    _avg?: Bn_tagsAvgAggregateInputType
    _sum?: Bn_tagsSumAggregateInputType
    _min?: Bn_tagsMinAggregateInputType
    _max?: Bn_tagsMaxAggregateInputType
  }

  export type Bn_tagsGroupByOutputType = {
    tag_id: number
    tag_type: number | null
    tag_name: string
    tag_slug: string
    description: string | null
    img_path: string | null
    approval: number
    deletable: number
    created_at: Date | null
    updated_at: Date | null
    _count: Bn_tagsCountAggregateOutputType | null
    _avg: Bn_tagsAvgAggregateOutputType | null
    _sum: Bn_tagsSumAggregateOutputType | null
    _min: Bn_tagsMinAggregateOutputType | null
    _max: Bn_tagsMaxAggregateOutputType | null
  }

  type GetBn_tagsGroupByPayload<T extends bn_tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bn_tagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bn_tagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bn_tagsGroupByOutputType[P]>
            : GetScalarType<T[P], Bn_tagsGroupByOutputType[P]>
        }
      >
    >


  export type bn_tagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tag_id?: boolean
    tag_type?: boolean
    tag_name?: boolean
    tag_slug?: boolean
    description?: boolean
    img_path?: boolean
    approval?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["bn_tags"]>

  export type bn_tagsSelectScalar = {
    tag_id?: boolean
    tag_type?: boolean
    tag_name?: boolean
    tag_slug?: boolean
    description?: boolean
    img_path?: boolean
    approval?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $bn_tagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bn_tags"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      tag_id: number
      tag_type: number | null
      tag_name: string
      tag_slug: string
      description: string | null
      img_path: string | null
      approval: number
      deletable: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["bn_tags"]>
    composites: {}
  }


  type bn_tagsGetPayload<S extends boolean | null | undefined | bn_tagsDefaultArgs> = $Result.GetResult<Prisma.$bn_tagsPayload, S>

  type bn_tagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bn_tagsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bn_tagsCountAggregateInputType | true
    }

  export interface bn_tagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bn_tags'], meta: { name: 'bn_tags' } }
    /**
     * Find zero or one Bn_tags that matches the filter.
     * @param {bn_tagsFindUniqueArgs} args - Arguments to find a Bn_tags
     * @example
     * // Get one Bn_tags
     * const bn_tags = await prisma.bn_tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bn_tagsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bn_tagsFindUniqueArgs<ExtArgs>>
    ): Prisma__bn_tagsClient<$Result.GetResult<Prisma.$bn_tagsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bn_tags that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bn_tagsFindUniqueOrThrowArgs} args - Arguments to find a Bn_tags
     * @example
     * // Get one Bn_tags
     * const bn_tags = await prisma.bn_tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bn_tagsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_tagsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bn_tagsClient<$Result.GetResult<Prisma.$bn_tagsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bn_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_tagsFindFirstArgs} args - Arguments to find a Bn_tags
     * @example
     * // Get one Bn_tags
     * const bn_tags = await prisma.bn_tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bn_tagsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_tagsFindFirstArgs<ExtArgs>>
    ): Prisma__bn_tagsClient<$Result.GetResult<Prisma.$bn_tagsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bn_tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_tagsFindFirstOrThrowArgs} args - Arguments to find a Bn_tags
     * @example
     * // Get one Bn_tags
     * const bn_tags = await prisma.bn_tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bn_tagsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_tagsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bn_tagsClient<$Result.GetResult<Prisma.$bn_tagsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bn_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_tagsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bn_tags
     * const bn_tags = await prisma.bn_tags.findMany()
     * 
     * // Get first 10 Bn_tags
     * const bn_tags = await prisma.bn_tags.findMany({ take: 10 })
     * 
     * // Only select the `tag_id`
     * const bn_tagsWithTag_idOnly = await prisma.bn_tags.findMany({ select: { tag_id: true } })
     * 
    **/
    findMany<T extends bn_tagsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_tagsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bn_tagsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bn_tags.
     * @param {bn_tagsCreateArgs} args - Arguments to create a Bn_tags.
     * @example
     * // Create one Bn_tags
     * const Bn_tags = await prisma.bn_tags.create({
     *   data: {
     *     // ... data to create a Bn_tags
     *   }
     * })
     * 
    **/
    create<T extends bn_tagsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_tagsCreateArgs<ExtArgs>>
    ): Prisma__bn_tagsClient<$Result.GetResult<Prisma.$bn_tagsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bn_tags.
     *     @param {bn_tagsCreateManyArgs} args - Arguments to create many Bn_tags.
     *     @example
     *     // Create many Bn_tags
     *     const bn_tags = await prisma.bn_tags.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bn_tagsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_tagsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bn_tags.
     * @param {bn_tagsDeleteArgs} args - Arguments to delete one Bn_tags.
     * @example
     * // Delete one Bn_tags
     * const Bn_tags = await prisma.bn_tags.delete({
     *   where: {
     *     // ... filter to delete one Bn_tags
     *   }
     * })
     * 
    **/
    delete<T extends bn_tagsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bn_tagsDeleteArgs<ExtArgs>>
    ): Prisma__bn_tagsClient<$Result.GetResult<Prisma.$bn_tagsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bn_tags.
     * @param {bn_tagsUpdateArgs} args - Arguments to update one Bn_tags.
     * @example
     * // Update one Bn_tags
     * const bn_tags = await prisma.bn_tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bn_tagsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_tagsUpdateArgs<ExtArgs>>
    ): Prisma__bn_tagsClient<$Result.GetResult<Prisma.$bn_tagsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bn_tags.
     * @param {bn_tagsDeleteManyArgs} args - Arguments to filter Bn_tags to delete.
     * @example
     * // Delete a few Bn_tags
     * const { count } = await prisma.bn_tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bn_tagsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_tagsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bn_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bn_tags
     * const bn_tags = await prisma.bn_tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bn_tagsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bn_tagsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bn_tags.
     * @param {bn_tagsUpsertArgs} args - Arguments to update or create a Bn_tags.
     * @example
     * // Update or create a Bn_tags
     * const bn_tags = await prisma.bn_tags.upsert({
     *   create: {
     *     // ... data to create a Bn_tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bn_tags we want to update
     *   }
     * })
    **/
    upsert<T extends bn_tagsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bn_tagsUpsertArgs<ExtArgs>>
    ): Prisma__bn_tagsClient<$Result.GetResult<Prisma.$bn_tagsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bn_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_tagsCountArgs} args - Arguments to filter Bn_tags to count.
     * @example
     * // Count the number of Bn_tags
     * const count = await prisma.bn_tags.count({
     *   where: {
     *     // ... the filter for the Bn_tags we want to count
     *   }
     * })
    **/
    count<T extends bn_tagsCountArgs>(
      args?: Subset<T, bn_tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bn_tagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bn_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bn_tagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bn_tagsAggregateArgs>(args: Subset<T, Bn_tagsAggregateArgs>): Prisma.PrismaPromise<GetBn_tagsAggregateType<T>>

    /**
     * Group by Bn_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bn_tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bn_tagsGroupByArgs['orderBy'] }
        : { orderBy?: bn_tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bn_tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBn_tagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bn_tags model
   */
  readonly fields: bn_tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bn_tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bn_tagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bn_tags model
   */ 
  interface bn_tagsFieldRefs {
    readonly tag_id: FieldRef<"bn_tags", 'Int'>
    readonly tag_type: FieldRef<"bn_tags", 'Int'>
    readonly tag_name: FieldRef<"bn_tags", 'String'>
    readonly tag_slug: FieldRef<"bn_tags", 'String'>
    readonly description: FieldRef<"bn_tags", 'String'>
    readonly img_path: FieldRef<"bn_tags", 'String'>
    readonly approval: FieldRef<"bn_tags", 'Int'>
    readonly deletable: FieldRef<"bn_tags", 'Int'>
    readonly created_at: FieldRef<"bn_tags", 'DateTime'>
    readonly updated_at: FieldRef<"bn_tags", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * bn_tags findUnique
   */
  export type bn_tagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_tags
     */
    select?: bn_tagsSelect<ExtArgs> | null
    /**
     * Filter, which bn_tags to fetch.
     */
    where: bn_tagsWhereUniqueInput
  }


  /**
   * bn_tags findUniqueOrThrow
   */
  export type bn_tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_tags
     */
    select?: bn_tagsSelect<ExtArgs> | null
    /**
     * Filter, which bn_tags to fetch.
     */
    where: bn_tagsWhereUniqueInput
  }


  /**
   * bn_tags findFirst
   */
  export type bn_tagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_tags
     */
    select?: bn_tagsSelect<ExtArgs> | null
    /**
     * Filter, which bn_tags to fetch.
     */
    where?: bn_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_tags to fetch.
     */
    orderBy?: bn_tagsOrderByWithRelationInput | bn_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_tags.
     */
    cursor?: bn_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_tags.
     */
    distinct?: Bn_tagsScalarFieldEnum | Bn_tagsScalarFieldEnum[]
  }


  /**
   * bn_tags findFirstOrThrow
   */
  export type bn_tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_tags
     */
    select?: bn_tagsSelect<ExtArgs> | null
    /**
     * Filter, which bn_tags to fetch.
     */
    where?: bn_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_tags to fetch.
     */
    orderBy?: bn_tagsOrderByWithRelationInput | bn_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_tags.
     */
    cursor?: bn_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_tags.
     */
    distinct?: Bn_tagsScalarFieldEnum | Bn_tagsScalarFieldEnum[]
  }


  /**
   * bn_tags findMany
   */
  export type bn_tagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_tags
     */
    select?: bn_tagsSelect<ExtArgs> | null
    /**
     * Filter, which bn_tags to fetch.
     */
    where?: bn_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_tags to fetch.
     */
    orderBy?: bn_tagsOrderByWithRelationInput | bn_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bn_tags.
     */
    cursor?: bn_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_tags.
     */
    skip?: number
    distinct?: Bn_tagsScalarFieldEnum | Bn_tagsScalarFieldEnum[]
  }


  /**
   * bn_tags create
   */
  export type bn_tagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_tags
     */
    select?: bn_tagsSelect<ExtArgs> | null
    /**
     * The data needed to create a bn_tags.
     */
    data: XOR<bn_tagsCreateInput, bn_tagsUncheckedCreateInput>
  }


  /**
   * bn_tags createMany
   */
  export type bn_tagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bn_tags.
     */
    data: bn_tagsCreateManyInput | bn_tagsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bn_tags update
   */
  export type bn_tagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_tags
     */
    select?: bn_tagsSelect<ExtArgs> | null
    /**
     * The data needed to update a bn_tags.
     */
    data: XOR<bn_tagsUpdateInput, bn_tagsUncheckedUpdateInput>
    /**
     * Choose, which bn_tags to update.
     */
    where: bn_tagsWhereUniqueInput
  }


  /**
   * bn_tags updateMany
   */
  export type bn_tagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bn_tags.
     */
    data: XOR<bn_tagsUpdateManyMutationInput, bn_tagsUncheckedUpdateManyInput>
    /**
     * Filter which bn_tags to update
     */
    where?: bn_tagsWhereInput
  }


  /**
   * bn_tags upsert
   */
  export type bn_tagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_tags
     */
    select?: bn_tagsSelect<ExtArgs> | null
    /**
     * The filter to search for the bn_tags to update in case it exists.
     */
    where: bn_tagsWhereUniqueInput
    /**
     * In case the bn_tags found by the `where` argument doesn't exist, create a new bn_tags with this data.
     */
    create: XOR<bn_tagsCreateInput, bn_tagsUncheckedCreateInput>
    /**
     * In case the bn_tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bn_tagsUpdateInput, bn_tagsUncheckedUpdateInput>
  }


  /**
   * bn_tags delete
   */
  export type bn_tagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_tags
     */
    select?: bn_tagsSelect<ExtArgs> | null
    /**
     * Filter which bn_tags to delete.
     */
    where: bn_tagsWhereUniqueInput
  }


  /**
   * bn_tags deleteMany
   */
  export type bn_tagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_tags to delete
     */
    where?: bn_tagsWhereInput
  }


  /**
   * bn_tags without action
   */
  export type bn_tagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_tags
     */
    select?: bn_tagsSelect<ExtArgs> | null
  }



  /**
   * Model bn_video_categories
   */

  export type AggregateBn_video_categories = {
    _count: Bn_video_categoriesCountAggregateOutputType | null
    _avg: Bn_video_categoriesAvgAggregateOutputType | null
    _sum: Bn_video_categoriesSumAggregateOutputType | null
    _min: Bn_video_categoriesMinAggregateOutputType | null
    _max: Bn_video_categoriesMaxAggregateOutputType | null
  }

  export type Bn_video_categoriesAvgAggregateOutputType = {
    id: number | null
    position: number | null
    user_id: number | null
    status: number | null
    deletable: number | null
  }

  export type Bn_video_categoriesSumAggregateOutputType = {
    id: number | null
    position: number | null
    user_id: number | null
    status: number | null
    deletable: number | null
  }

  export type Bn_video_categoriesMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    name_bn: string | null
    meta_keywords: string | null
    meta_description: string | null
    og_img_path: string | null
    position: number | null
    user_id: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_video_categoriesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    name_bn: string | null
    meta_keywords: string | null
    meta_description: string | null
    og_img_path: string | null
    position: number | null
    user_id: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_video_categoriesCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    name_bn: number
    meta_keywords: number
    meta_description: number
    og_img_path: number
    position: number
    user_id: number
    status: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Bn_video_categoriesAvgAggregateInputType = {
    id?: true
    position?: true
    user_id?: true
    status?: true
    deletable?: true
  }

  export type Bn_video_categoriesSumAggregateInputType = {
    id?: true
    position?: true
    user_id?: true
    status?: true
    deletable?: true
  }

  export type Bn_video_categoriesMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    name_bn?: true
    meta_keywords?: true
    meta_description?: true
    og_img_path?: true
    position?: true
    user_id?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_video_categoriesMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    name_bn?: true
    meta_keywords?: true
    meta_description?: true
    og_img_path?: true
    position?: true
    user_id?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_video_categoriesCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    name_bn?: true
    meta_keywords?: true
    meta_description?: true
    og_img_path?: true
    position?: true
    user_id?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Bn_video_categoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_video_categories to aggregate.
     */
    where?: bn_video_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_video_categories to fetch.
     */
    orderBy?: bn_video_categoriesOrderByWithRelationInput | bn_video_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bn_video_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_video_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_video_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bn_video_categories
    **/
    _count?: true | Bn_video_categoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bn_video_categoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bn_video_categoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bn_video_categoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bn_video_categoriesMaxAggregateInputType
  }

  export type GetBn_video_categoriesAggregateType<T extends Bn_video_categoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateBn_video_categories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBn_video_categories[P]>
      : GetScalarType<T[P], AggregateBn_video_categories[P]>
  }




  export type bn_video_categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bn_video_categoriesWhereInput
    orderBy?: bn_video_categoriesOrderByWithAggregationInput | bn_video_categoriesOrderByWithAggregationInput[]
    by: Bn_video_categoriesScalarFieldEnum[] | Bn_video_categoriesScalarFieldEnum
    having?: bn_video_categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bn_video_categoriesCountAggregateInputType | true
    _avg?: Bn_video_categoriesAvgAggregateInputType
    _sum?: Bn_video_categoriesSumAggregateInputType
    _min?: Bn_video_categoriesMinAggregateInputType
    _max?: Bn_video_categoriesMaxAggregateInputType
  }

  export type Bn_video_categoriesGroupByOutputType = {
    id: number
    name: string | null
    slug: string | null
    name_bn: string | null
    meta_keywords: string | null
    meta_description: string | null
    og_img_path: string | null
    position: number | null
    user_id: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
    _count: Bn_video_categoriesCountAggregateOutputType | null
    _avg: Bn_video_categoriesAvgAggregateOutputType | null
    _sum: Bn_video_categoriesSumAggregateOutputType | null
    _min: Bn_video_categoriesMinAggregateOutputType | null
    _max: Bn_video_categoriesMaxAggregateOutputType | null
  }

  type GetBn_video_categoriesGroupByPayload<T extends bn_video_categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bn_video_categoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bn_video_categoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bn_video_categoriesGroupByOutputType[P]>
            : GetScalarType<T[P], Bn_video_categoriesGroupByOutputType[P]>
        }
      >
    >


  export type bn_video_categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    name_bn?: boolean
    meta_keywords?: boolean
    meta_description?: boolean
    og_img_path?: boolean
    position?: boolean
    user_id?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["bn_video_categories"]>

  export type bn_video_categoriesSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    name_bn?: boolean
    meta_keywords?: boolean
    meta_description?: boolean
    og_img_path?: boolean
    position?: boolean
    user_id?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $bn_video_categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bn_video_categories"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      slug: string | null
      name_bn: string | null
      meta_keywords: string | null
      meta_description: string | null
      og_img_path: string | null
      position: number | null
      user_id: number | null
      status: number | null
      deletable: number | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["bn_video_categories"]>
    composites: {}
  }


  type bn_video_categoriesGetPayload<S extends boolean | null | undefined | bn_video_categoriesDefaultArgs> = $Result.GetResult<Prisma.$bn_video_categoriesPayload, S>

  type bn_video_categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bn_video_categoriesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bn_video_categoriesCountAggregateInputType | true
    }

  export interface bn_video_categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bn_video_categories'], meta: { name: 'bn_video_categories' } }
    /**
     * Find zero or one Bn_video_categories that matches the filter.
     * @param {bn_video_categoriesFindUniqueArgs} args - Arguments to find a Bn_video_categories
     * @example
     * // Get one Bn_video_categories
     * const bn_video_categories = await prisma.bn_video_categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bn_video_categoriesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bn_video_categoriesFindUniqueArgs<ExtArgs>>
    ): Prisma__bn_video_categoriesClient<$Result.GetResult<Prisma.$bn_video_categoriesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bn_video_categories that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bn_video_categoriesFindUniqueOrThrowArgs} args - Arguments to find a Bn_video_categories
     * @example
     * // Get one Bn_video_categories
     * const bn_video_categories = await prisma.bn_video_categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bn_video_categoriesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_video_categoriesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bn_video_categoriesClient<$Result.GetResult<Prisma.$bn_video_categoriesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bn_video_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_video_categoriesFindFirstArgs} args - Arguments to find a Bn_video_categories
     * @example
     * // Get one Bn_video_categories
     * const bn_video_categories = await prisma.bn_video_categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bn_video_categoriesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_video_categoriesFindFirstArgs<ExtArgs>>
    ): Prisma__bn_video_categoriesClient<$Result.GetResult<Prisma.$bn_video_categoriesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bn_video_categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_video_categoriesFindFirstOrThrowArgs} args - Arguments to find a Bn_video_categories
     * @example
     * // Get one Bn_video_categories
     * const bn_video_categories = await prisma.bn_video_categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bn_video_categoriesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_video_categoriesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bn_video_categoriesClient<$Result.GetResult<Prisma.$bn_video_categoriesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bn_video_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_video_categoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bn_video_categories
     * const bn_video_categories = await prisma.bn_video_categories.findMany()
     * 
     * // Get first 10 Bn_video_categories
     * const bn_video_categories = await prisma.bn_video_categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bn_video_categoriesWithIdOnly = await prisma.bn_video_categories.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends bn_video_categoriesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_video_categoriesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bn_video_categoriesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bn_video_categories.
     * @param {bn_video_categoriesCreateArgs} args - Arguments to create a Bn_video_categories.
     * @example
     * // Create one Bn_video_categories
     * const Bn_video_categories = await prisma.bn_video_categories.create({
     *   data: {
     *     // ... data to create a Bn_video_categories
     *   }
     * })
     * 
    **/
    create<T extends bn_video_categoriesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_video_categoriesCreateArgs<ExtArgs>>
    ): Prisma__bn_video_categoriesClient<$Result.GetResult<Prisma.$bn_video_categoriesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bn_video_categories.
     *     @param {bn_video_categoriesCreateManyArgs} args - Arguments to create many Bn_video_categories.
     *     @example
     *     // Create many Bn_video_categories
     *     const bn_video_categories = await prisma.bn_video_categories.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bn_video_categoriesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_video_categoriesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bn_video_categories.
     * @param {bn_video_categoriesDeleteArgs} args - Arguments to delete one Bn_video_categories.
     * @example
     * // Delete one Bn_video_categories
     * const Bn_video_categories = await prisma.bn_video_categories.delete({
     *   where: {
     *     // ... filter to delete one Bn_video_categories
     *   }
     * })
     * 
    **/
    delete<T extends bn_video_categoriesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bn_video_categoriesDeleteArgs<ExtArgs>>
    ): Prisma__bn_video_categoriesClient<$Result.GetResult<Prisma.$bn_video_categoriesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bn_video_categories.
     * @param {bn_video_categoriesUpdateArgs} args - Arguments to update one Bn_video_categories.
     * @example
     * // Update one Bn_video_categories
     * const bn_video_categories = await prisma.bn_video_categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bn_video_categoriesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_video_categoriesUpdateArgs<ExtArgs>>
    ): Prisma__bn_video_categoriesClient<$Result.GetResult<Prisma.$bn_video_categoriesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bn_video_categories.
     * @param {bn_video_categoriesDeleteManyArgs} args - Arguments to filter Bn_video_categories to delete.
     * @example
     * // Delete a few Bn_video_categories
     * const { count } = await prisma.bn_video_categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bn_video_categoriesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_video_categoriesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bn_video_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_video_categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bn_video_categories
     * const bn_video_categories = await prisma.bn_video_categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bn_video_categoriesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bn_video_categoriesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bn_video_categories.
     * @param {bn_video_categoriesUpsertArgs} args - Arguments to update or create a Bn_video_categories.
     * @example
     * // Update or create a Bn_video_categories
     * const bn_video_categories = await prisma.bn_video_categories.upsert({
     *   create: {
     *     // ... data to create a Bn_video_categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bn_video_categories we want to update
     *   }
     * })
    **/
    upsert<T extends bn_video_categoriesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bn_video_categoriesUpsertArgs<ExtArgs>>
    ): Prisma__bn_video_categoriesClient<$Result.GetResult<Prisma.$bn_video_categoriesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bn_video_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_video_categoriesCountArgs} args - Arguments to filter Bn_video_categories to count.
     * @example
     * // Count the number of Bn_video_categories
     * const count = await prisma.bn_video_categories.count({
     *   where: {
     *     // ... the filter for the Bn_video_categories we want to count
     *   }
     * })
    **/
    count<T extends bn_video_categoriesCountArgs>(
      args?: Subset<T, bn_video_categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bn_video_categoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bn_video_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bn_video_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bn_video_categoriesAggregateArgs>(args: Subset<T, Bn_video_categoriesAggregateArgs>): Prisma.PrismaPromise<GetBn_video_categoriesAggregateType<T>>

    /**
     * Group by Bn_video_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_video_categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bn_video_categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bn_video_categoriesGroupByArgs['orderBy'] }
        : { orderBy?: bn_video_categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bn_video_categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBn_video_categoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bn_video_categories model
   */
  readonly fields: bn_video_categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bn_video_categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bn_video_categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bn_video_categories model
   */ 
  interface bn_video_categoriesFieldRefs {
    readonly id: FieldRef<"bn_video_categories", 'Int'>
    readonly name: FieldRef<"bn_video_categories", 'String'>
    readonly slug: FieldRef<"bn_video_categories", 'String'>
    readonly name_bn: FieldRef<"bn_video_categories", 'String'>
    readonly meta_keywords: FieldRef<"bn_video_categories", 'String'>
    readonly meta_description: FieldRef<"bn_video_categories", 'String'>
    readonly og_img_path: FieldRef<"bn_video_categories", 'String'>
    readonly position: FieldRef<"bn_video_categories", 'Int'>
    readonly user_id: FieldRef<"bn_video_categories", 'Int'>
    readonly status: FieldRef<"bn_video_categories", 'Int'>
    readonly deletable: FieldRef<"bn_video_categories", 'Int'>
    readonly created_at: FieldRef<"bn_video_categories", 'DateTime'>
    readonly updated_at: FieldRef<"bn_video_categories", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * bn_video_categories findUnique
   */
  export type bn_video_categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_video_categories
     */
    select?: bn_video_categoriesSelect<ExtArgs> | null
    /**
     * Filter, which bn_video_categories to fetch.
     */
    where: bn_video_categoriesWhereUniqueInput
  }


  /**
   * bn_video_categories findUniqueOrThrow
   */
  export type bn_video_categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_video_categories
     */
    select?: bn_video_categoriesSelect<ExtArgs> | null
    /**
     * Filter, which bn_video_categories to fetch.
     */
    where: bn_video_categoriesWhereUniqueInput
  }


  /**
   * bn_video_categories findFirst
   */
  export type bn_video_categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_video_categories
     */
    select?: bn_video_categoriesSelect<ExtArgs> | null
    /**
     * Filter, which bn_video_categories to fetch.
     */
    where?: bn_video_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_video_categories to fetch.
     */
    orderBy?: bn_video_categoriesOrderByWithRelationInput | bn_video_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_video_categories.
     */
    cursor?: bn_video_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_video_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_video_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_video_categories.
     */
    distinct?: Bn_video_categoriesScalarFieldEnum | Bn_video_categoriesScalarFieldEnum[]
  }


  /**
   * bn_video_categories findFirstOrThrow
   */
  export type bn_video_categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_video_categories
     */
    select?: bn_video_categoriesSelect<ExtArgs> | null
    /**
     * Filter, which bn_video_categories to fetch.
     */
    where?: bn_video_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_video_categories to fetch.
     */
    orderBy?: bn_video_categoriesOrderByWithRelationInput | bn_video_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_video_categories.
     */
    cursor?: bn_video_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_video_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_video_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_video_categories.
     */
    distinct?: Bn_video_categoriesScalarFieldEnum | Bn_video_categoriesScalarFieldEnum[]
  }


  /**
   * bn_video_categories findMany
   */
  export type bn_video_categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_video_categories
     */
    select?: bn_video_categoriesSelect<ExtArgs> | null
    /**
     * Filter, which bn_video_categories to fetch.
     */
    where?: bn_video_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_video_categories to fetch.
     */
    orderBy?: bn_video_categoriesOrderByWithRelationInput | bn_video_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bn_video_categories.
     */
    cursor?: bn_video_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_video_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_video_categories.
     */
    skip?: number
    distinct?: Bn_video_categoriesScalarFieldEnum | Bn_video_categoriesScalarFieldEnum[]
  }


  /**
   * bn_video_categories create
   */
  export type bn_video_categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_video_categories
     */
    select?: bn_video_categoriesSelect<ExtArgs> | null
    /**
     * The data needed to create a bn_video_categories.
     */
    data?: XOR<bn_video_categoriesCreateInput, bn_video_categoriesUncheckedCreateInput>
  }


  /**
   * bn_video_categories createMany
   */
  export type bn_video_categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bn_video_categories.
     */
    data: bn_video_categoriesCreateManyInput | bn_video_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bn_video_categories update
   */
  export type bn_video_categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_video_categories
     */
    select?: bn_video_categoriesSelect<ExtArgs> | null
    /**
     * The data needed to update a bn_video_categories.
     */
    data: XOR<bn_video_categoriesUpdateInput, bn_video_categoriesUncheckedUpdateInput>
    /**
     * Choose, which bn_video_categories to update.
     */
    where: bn_video_categoriesWhereUniqueInput
  }


  /**
   * bn_video_categories updateMany
   */
  export type bn_video_categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bn_video_categories.
     */
    data: XOR<bn_video_categoriesUpdateManyMutationInput, bn_video_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which bn_video_categories to update
     */
    where?: bn_video_categoriesWhereInput
  }


  /**
   * bn_video_categories upsert
   */
  export type bn_video_categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_video_categories
     */
    select?: bn_video_categoriesSelect<ExtArgs> | null
    /**
     * The filter to search for the bn_video_categories to update in case it exists.
     */
    where: bn_video_categoriesWhereUniqueInput
    /**
     * In case the bn_video_categories found by the `where` argument doesn't exist, create a new bn_video_categories with this data.
     */
    create: XOR<bn_video_categoriesCreateInput, bn_video_categoriesUncheckedCreateInput>
    /**
     * In case the bn_video_categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bn_video_categoriesUpdateInput, bn_video_categoriesUncheckedUpdateInput>
  }


  /**
   * bn_video_categories delete
   */
  export type bn_video_categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_video_categories
     */
    select?: bn_video_categoriesSelect<ExtArgs> | null
    /**
     * Filter which bn_video_categories to delete.
     */
    where: bn_video_categoriesWhereUniqueInput
  }


  /**
   * bn_video_categories deleteMany
   */
  export type bn_video_categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_video_categories to delete
     */
    where?: bn_video_categoriesWhereInput
  }


  /**
   * bn_video_categories without action
   */
  export type bn_video_categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_video_categories
     */
    select?: bn_video_categoriesSelect<ExtArgs> | null
  }



  /**
   * Model bn_video_positions
   */

  export type AggregateBn_video_positions = {
    _count: Bn_video_positionsCountAggregateOutputType | null
    _avg: Bn_video_positionsAvgAggregateOutputType | null
    _sum: Bn_video_positionsSumAggregateOutputType | null
    _min: Bn_video_positionsMinAggregateOutputType | null
    _max: Bn_video_positionsMaxAggregateOutputType | null
  }

  export type Bn_video_positionsAvgAggregateOutputType = {
    position_id: number | null
    cat_id: number | null
    subcat_id: number | null
    total_video: number | null
    deletable: number | null
  }

  export type Bn_video_positionsSumAggregateOutputType = {
    position_id: number | null
    cat_id: number | null
    subcat_id: number | null
    total_video: number | null
    deletable: number | null
  }

  export type Bn_video_positionsMinAggregateOutputType = {
    position_id: number | null
    position_name: string | null
    cat_id: number | null
    subcat_id: number | null
    video_ids: string | null
    total_video: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_video_positionsMaxAggregateOutputType = {
    position_id: number | null
    position_name: string | null
    cat_id: number | null
    subcat_id: number | null
    video_ids: string | null
    total_video: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_video_positionsCountAggregateOutputType = {
    position_id: number
    position_name: number
    cat_id: number
    subcat_id: number
    video_ids: number
    total_video: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Bn_video_positionsAvgAggregateInputType = {
    position_id?: true
    cat_id?: true
    subcat_id?: true
    total_video?: true
    deletable?: true
  }

  export type Bn_video_positionsSumAggregateInputType = {
    position_id?: true
    cat_id?: true
    subcat_id?: true
    total_video?: true
    deletable?: true
  }

  export type Bn_video_positionsMinAggregateInputType = {
    position_id?: true
    position_name?: true
    cat_id?: true
    subcat_id?: true
    video_ids?: true
    total_video?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_video_positionsMaxAggregateInputType = {
    position_id?: true
    position_name?: true
    cat_id?: true
    subcat_id?: true
    video_ids?: true
    total_video?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_video_positionsCountAggregateInputType = {
    position_id?: true
    position_name?: true
    cat_id?: true
    subcat_id?: true
    video_ids?: true
    total_video?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Bn_video_positionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_video_positions to aggregate.
     */
    where?: bn_video_positionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_video_positions to fetch.
     */
    orderBy?: bn_video_positionsOrderByWithRelationInput | bn_video_positionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bn_video_positionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_video_positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_video_positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bn_video_positions
    **/
    _count?: true | Bn_video_positionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bn_video_positionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bn_video_positionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bn_video_positionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bn_video_positionsMaxAggregateInputType
  }

  export type GetBn_video_positionsAggregateType<T extends Bn_video_positionsAggregateArgs> = {
        [P in keyof T & keyof AggregateBn_video_positions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBn_video_positions[P]>
      : GetScalarType<T[P], AggregateBn_video_positions[P]>
  }




  export type bn_video_positionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bn_video_positionsWhereInput
    orderBy?: bn_video_positionsOrderByWithAggregationInput | bn_video_positionsOrderByWithAggregationInput[]
    by: Bn_video_positionsScalarFieldEnum[] | Bn_video_positionsScalarFieldEnum
    having?: bn_video_positionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bn_video_positionsCountAggregateInputType | true
    _avg?: Bn_video_positionsAvgAggregateInputType
    _sum?: Bn_video_positionsSumAggregateInputType
    _min?: Bn_video_positionsMinAggregateInputType
    _max?: Bn_video_positionsMaxAggregateInputType
  }

  export type Bn_video_positionsGroupByOutputType = {
    position_id: number
    position_name: string
    cat_id: number | null
    subcat_id: number | null
    video_ids: string | null
    total_video: number | null
    deletable: number
    created_at: Date | null
    updated_at: Date | null
    _count: Bn_video_positionsCountAggregateOutputType | null
    _avg: Bn_video_positionsAvgAggregateOutputType | null
    _sum: Bn_video_positionsSumAggregateOutputType | null
    _min: Bn_video_positionsMinAggregateOutputType | null
    _max: Bn_video_positionsMaxAggregateOutputType | null
  }

  type GetBn_video_positionsGroupByPayload<T extends bn_video_positionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bn_video_positionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bn_video_positionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bn_video_positionsGroupByOutputType[P]>
            : GetScalarType<T[P], Bn_video_positionsGroupByOutputType[P]>
        }
      >
    >


  export type bn_video_positionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    position_id?: boolean
    position_name?: boolean
    cat_id?: boolean
    subcat_id?: boolean
    video_ids?: boolean
    total_video?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["bn_video_positions"]>

  export type bn_video_positionsSelectScalar = {
    position_id?: boolean
    position_name?: boolean
    cat_id?: boolean
    subcat_id?: boolean
    video_ids?: boolean
    total_video?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $bn_video_positionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bn_video_positions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      position_id: number
      position_name: string
      cat_id: number | null
      subcat_id: number | null
      video_ids: string | null
      total_video: number | null
      deletable: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["bn_video_positions"]>
    composites: {}
  }


  type bn_video_positionsGetPayload<S extends boolean | null | undefined | bn_video_positionsDefaultArgs> = $Result.GetResult<Prisma.$bn_video_positionsPayload, S>

  type bn_video_positionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bn_video_positionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bn_video_positionsCountAggregateInputType | true
    }

  export interface bn_video_positionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bn_video_positions'], meta: { name: 'bn_video_positions' } }
    /**
     * Find zero or one Bn_video_positions that matches the filter.
     * @param {bn_video_positionsFindUniqueArgs} args - Arguments to find a Bn_video_positions
     * @example
     * // Get one Bn_video_positions
     * const bn_video_positions = await prisma.bn_video_positions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bn_video_positionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bn_video_positionsFindUniqueArgs<ExtArgs>>
    ): Prisma__bn_video_positionsClient<$Result.GetResult<Prisma.$bn_video_positionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bn_video_positions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bn_video_positionsFindUniqueOrThrowArgs} args - Arguments to find a Bn_video_positions
     * @example
     * // Get one Bn_video_positions
     * const bn_video_positions = await prisma.bn_video_positions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bn_video_positionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_video_positionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bn_video_positionsClient<$Result.GetResult<Prisma.$bn_video_positionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bn_video_positions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_video_positionsFindFirstArgs} args - Arguments to find a Bn_video_positions
     * @example
     * // Get one Bn_video_positions
     * const bn_video_positions = await prisma.bn_video_positions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bn_video_positionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_video_positionsFindFirstArgs<ExtArgs>>
    ): Prisma__bn_video_positionsClient<$Result.GetResult<Prisma.$bn_video_positionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bn_video_positions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_video_positionsFindFirstOrThrowArgs} args - Arguments to find a Bn_video_positions
     * @example
     * // Get one Bn_video_positions
     * const bn_video_positions = await prisma.bn_video_positions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bn_video_positionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_video_positionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bn_video_positionsClient<$Result.GetResult<Prisma.$bn_video_positionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bn_video_positions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_video_positionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bn_video_positions
     * const bn_video_positions = await prisma.bn_video_positions.findMany()
     * 
     * // Get first 10 Bn_video_positions
     * const bn_video_positions = await prisma.bn_video_positions.findMany({ take: 10 })
     * 
     * // Only select the `position_id`
     * const bn_video_positionsWithPosition_idOnly = await prisma.bn_video_positions.findMany({ select: { position_id: true } })
     * 
    **/
    findMany<T extends bn_video_positionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_video_positionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bn_video_positionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bn_video_positions.
     * @param {bn_video_positionsCreateArgs} args - Arguments to create a Bn_video_positions.
     * @example
     * // Create one Bn_video_positions
     * const Bn_video_positions = await prisma.bn_video_positions.create({
     *   data: {
     *     // ... data to create a Bn_video_positions
     *   }
     * })
     * 
    **/
    create<T extends bn_video_positionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_video_positionsCreateArgs<ExtArgs>>
    ): Prisma__bn_video_positionsClient<$Result.GetResult<Prisma.$bn_video_positionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bn_video_positions.
     *     @param {bn_video_positionsCreateManyArgs} args - Arguments to create many Bn_video_positions.
     *     @example
     *     // Create many Bn_video_positions
     *     const bn_video_positions = await prisma.bn_video_positions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bn_video_positionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_video_positionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bn_video_positions.
     * @param {bn_video_positionsDeleteArgs} args - Arguments to delete one Bn_video_positions.
     * @example
     * // Delete one Bn_video_positions
     * const Bn_video_positions = await prisma.bn_video_positions.delete({
     *   where: {
     *     // ... filter to delete one Bn_video_positions
     *   }
     * })
     * 
    **/
    delete<T extends bn_video_positionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bn_video_positionsDeleteArgs<ExtArgs>>
    ): Prisma__bn_video_positionsClient<$Result.GetResult<Prisma.$bn_video_positionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bn_video_positions.
     * @param {bn_video_positionsUpdateArgs} args - Arguments to update one Bn_video_positions.
     * @example
     * // Update one Bn_video_positions
     * const bn_video_positions = await prisma.bn_video_positions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bn_video_positionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_video_positionsUpdateArgs<ExtArgs>>
    ): Prisma__bn_video_positionsClient<$Result.GetResult<Prisma.$bn_video_positionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bn_video_positions.
     * @param {bn_video_positionsDeleteManyArgs} args - Arguments to filter Bn_video_positions to delete.
     * @example
     * // Delete a few Bn_video_positions
     * const { count } = await prisma.bn_video_positions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bn_video_positionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_video_positionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bn_video_positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_video_positionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bn_video_positions
     * const bn_video_positions = await prisma.bn_video_positions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bn_video_positionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bn_video_positionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bn_video_positions.
     * @param {bn_video_positionsUpsertArgs} args - Arguments to update or create a Bn_video_positions.
     * @example
     * // Update or create a Bn_video_positions
     * const bn_video_positions = await prisma.bn_video_positions.upsert({
     *   create: {
     *     // ... data to create a Bn_video_positions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bn_video_positions we want to update
     *   }
     * })
    **/
    upsert<T extends bn_video_positionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bn_video_positionsUpsertArgs<ExtArgs>>
    ): Prisma__bn_video_positionsClient<$Result.GetResult<Prisma.$bn_video_positionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bn_video_positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_video_positionsCountArgs} args - Arguments to filter Bn_video_positions to count.
     * @example
     * // Count the number of Bn_video_positions
     * const count = await prisma.bn_video_positions.count({
     *   where: {
     *     // ... the filter for the Bn_video_positions we want to count
     *   }
     * })
    **/
    count<T extends bn_video_positionsCountArgs>(
      args?: Subset<T, bn_video_positionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bn_video_positionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bn_video_positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bn_video_positionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bn_video_positionsAggregateArgs>(args: Subset<T, Bn_video_positionsAggregateArgs>): Prisma.PrismaPromise<GetBn_video_positionsAggregateType<T>>

    /**
     * Group by Bn_video_positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_video_positionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bn_video_positionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bn_video_positionsGroupByArgs['orderBy'] }
        : { orderBy?: bn_video_positionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bn_video_positionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBn_video_positionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bn_video_positions model
   */
  readonly fields: bn_video_positionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bn_video_positions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bn_video_positionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bn_video_positions model
   */ 
  interface bn_video_positionsFieldRefs {
    readonly position_id: FieldRef<"bn_video_positions", 'Int'>
    readonly position_name: FieldRef<"bn_video_positions", 'String'>
    readonly cat_id: FieldRef<"bn_video_positions", 'Int'>
    readonly subcat_id: FieldRef<"bn_video_positions", 'Int'>
    readonly video_ids: FieldRef<"bn_video_positions", 'String'>
    readonly total_video: FieldRef<"bn_video_positions", 'Int'>
    readonly deletable: FieldRef<"bn_video_positions", 'Int'>
    readonly created_at: FieldRef<"bn_video_positions", 'DateTime'>
    readonly updated_at: FieldRef<"bn_video_positions", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * bn_video_positions findUnique
   */
  export type bn_video_positionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_video_positions
     */
    select?: bn_video_positionsSelect<ExtArgs> | null
    /**
     * Filter, which bn_video_positions to fetch.
     */
    where: bn_video_positionsWhereUniqueInput
  }


  /**
   * bn_video_positions findUniqueOrThrow
   */
  export type bn_video_positionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_video_positions
     */
    select?: bn_video_positionsSelect<ExtArgs> | null
    /**
     * Filter, which bn_video_positions to fetch.
     */
    where: bn_video_positionsWhereUniqueInput
  }


  /**
   * bn_video_positions findFirst
   */
  export type bn_video_positionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_video_positions
     */
    select?: bn_video_positionsSelect<ExtArgs> | null
    /**
     * Filter, which bn_video_positions to fetch.
     */
    where?: bn_video_positionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_video_positions to fetch.
     */
    orderBy?: bn_video_positionsOrderByWithRelationInput | bn_video_positionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_video_positions.
     */
    cursor?: bn_video_positionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_video_positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_video_positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_video_positions.
     */
    distinct?: Bn_video_positionsScalarFieldEnum | Bn_video_positionsScalarFieldEnum[]
  }


  /**
   * bn_video_positions findFirstOrThrow
   */
  export type bn_video_positionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_video_positions
     */
    select?: bn_video_positionsSelect<ExtArgs> | null
    /**
     * Filter, which bn_video_positions to fetch.
     */
    where?: bn_video_positionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_video_positions to fetch.
     */
    orderBy?: bn_video_positionsOrderByWithRelationInput | bn_video_positionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_video_positions.
     */
    cursor?: bn_video_positionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_video_positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_video_positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_video_positions.
     */
    distinct?: Bn_video_positionsScalarFieldEnum | Bn_video_positionsScalarFieldEnum[]
  }


  /**
   * bn_video_positions findMany
   */
  export type bn_video_positionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_video_positions
     */
    select?: bn_video_positionsSelect<ExtArgs> | null
    /**
     * Filter, which bn_video_positions to fetch.
     */
    where?: bn_video_positionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_video_positions to fetch.
     */
    orderBy?: bn_video_positionsOrderByWithRelationInput | bn_video_positionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bn_video_positions.
     */
    cursor?: bn_video_positionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_video_positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_video_positions.
     */
    skip?: number
    distinct?: Bn_video_positionsScalarFieldEnum | Bn_video_positionsScalarFieldEnum[]
  }


  /**
   * bn_video_positions create
   */
  export type bn_video_positionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_video_positions
     */
    select?: bn_video_positionsSelect<ExtArgs> | null
    /**
     * The data needed to create a bn_video_positions.
     */
    data: XOR<bn_video_positionsCreateInput, bn_video_positionsUncheckedCreateInput>
  }


  /**
   * bn_video_positions createMany
   */
  export type bn_video_positionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bn_video_positions.
     */
    data: bn_video_positionsCreateManyInput | bn_video_positionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bn_video_positions update
   */
  export type bn_video_positionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_video_positions
     */
    select?: bn_video_positionsSelect<ExtArgs> | null
    /**
     * The data needed to update a bn_video_positions.
     */
    data: XOR<bn_video_positionsUpdateInput, bn_video_positionsUncheckedUpdateInput>
    /**
     * Choose, which bn_video_positions to update.
     */
    where: bn_video_positionsWhereUniqueInput
  }


  /**
   * bn_video_positions updateMany
   */
  export type bn_video_positionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bn_video_positions.
     */
    data: XOR<bn_video_positionsUpdateManyMutationInput, bn_video_positionsUncheckedUpdateManyInput>
    /**
     * Filter which bn_video_positions to update
     */
    where?: bn_video_positionsWhereInput
  }


  /**
   * bn_video_positions upsert
   */
  export type bn_video_positionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_video_positions
     */
    select?: bn_video_positionsSelect<ExtArgs> | null
    /**
     * The filter to search for the bn_video_positions to update in case it exists.
     */
    where: bn_video_positionsWhereUniqueInput
    /**
     * In case the bn_video_positions found by the `where` argument doesn't exist, create a new bn_video_positions with this data.
     */
    create: XOR<bn_video_positionsCreateInput, bn_video_positionsUncheckedCreateInput>
    /**
     * In case the bn_video_positions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bn_video_positionsUpdateInput, bn_video_positionsUncheckedUpdateInput>
  }


  /**
   * bn_video_positions delete
   */
  export type bn_video_positionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_video_positions
     */
    select?: bn_video_positionsSelect<ExtArgs> | null
    /**
     * Filter which bn_video_positions to delete.
     */
    where: bn_video_positionsWhereUniqueInput
  }


  /**
   * bn_video_positions deleteMany
   */
  export type bn_video_positionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_video_positions to delete
     */
    where?: bn_video_positionsWhereInput
  }


  /**
   * bn_video_positions without action
   */
  export type bn_video_positionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_video_positions
     */
    select?: bn_video_positionsSelect<ExtArgs> | null
  }



  /**
   * Model bn_videos
   */

  export type AggregateBn_videos = {
    _count: Bn_videosCountAggregateOutputType | null
    _avg: Bn_videosAvgAggregateOutputType | null
    _sum: Bn_videosSumAggregateOutputType | null
    _min: Bn_videosMinAggregateOutputType | null
    _max: Bn_videosMaxAggregateOutputType | null
  }

  export type Bn_videosAvgAggregateOutputType = {
    id: number | null
    cat_id: number | null
    type: number | null
    user_id: number | null
    target: number | null
    is_live: number | null
    status: number | null
    deletable: number | null
  }

  export type Bn_videosSumAggregateOutputType = {
    id: number | null
    cat_id: number | null
    type: number | null
    user_id: number | null
    target: number | null
    is_live: number | null
    status: number | null
    deletable: number | null
  }

  export type Bn_videosMinAggregateOutputType = {
    id: number | null
    cat_id: number | null
    type: number | null
    title: string | null
    code: string | null
    img_bg_path: string | null
    img_sm_path: string | null
    img_xs_path: string | null
    link: string | null
    meta_keywords: string | null
    meta_description: string | null
    user_id: number | null
    target: number | null
    is_live: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_videosMaxAggregateOutputType = {
    id: number | null
    cat_id: number | null
    type: number | null
    title: string | null
    code: string | null
    img_bg_path: string | null
    img_sm_path: string | null
    img_xs_path: string | null
    link: string | null
    meta_keywords: string | null
    meta_description: string | null
    user_id: number | null
    target: number | null
    is_live: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Bn_videosCountAggregateOutputType = {
    id: number
    cat_id: number
    type: number
    title: number
    code: number
    img_bg_path: number
    img_sm_path: number
    img_xs_path: number
    link: number
    meta_keywords: number
    meta_description: number
    user_id: number
    target: number
    is_live: number
    status: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Bn_videosAvgAggregateInputType = {
    id?: true
    cat_id?: true
    type?: true
    user_id?: true
    target?: true
    is_live?: true
    status?: true
    deletable?: true
  }

  export type Bn_videosSumAggregateInputType = {
    id?: true
    cat_id?: true
    type?: true
    user_id?: true
    target?: true
    is_live?: true
    status?: true
    deletable?: true
  }

  export type Bn_videosMinAggregateInputType = {
    id?: true
    cat_id?: true
    type?: true
    title?: true
    code?: true
    img_bg_path?: true
    img_sm_path?: true
    img_xs_path?: true
    link?: true
    meta_keywords?: true
    meta_description?: true
    user_id?: true
    target?: true
    is_live?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_videosMaxAggregateInputType = {
    id?: true
    cat_id?: true
    type?: true
    title?: true
    code?: true
    img_bg_path?: true
    img_sm_path?: true
    img_xs_path?: true
    link?: true
    meta_keywords?: true
    meta_description?: true
    user_id?: true
    target?: true
    is_live?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Bn_videosCountAggregateInputType = {
    id?: true
    cat_id?: true
    type?: true
    title?: true
    code?: true
    img_bg_path?: true
    img_sm_path?: true
    img_xs_path?: true
    link?: true
    meta_keywords?: true
    meta_description?: true
    user_id?: true
    target?: true
    is_live?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Bn_videosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_videos to aggregate.
     */
    where?: bn_videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_videos to fetch.
     */
    orderBy?: bn_videosOrderByWithRelationInput | bn_videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bn_videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bn_videos
    **/
    _count?: true | Bn_videosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bn_videosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bn_videosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bn_videosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bn_videosMaxAggregateInputType
  }

  export type GetBn_videosAggregateType<T extends Bn_videosAggregateArgs> = {
        [P in keyof T & keyof AggregateBn_videos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBn_videos[P]>
      : GetScalarType<T[P], AggregateBn_videos[P]>
  }




  export type bn_videosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bn_videosWhereInput
    orderBy?: bn_videosOrderByWithAggregationInput | bn_videosOrderByWithAggregationInput[]
    by: Bn_videosScalarFieldEnum[] | Bn_videosScalarFieldEnum
    having?: bn_videosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bn_videosCountAggregateInputType | true
    _avg?: Bn_videosAvgAggregateInputType
    _sum?: Bn_videosSumAggregateInputType
    _min?: Bn_videosMinAggregateInputType
    _max?: Bn_videosMaxAggregateInputType
  }

  export type Bn_videosGroupByOutputType = {
    id: number
    cat_id: number | null
    type: number | null
    title: string | null
    code: string | null
    img_bg_path: string | null
    img_sm_path: string | null
    img_xs_path: string | null
    link: string | null
    meta_keywords: string | null
    meta_description: string | null
    user_id: number | null
    target: number
    is_live: number
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
    _count: Bn_videosCountAggregateOutputType | null
    _avg: Bn_videosAvgAggregateOutputType | null
    _sum: Bn_videosSumAggregateOutputType | null
    _min: Bn_videosMinAggregateOutputType | null
    _max: Bn_videosMaxAggregateOutputType | null
  }

  type GetBn_videosGroupByPayload<T extends bn_videosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bn_videosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bn_videosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bn_videosGroupByOutputType[P]>
            : GetScalarType<T[P], Bn_videosGroupByOutputType[P]>
        }
      >
    >


  export type bn_videosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cat_id?: boolean
    type?: boolean
    title?: boolean
    code?: boolean
    img_bg_path?: boolean
    img_sm_path?: boolean
    img_xs_path?: boolean
    link?: boolean
    meta_keywords?: boolean
    meta_description?: boolean
    user_id?: boolean
    target?: boolean
    is_live?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["bn_videos"]>

  export type bn_videosSelectScalar = {
    id?: boolean
    cat_id?: boolean
    type?: boolean
    title?: boolean
    code?: boolean
    img_bg_path?: boolean
    img_sm_path?: boolean
    img_xs_path?: boolean
    link?: boolean
    meta_keywords?: boolean
    meta_description?: boolean
    user_id?: boolean
    target?: boolean
    is_live?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $bn_videosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bn_videos"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cat_id: number | null
      type: number | null
      title: string | null
      code: string | null
      img_bg_path: string | null
      img_sm_path: string | null
      img_xs_path: string | null
      link: string | null
      meta_keywords: string | null
      meta_description: string | null
      user_id: number | null
      target: number
      is_live: number
      status: number | null
      deletable: number | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["bn_videos"]>
    composites: {}
  }


  type bn_videosGetPayload<S extends boolean | null | undefined | bn_videosDefaultArgs> = $Result.GetResult<Prisma.$bn_videosPayload, S>

  type bn_videosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bn_videosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bn_videosCountAggregateInputType | true
    }

  export interface bn_videosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bn_videos'], meta: { name: 'bn_videos' } }
    /**
     * Find zero or one Bn_videos that matches the filter.
     * @param {bn_videosFindUniqueArgs} args - Arguments to find a Bn_videos
     * @example
     * // Get one Bn_videos
     * const bn_videos = await prisma.bn_videos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bn_videosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bn_videosFindUniqueArgs<ExtArgs>>
    ): Prisma__bn_videosClient<$Result.GetResult<Prisma.$bn_videosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bn_videos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bn_videosFindUniqueOrThrowArgs} args - Arguments to find a Bn_videos
     * @example
     * // Get one Bn_videos
     * const bn_videos = await prisma.bn_videos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bn_videosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_videosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bn_videosClient<$Result.GetResult<Prisma.$bn_videosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bn_videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_videosFindFirstArgs} args - Arguments to find a Bn_videos
     * @example
     * // Get one Bn_videos
     * const bn_videos = await prisma.bn_videos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bn_videosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_videosFindFirstArgs<ExtArgs>>
    ): Prisma__bn_videosClient<$Result.GetResult<Prisma.$bn_videosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bn_videos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_videosFindFirstOrThrowArgs} args - Arguments to find a Bn_videos
     * @example
     * // Get one Bn_videos
     * const bn_videos = await prisma.bn_videos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bn_videosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_videosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bn_videosClient<$Result.GetResult<Prisma.$bn_videosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bn_videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_videosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bn_videos
     * const bn_videos = await prisma.bn_videos.findMany()
     * 
     * // Get first 10 Bn_videos
     * const bn_videos = await prisma.bn_videos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bn_videosWithIdOnly = await prisma.bn_videos.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends bn_videosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_videosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bn_videosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bn_videos.
     * @param {bn_videosCreateArgs} args - Arguments to create a Bn_videos.
     * @example
     * // Create one Bn_videos
     * const Bn_videos = await prisma.bn_videos.create({
     *   data: {
     *     // ... data to create a Bn_videos
     *   }
     * })
     * 
    **/
    create<T extends bn_videosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_videosCreateArgs<ExtArgs>>
    ): Prisma__bn_videosClient<$Result.GetResult<Prisma.$bn_videosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bn_videos.
     *     @param {bn_videosCreateManyArgs} args - Arguments to create many Bn_videos.
     *     @example
     *     // Create many Bn_videos
     *     const bn_videos = await prisma.bn_videos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bn_videosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_videosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bn_videos.
     * @param {bn_videosDeleteArgs} args - Arguments to delete one Bn_videos.
     * @example
     * // Delete one Bn_videos
     * const Bn_videos = await prisma.bn_videos.delete({
     *   where: {
     *     // ... filter to delete one Bn_videos
     *   }
     * })
     * 
    **/
    delete<T extends bn_videosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bn_videosDeleteArgs<ExtArgs>>
    ): Prisma__bn_videosClient<$Result.GetResult<Prisma.$bn_videosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bn_videos.
     * @param {bn_videosUpdateArgs} args - Arguments to update one Bn_videos.
     * @example
     * // Update one Bn_videos
     * const bn_videos = await prisma.bn_videos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bn_videosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bn_videosUpdateArgs<ExtArgs>>
    ): Prisma__bn_videosClient<$Result.GetResult<Prisma.$bn_videosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bn_videos.
     * @param {bn_videosDeleteManyArgs} args - Arguments to filter Bn_videos to delete.
     * @example
     * // Delete a few Bn_videos
     * const { count } = await prisma.bn_videos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bn_videosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bn_videosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bn_videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_videosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bn_videos
     * const bn_videos = await prisma.bn_videos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bn_videosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bn_videosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bn_videos.
     * @param {bn_videosUpsertArgs} args - Arguments to update or create a Bn_videos.
     * @example
     * // Update or create a Bn_videos
     * const bn_videos = await prisma.bn_videos.upsert({
     *   create: {
     *     // ... data to create a Bn_videos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bn_videos we want to update
     *   }
     * })
    **/
    upsert<T extends bn_videosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bn_videosUpsertArgs<ExtArgs>>
    ): Prisma__bn_videosClient<$Result.GetResult<Prisma.$bn_videosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bn_videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_videosCountArgs} args - Arguments to filter Bn_videos to count.
     * @example
     * // Count the number of Bn_videos
     * const count = await prisma.bn_videos.count({
     *   where: {
     *     // ... the filter for the Bn_videos we want to count
     *   }
     * })
    **/
    count<T extends bn_videosCountArgs>(
      args?: Subset<T, bn_videosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bn_videosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bn_videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bn_videosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bn_videosAggregateArgs>(args: Subset<T, Bn_videosAggregateArgs>): Prisma.PrismaPromise<GetBn_videosAggregateType<T>>

    /**
     * Group by Bn_videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bn_videosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bn_videosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bn_videosGroupByArgs['orderBy'] }
        : { orderBy?: bn_videosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bn_videosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBn_videosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bn_videos model
   */
  readonly fields: bn_videosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bn_videos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bn_videosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bn_videos model
   */ 
  interface bn_videosFieldRefs {
    readonly id: FieldRef<"bn_videos", 'Int'>
    readonly cat_id: FieldRef<"bn_videos", 'Int'>
    readonly type: FieldRef<"bn_videos", 'Int'>
    readonly title: FieldRef<"bn_videos", 'String'>
    readonly code: FieldRef<"bn_videos", 'String'>
    readonly img_bg_path: FieldRef<"bn_videos", 'String'>
    readonly img_sm_path: FieldRef<"bn_videos", 'String'>
    readonly img_xs_path: FieldRef<"bn_videos", 'String'>
    readonly link: FieldRef<"bn_videos", 'String'>
    readonly meta_keywords: FieldRef<"bn_videos", 'String'>
    readonly meta_description: FieldRef<"bn_videos", 'String'>
    readonly user_id: FieldRef<"bn_videos", 'Int'>
    readonly target: FieldRef<"bn_videos", 'Int'>
    readonly is_live: FieldRef<"bn_videos", 'Int'>
    readonly status: FieldRef<"bn_videos", 'Int'>
    readonly deletable: FieldRef<"bn_videos", 'Int'>
    readonly created_at: FieldRef<"bn_videos", 'DateTime'>
    readonly updated_at: FieldRef<"bn_videos", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * bn_videos findUnique
   */
  export type bn_videosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_videos
     */
    select?: bn_videosSelect<ExtArgs> | null
    /**
     * Filter, which bn_videos to fetch.
     */
    where: bn_videosWhereUniqueInput
  }


  /**
   * bn_videos findUniqueOrThrow
   */
  export type bn_videosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_videos
     */
    select?: bn_videosSelect<ExtArgs> | null
    /**
     * Filter, which bn_videos to fetch.
     */
    where: bn_videosWhereUniqueInput
  }


  /**
   * bn_videos findFirst
   */
  export type bn_videosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_videos
     */
    select?: bn_videosSelect<ExtArgs> | null
    /**
     * Filter, which bn_videos to fetch.
     */
    where?: bn_videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_videos to fetch.
     */
    orderBy?: bn_videosOrderByWithRelationInput | bn_videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_videos.
     */
    cursor?: bn_videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_videos.
     */
    distinct?: Bn_videosScalarFieldEnum | Bn_videosScalarFieldEnum[]
  }


  /**
   * bn_videos findFirstOrThrow
   */
  export type bn_videosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_videos
     */
    select?: bn_videosSelect<ExtArgs> | null
    /**
     * Filter, which bn_videos to fetch.
     */
    where?: bn_videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_videos to fetch.
     */
    orderBy?: bn_videosOrderByWithRelationInput | bn_videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bn_videos.
     */
    cursor?: bn_videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bn_videos.
     */
    distinct?: Bn_videosScalarFieldEnum | Bn_videosScalarFieldEnum[]
  }


  /**
   * bn_videos findMany
   */
  export type bn_videosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_videos
     */
    select?: bn_videosSelect<ExtArgs> | null
    /**
     * Filter, which bn_videos to fetch.
     */
    where?: bn_videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bn_videos to fetch.
     */
    orderBy?: bn_videosOrderByWithRelationInput | bn_videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bn_videos.
     */
    cursor?: bn_videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bn_videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bn_videos.
     */
    skip?: number
    distinct?: Bn_videosScalarFieldEnum | Bn_videosScalarFieldEnum[]
  }


  /**
   * bn_videos create
   */
  export type bn_videosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_videos
     */
    select?: bn_videosSelect<ExtArgs> | null
    /**
     * The data needed to create a bn_videos.
     */
    data?: XOR<bn_videosCreateInput, bn_videosUncheckedCreateInput>
  }


  /**
   * bn_videos createMany
   */
  export type bn_videosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bn_videos.
     */
    data: bn_videosCreateManyInput | bn_videosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bn_videos update
   */
  export type bn_videosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_videos
     */
    select?: bn_videosSelect<ExtArgs> | null
    /**
     * The data needed to update a bn_videos.
     */
    data: XOR<bn_videosUpdateInput, bn_videosUncheckedUpdateInput>
    /**
     * Choose, which bn_videos to update.
     */
    where: bn_videosWhereUniqueInput
  }


  /**
   * bn_videos updateMany
   */
  export type bn_videosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bn_videos.
     */
    data: XOR<bn_videosUpdateManyMutationInput, bn_videosUncheckedUpdateManyInput>
    /**
     * Filter which bn_videos to update
     */
    where?: bn_videosWhereInput
  }


  /**
   * bn_videos upsert
   */
  export type bn_videosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_videos
     */
    select?: bn_videosSelect<ExtArgs> | null
    /**
     * The filter to search for the bn_videos to update in case it exists.
     */
    where: bn_videosWhereUniqueInput
    /**
     * In case the bn_videos found by the `where` argument doesn't exist, create a new bn_videos with this data.
     */
    create: XOR<bn_videosCreateInput, bn_videosUncheckedCreateInput>
    /**
     * In case the bn_videos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bn_videosUpdateInput, bn_videosUncheckedUpdateInput>
  }


  /**
   * bn_videos delete
   */
  export type bn_videosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_videos
     */
    select?: bn_videosSelect<ExtArgs> | null
    /**
     * Filter which bn_videos to delete.
     */
    where: bn_videosWhereUniqueInput
  }


  /**
   * bn_videos deleteMany
   */
  export type bn_videosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bn_videos to delete
     */
    where?: bn_videosWhereInput
  }


  /**
   * bn_videos without action
   */
  export type bn_videosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bn_videos
     */
    select?: bn_videosSelect<ExtArgs> | null
  }



  /**
   * Model countries
   */

  export type AggregateCountries = {
    _count: CountriesCountAggregateOutputType | null
    _avg: CountriesAvgAggregateOutputType | null
    _sum: CountriesSumAggregateOutputType | null
    _min: CountriesMinAggregateOutputType | null
    _max: CountriesMaxAggregateOutputType | null
  }

  export type CountriesAvgAggregateOutputType = {
    country_id: number | null
    deletable: number | null
  }

  export type CountriesSumAggregateOutputType = {
    country_id: number | null
    deletable: number | null
  }

  export type CountriesMinAggregateOutputType = {
    country_id: number | null
    country_name: string | null
    country_name_bn: string | null
    country_slug: string | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CountriesMaxAggregateOutputType = {
    country_id: number | null
    country_name: string | null
    country_name_bn: string | null
    country_slug: string | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CountriesCountAggregateOutputType = {
    country_id: number
    country_name: number
    country_name_bn: number
    country_slug: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CountriesAvgAggregateInputType = {
    country_id?: true
    deletable?: true
  }

  export type CountriesSumAggregateInputType = {
    country_id?: true
    deletable?: true
  }

  export type CountriesMinAggregateInputType = {
    country_id?: true
    country_name?: true
    country_name_bn?: true
    country_slug?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type CountriesMaxAggregateInputType = {
    country_id?: true
    country_name?: true
    country_name_bn?: true
    country_slug?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type CountriesCountAggregateInputType = {
    country_id?: true
    country_name?: true
    country_name_bn?: true
    country_slug?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CountriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which countries to aggregate.
     */
    where?: countriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countriesOrderByWithRelationInput | countriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: countriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned countries
    **/
    _count?: true | CountriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountriesMaxAggregateInputType
  }

  export type GetCountriesAggregateType<T extends CountriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCountries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountries[P]>
      : GetScalarType<T[P], AggregateCountries[P]>
  }




  export type countriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: countriesWhereInput
    orderBy?: countriesOrderByWithAggregationInput | countriesOrderByWithAggregationInput[]
    by: CountriesScalarFieldEnum[] | CountriesScalarFieldEnum
    having?: countriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountriesCountAggregateInputType | true
    _avg?: CountriesAvgAggregateInputType
    _sum?: CountriesSumAggregateInputType
    _min?: CountriesMinAggregateInputType
    _max?: CountriesMaxAggregateInputType
  }

  export type CountriesGroupByOutputType = {
    country_id: number
    country_name: string
    country_name_bn: string
    country_slug: string
    deletable: number
    created_at: Date | null
    updated_at: Date | null
    _count: CountriesCountAggregateOutputType | null
    _avg: CountriesAvgAggregateOutputType | null
    _sum: CountriesSumAggregateOutputType | null
    _min: CountriesMinAggregateOutputType | null
    _max: CountriesMaxAggregateOutputType | null
  }

  type GetCountriesGroupByPayload<T extends countriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountriesGroupByOutputType[P]>
            : GetScalarType<T[P], CountriesGroupByOutputType[P]>
        }
      >
    >


  export type countriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    country_id?: boolean
    country_name?: boolean
    country_name_bn?: boolean
    country_slug?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["countries"]>

  export type countriesSelectScalar = {
    country_id?: boolean
    country_name?: boolean
    country_name_bn?: boolean
    country_slug?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $countriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "countries"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      country_id: number
      country_name: string
      country_name_bn: string
      country_slug: string
      deletable: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["countries"]>
    composites: {}
  }


  type countriesGetPayload<S extends boolean | null | undefined | countriesDefaultArgs> = $Result.GetResult<Prisma.$countriesPayload, S>

  type countriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<countriesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CountriesCountAggregateInputType | true
    }

  export interface countriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['countries'], meta: { name: 'countries' } }
    /**
     * Find zero or one Countries that matches the filter.
     * @param {countriesFindUniqueArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends countriesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, countriesFindUniqueArgs<ExtArgs>>
    ): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Countries that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {countriesFindUniqueOrThrowArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends countriesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, countriesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesFindFirstArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends countriesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, countriesFindFirstArgs<ExtArgs>>
    ): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Countries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesFindFirstOrThrowArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends countriesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, countriesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.countries.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.countries.findMany({ take: 10 })
     * 
     * // Only select the `country_id`
     * const countriesWithCountry_idOnly = await prisma.countries.findMany({ select: { country_id: true } })
     * 
    **/
    findMany<T extends countriesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, countriesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Countries.
     * @param {countriesCreateArgs} args - Arguments to create a Countries.
     * @example
     * // Create one Countries
     * const Countries = await prisma.countries.create({
     *   data: {
     *     // ... data to create a Countries
     *   }
     * })
     * 
    **/
    create<T extends countriesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, countriesCreateArgs<ExtArgs>>
    ): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Countries.
     *     @param {countriesCreateManyArgs} args - Arguments to create many Countries.
     *     @example
     *     // Create many Countries
     *     const countries = await prisma.countries.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends countriesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, countriesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Countries.
     * @param {countriesDeleteArgs} args - Arguments to delete one Countries.
     * @example
     * // Delete one Countries
     * const Countries = await prisma.countries.delete({
     *   where: {
     *     // ... filter to delete one Countries
     *   }
     * })
     * 
    **/
    delete<T extends countriesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, countriesDeleteArgs<ExtArgs>>
    ): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Countries.
     * @param {countriesUpdateArgs} args - Arguments to update one Countries.
     * @example
     * // Update one Countries
     * const countries = await prisma.countries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends countriesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, countriesUpdateArgs<ExtArgs>>
    ): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Countries.
     * @param {countriesDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.countries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends countriesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, countriesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const countries = await prisma.countries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends countriesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, countriesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Countries.
     * @param {countriesUpsertArgs} args - Arguments to update or create a Countries.
     * @example
     * // Update or create a Countries
     * const countries = await prisma.countries.upsert({
     *   create: {
     *     // ... data to create a Countries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Countries we want to update
     *   }
     * })
    **/
    upsert<T extends countriesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, countriesUpsertArgs<ExtArgs>>
    ): Prisma__countriesClient<$Result.GetResult<Prisma.$countriesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.countries.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends countriesCountArgs>(
      args?: Subset<T, countriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountriesAggregateArgs>(args: Subset<T, CountriesAggregateArgs>): Prisma.PrismaPromise<GetCountriesAggregateType<T>>

    /**
     * Group by Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends countriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: countriesGroupByArgs['orderBy'] }
        : { orderBy?: countriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, countriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the countries model
   */
  readonly fields: countriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for countries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__countriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the countries model
   */ 
  interface countriesFieldRefs {
    readonly country_id: FieldRef<"countries", 'Int'>
    readonly country_name: FieldRef<"countries", 'String'>
    readonly country_name_bn: FieldRef<"countries", 'String'>
    readonly country_slug: FieldRef<"countries", 'String'>
    readonly deletable: FieldRef<"countries", 'Int'>
    readonly created_at: FieldRef<"countries", 'DateTime'>
    readonly updated_at: FieldRef<"countries", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * countries findUnique
   */
  export type countriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Filter, which countries to fetch.
     */
    where: countriesWhereUniqueInput
  }


  /**
   * countries findUniqueOrThrow
   */
  export type countriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Filter, which countries to fetch.
     */
    where: countriesWhereUniqueInput
  }


  /**
   * countries findFirst
   */
  export type countriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Filter, which countries to fetch.
     */
    where?: countriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countriesOrderByWithRelationInput | countriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for countries.
     */
    cursor?: countriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of countries.
     */
    distinct?: CountriesScalarFieldEnum | CountriesScalarFieldEnum[]
  }


  /**
   * countries findFirstOrThrow
   */
  export type countriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Filter, which countries to fetch.
     */
    where?: countriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countriesOrderByWithRelationInput | countriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for countries.
     */
    cursor?: countriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of countries.
     */
    distinct?: CountriesScalarFieldEnum | CountriesScalarFieldEnum[]
  }


  /**
   * countries findMany
   */
  export type countriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Filter, which countries to fetch.
     */
    where?: countriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countriesOrderByWithRelationInput | countriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing countries.
     */
    cursor?: countriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    distinct?: CountriesScalarFieldEnum | CountriesScalarFieldEnum[]
  }


  /**
   * countries create
   */
  export type countriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * The data needed to create a countries.
     */
    data: XOR<countriesCreateInput, countriesUncheckedCreateInput>
  }


  /**
   * countries createMany
   */
  export type countriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many countries.
     */
    data: countriesCreateManyInput | countriesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * countries update
   */
  export type countriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * The data needed to update a countries.
     */
    data: XOR<countriesUpdateInput, countriesUncheckedUpdateInput>
    /**
     * Choose, which countries to update.
     */
    where: countriesWhereUniqueInput
  }


  /**
   * countries updateMany
   */
  export type countriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update countries.
     */
    data: XOR<countriesUpdateManyMutationInput, countriesUncheckedUpdateManyInput>
    /**
     * Filter which countries to update
     */
    where?: countriesWhereInput
  }


  /**
   * countries upsert
   */
  export type countriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * The filter to search for the countries to update in case it exists.
     */
    where: countriesWhereUniqueInput
    /**
     * In case the countries found by the `where` argument doesn't exist, create a new countries with this data.
     */
    create: XOR<countriesCreateInput, countriesUncheckedCreateInput>
    /**
     * In case the countries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<countriesUpdateInput, countriesUncheckedUpdateInput>
  }


  /**
   * countries delete
   */
  export type countriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
    /**
     * Filter which countries to delete.
     */
    where: countriesWhereUniqueInput
  }


  /**
   * countries deleteMany
   */
  export type countriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which countries to delete
     */
    where?: countriesWhereInput
  }


  /**
   * countries without action
   */
  export type countriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the countries
     */
    select?: countriesSelect<ExtArgs> | null
  }



  /**
   * Model districts
   */

  export type AggregateDistricts = {
    _count: DistrictsCountAggregateOutputType | null
    _avg: DistrictsAvgAggregateOutputType | null
    _sum: DistrictsSumAggregateOutputType | null
    _min: DistrictsMinAggregateOutputType | null
    _max: DistrictsMaxAggregateOutputType | null
  }

  export type DistrictsAvgAggregateOutputType = {
    district_id: number | null
    division_id: number | null
    deletable: number | null
  }

  export type DistrictsSumAggregateOutputType = {
    district_id: number | null
    division_id: number | null
    deletable: number | null
  }

  export type DistrictsMinAggregateOutputType = {
    district_id: number | null
    division_id: number | null
    district_name: string | null
    district_name_bn: string | null
    district_slug: string | null
    district_title: string | null
    meta_description: string | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DistrictsMaxAggregateOutputType = {
    district_id: number | null
    division_id: number | null
    district_name: string | null
    district_name_bn: string | null
    district_slug: string | null
    district_title: string | null
    meta_description: string | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DistrictsCountAggregateOutputType = {
    district_id: number
    division_id: number
    district_name: number
    district_name_bn: number
    district_slug: number
    district_title: number
    meta_description: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DistrictsAvgAggregateInputType = {
    district_id?: true
    division_id?: true
    deletable?: true
  }

  export type DistrictsSumAggregateInputType = {
    district_id?: true
    division_id?: true
    deletable?: true
  }

  export type DistrictsMinAggregateInputType = {
    district_id?: true
    division_id?: true
    district_name?: true
    district_name_bn?: true
    district_slug?: true
    district_title?: true
    meta_description?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type DistrictsMaxAggregateInputType = {
    district_id?: true
    division_id?: true
    district_name?: true
    district_name_bn?: true
    district_slug?: true
    district_title?: true
    meta_description?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type DistrictsCountAggregateInputType = {
    district_id?: true
    division_id?: true
    district_name?: true
    district_name_bn?: true
    district_slug?: true
    district_title?: true
    meta_description?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DistrictsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which districts to aggregate.
     */
    where?: districtsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of districts to fetch.
     */
    orderBy?: districtsOrderByWithRelationInput | districtsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: districtsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned districts
    **/
    _count?: true | DistrictsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DistrictsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DistrictsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DistrictsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DistrictsMaxAggregateInputType
  }

  export type GetDistrictsAggregateType<T extends DistrictsAggregateArgs> = {
        [P in keyof T & keyof AggregateDistricts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDistricts[P]>
      : GetScalarType<T[P], AggregateDistricts[P]>
  }




  export type districtsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: districtsWhereInput
    orderBy?: districtsOrderByWithAggregationInput | districtsOrderByWithAggregationInput[]
    by: DistrictsScalarFieldEnum[] | DistrictsScalarFieldEnum
    having?: districtsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DistrictsCountAggregateInputType | true
    _avg?: DistrictsAvgAggregateInputType
    _sum?: DistrictsSumAggregateInputType
    _min?: DistrictsMinAggregateInputType
    _max?: DistrictsMaxAggregateInputType
  }

  export type DistrictsGroupByOutputType = {
    district_id: number
    division_id: number
    district_name: string
    district_name_bn: string
    district_slug: string
    district_title: string | null
    meta_description: string | null
    deletable: number
    created_at: Date | null
    updated_at: Date | null
    _count: DistrictsCountAggregateOutputType | null
    _avg: DistrictsAvgAggregateOutputType | null
    _sum: DistrictsSumAggregateOutputType | null
    _min: DistrictsMinAggregateOutputType | null
    _max: DistrictsMaxAggregateOutputType | null
  }

  type GetDistrictsGroupByPayload<T extends districtsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DistrictsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DistrictsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DistrictsGroupByOutputType[P]>
            : GetScalarType<T[P], DistrictsGroupByOutputType[P]>
        }
      >
    >


  export type districtsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    district_id?: boolean
    division_id?: boolean
    district_name?: boolean
    district_name_bn?: boolean
    district_slug?: boolean
    district_title?: boolean
    meta_description?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["districts"]>

  export type districtsSelectScalar = {
    district_id?: boolean
    division_id?: boolean
    district_name?: boolean
    district_name_bn?: boolean
    district_slug?: boolean
    district_title?: boolean
    meta_description?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $districtsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "districts"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      district_id: number
      division_id: number
      district_name: string
      district_name_bn: string
      district_slug: string
      district_title: string | null
      meta_description: string | null
      deletable: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["districts"]>
    composites: {}
  }


  type districtsGetPayload<S extends boolean | null | undefined | districtsDefaultArgs> = $Result.GetResult<Prisma.$districtsPayload, S>

  type districtsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<districtsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DistrictsCountAggregateInputType | true
    }

  export interface districtsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['districts'], meta: { name: 'districts' } }
    /**
     * Find zero or one Districts that matches the filter.
     * @param {districtsFindUniqueArgs} args - Arguments to find a Districts
     * @example
     * // Get one Districts
     * const districts = await prisma.districts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends districtsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, districtsFindUniqueArgs<ExtArgs>>
    ): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Districts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {districtsFindUniqueOrThrowArgs} args - Arguments to find a Districts
     * @example
     * // Get one Districts
     * const districts = await prisma.districts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends districtsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, districtsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Districts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtsFindFirstArgs} args - Arguments to find a Districts
     * @example
     * // Get one Districts
     * const districts = await prisma.districts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends districtsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, districtsFindFirstArgs<ExtArgs>>
    ): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Districts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtsFindFirstOrThrowArgs} args - Arguments to find a Districts
     * @example
     * // Get one Districts
     * const districts = await prisma.districts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends districtsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, districtsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Districts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Districts
     * const districts = await prisma.districts.findMany()
     * 
     * // Get first 10 Districts
     * const districts = await prisma.districts.findMany({ take: 10 })
     * 
     * // Only select the `district_id`
     * const districtsWithDistrict_idOnly = await prisma.districts.findMany({ select: { district_id: true } })
     * 
    **/
    findMany<T extends districtsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, districtsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Districts.
     * @param {districtsCreateArgs} args - Arguments to create a Districts.
     * @example
     * // Create one Districts
     * const Districts = await prisma.districts.create({
     *   data: {
     *     // ... data to create a Districts
     *   }
     * })
     * 
    **/
    create<T extends districtsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, districtsCreateArgs<ExtArgs>>
    ): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Districts.
     *     @param {districtsCreateManyArgs} args - Arguments to create many Districts.
     *     @example
     *     // Create many Districts
     *     const districts = await prisma.districts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends districtsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, districtsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Districts.
     * @param {districtsDeleteArgs} args - Arguments to delete one Districts.
     * @example
     * // Delete one Districts
     * const Districts = await prisma.districts.delete({
     *   where: {
     *     // ... filter to delete one Districts
     *   }
     * })
     * 
    **/
    delete<T extends districtsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, districtsDeleteArgs<ExtArgs>>
    ): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Districts.
     * @param {districtsUpdateArgs} args - Arguments to update one Districts.
     * @example
     * // Update one Districts
     * const districts = await prisma.districts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends districtsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, districtsUpdateArgs<ExtArgs>>
    ): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Districts.
     * @param {districtsDeleteManyArgs} args - Arguments to filter Districts to delete.
     * @example
     * // Delete a few Districts
     * const { count } = await prisma.districts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends districtsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, districtsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Districts
     * const districts = await prisma.districts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends districtsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, districtsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Districts.
     * @param {districtsUpsertArgs} args - Arguments to update or create a Districts.
     * @example
     * // Update or create a Districts
     * const districts = await prisma.districts.upsert({
     *   create: {
     *     // ... data to create a Districts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Districts we want to update
     *   }
     * })
    **/
    upsert<T extends districtsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, districtsUpsertArgs<ExtArgs>>
    ): Prisma__districtsClient<$Result.GetResult<Prisma.$districtsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtsCountArgs} args - Arguments to filter Districts to count.
     * @example
     * // Count the number of Districts
     * const count = await prisma.districts.count({
     *   where: {
     *     // ... the filter for the Districts we want to count
     *   }
     * })
    **/
    count<T extends districtsCountArgs>(
      args?: Subset<T, districtsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DistrictsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DistrictsAggregateArgs>(args: Subset<T, DistrictsAggregateArgs>): Prisma.PrismaPromise<GetDistrictsAggregateType<T>>

    /**
     * Group by Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {districtsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends districtsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: districtsGroupByArgs['orderBy'] }
        : { orderBy?: districtsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, districtsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDistrictsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the districts model
   */
  readonly fields: districtsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for districts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__districtsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the districts model
   */ 
  interface districtsFieldRefs {
    readonly district_id: FieldRef<"districts", 'Int'>
    readonly division_id: FieldRef<"districts", 'Int'>
    readonly district_name: FieldRef<"districts", 'String'>
    readonly district_name_bn: FieldRef<"districts", 'String'>
    readonly district_slug: FieldRef<"districts", 'String'>
    readonly district_title: FieldRef<"districts", 'String'>
    readonly meta_description: FieldRef<"districts", 'String'>
    readonly deletable: FieldRef<"districts", 'Int'>
    readonly created_at: FieldRef<"districts", 'DateTime'>
    readonly updated_at: FieldRef<"districts", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * districts findUnique
   */
  export type districtsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Filter, which districts to fetch.
     */
    where: districtsWhereUniqueInput
  }


  /**
   * districts findUniqueOrThrow
   */
  export type districtsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Filter, which districts to fetch.
     */
    where: districtsWhereUniqueInput
  }


  /**
   * districts findFirst
   */
  export type districtsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Filter, which districts to fetch.
     */
    where?: districtsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of districts to fetch.
     */
    orderBy?: districtsOrderByWithRelationInput | districtsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for districts.
     */
    cursor?: districtsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of districts.
     */
    distinct?: DistrictsScalarFieldEnum | DistrictsScalarFieldEnum[]
  }


  /**
   * districts findFirstOrThrow
   */
  export type districtsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Filter, which districts to fetch.
     */
    where?: districtsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of districts to fetch.
     */
    orderBy?: districtsOrderByWithRelationInput | districtsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for districts.
     */
    cursor?: districtsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of districts.
     */
    distinct?: DistrictsScalarFieldEnum | DistrictsScalarFieldEnum[]
  }


  /**
   * districts findMany
   */
  export type districtsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Filter, which districts to fetch.
     */
    where?: districtsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of districts to fetch.
     */
    orderBy?: districtsOrderByWithRelationInput | districtsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing districts.
     */
    cursor?: districtsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` districts.
     */
    skip?: number
    distinct?: DistrictsScalarFieldEnum | DistrictsScalarFieldEnum[]
  }


  /**
   * districts create
   */
  export type districtsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * The data needed to create a districts.
     */
    data: XOR<districtsCreateInput, districtsUncheckedCreateInput>
  }


  /**
   * districts createMany
   */
  export type districtsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many districts.
     */
    data: districtsCreateManyInput | districtsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * districts update
   */
  export type districtsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * The data needed to update a districts.
     */
    data: XOR<districtsUpdateInput, districtsUncheckedUpdateInput>
    /**
     * Choose, which districts to update.
     */
    where: districtsWhereUniqueInput
  }


  /**
   * districts updateMany
   */
  export type districtsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update districts.
     */
    data: XOR<districtsUpdateManyMutationInput, districtsUncheckedUpdateManyInput>
    /**
     * Filter which districts to update
     */
    where?: districtsWhereInput
  }


  /**
   * districts upsert
   */
  export type districtsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * The filter to search for the districts to update in case it exists.
     */
    where: districtsWhereUniqueInput
    /**
     * In case the districts found by the `where` argument doesn't exist, create a new districts with this data.
     */
    create: XOR<districtsCreateInput, districtsUncheckedCreateInput>
    /**
     * In case the districts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<districtsUpdateInput, districtsUncheckedUpdateInput>
  }


  /**
   * districts delete
   */
  export type districtsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
    /**
     * Filter which districts to delete.
     */
    where: districtsWhereUniqueInput
  }


  /**
   * districts deleteMany
   */
  export type districtsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which districts to delete
     */
    where?: districtsWhereInput
  }


  /**
   * districts without action
   */
  export type districtsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the districts
     */
    select?: districtsSelect<ExtArgs> | null
  }



  /**
   * Model divisions
   */

  export type AggregateDivisions = {
    _count: DivisionsCountAggregateOutputType | null
    _avg: DivisionsAvgAggregateOutputType | null
    _sum: DivisionsSumAggregateOutputType | null
    _min: DivisionsMinAggregateOutputType | null
    _max: DivisionsMaxAggregateOutputType | null
  }

  export type DivisionsAvgAggregateOutputType = {
    division_id: number | null
    deletable: number | null
  }

  export type DivisionsSumAggregateOutputType = {
    division_id: number | null
    deletable: number | null
  }

  export type DivisionsMinAggregateOutputType = {
    division_id: number | null
    division_name: string | null
    division_name_bn: string | null
    division_slug: string | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DivisionsMaxAggregateOutputType = {
    division_id: number | null
    division_name: string | null
    division_name_bn: string | null
    division_slug: string | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DivisionsCountAggregateOutputType = {
    division_id: number
    division_name: number
    division_name_bn: number
    division_slug: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DivisionsAvgAggregateInputType = {
    division_id?: true
    deletable?: true
  }

  export type DivisionsSumAggregateInputType = {
    division_id?: true
    deletable?: true
  }

  export type DivisionsMinAggregateInputType = {
    division_id?: true
    division_name?: true
    division_name_bn?: true
    division_slug?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type DivisionsMaxAggregateInputType = {
    division_id?: true
    division_name?: true
    division_name_bn?: true
    division_slug?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type DivisionsCountAggregateInputType = {
    division_id?: true
    division_name?: true
    division_name_bn?: true
    division_slug?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DivisionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which divisions to aggregate.
     */
    where?: divisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of divisions to fetch.
     */
    orderBy?: divisionsOrderByWithRelationInput | divisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: divisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` divisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned divisions
    **/
    _count?: true | DivisionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DivisionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DivisionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DivisionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DivisionsMaxAggregateInputType
  }

  export type GetDivisionsAggregateType<T extends DivisionsAggregateArgs> = {
        [P in keyof T & keyof AggregateDivisions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDivisions[P]>
      : GetScalarType<T[P], AggregateDivisions[P]>
  }




  export type divisionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: divisionsWhereInput
    orderBy?: divisionsOrderByWithAggregationInput | divisionsOrderByWithAggregationInput[]
    by: DivisionsScalarFieldEnum[] | DivisionsScalarFieldEnum
    having?: divisionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DivisionsCountAggregateInputType | true
    _avg?: DivisionsAvgAggregateInputType
    _sum?: DivisionsSumAggregateInputType
    _min?: DivisionsMinAggregateInputType
    _max?: DivisionsMaxAggregateInputType
  }

  export type DivisionsGroupByOutputType = {
    division_id: number
    division_name: string
    division_name_bn: string
    division_slug: string
    deletable: number
    created_at: Date | null
    updated_at: Date | null
    _count: DivisionsCountAggregateOutputType | null
    _avg: DivisionsAvgAggregateOutputType | null
    _sum: DivisionsSumAggregateOutputType | null
    _min: DivisionsMinAggregateOutputType | null
    _max: DivisionsMaxAggregateOutputType | null
  }

  type GetDivisionsGroupByPayload<T extends divisionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DivisionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DivisionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DivisionsGroupByOutputType[P]>
            : GetScalarType<T[P], DivisionsGroupByOutputType[P]>
        }
      >
    >


  export type divisionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    division_id?: boolean
    division_name?: boolean
    division_name_bn?: boolean
    division_slug?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["divisions"]>

  export type divisionsSelectScalar = {
    division_id?: boolean
    division_name?: boolean
    division_name_bn?: boolean
    division_slug?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $divisionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "divisions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      division_id: number
      division_name: string
      division_name_bn: string
      division_slug: string
      deletable: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["divisions"]>
    composites: {}
  }


  type divisionsGetPayload<S extends boolean | null | undefined | divisionsDefaultArgs> = $Result.GetResult<Prisma.$divisionsPayload, S>

  type divisionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<divisionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DivisionsCountAggregateInputType | true
    }

  export interface divisionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['divisions'], meta: { name: 'divisions' } }
    /**
     * Find zero or one Divisions that matches the filter.
     * @param {divisionsFindUniqueArgs} args - Arguments to find a Divisions
     * @example
     * // Get one Divisions
     * const divisions = await prisma.divisions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends divisionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, divisionsFindUniqueArgs<ExtArgs>>
    ): Prisma__divisionsClient<$Result.GetResult<Prisma.$divisionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Divisions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {divisionsFindUniqueOrThrowArgs} args - Arguments to find a Divisions
     * @example
     * // Get one Divisions
     * const divisions = await prisma.divisions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends divisionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, divisionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__divisionsClient<$Result.GetResult<Prisma.$divisionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Divisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {divisionsFindFirstArgs} args - Arguments to find a Divisions
     * @example
     * // Get one Divisions
     * const divisions = await prisma.divisions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends divisionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, divisionsFindFirstArgs<ExtArgs>>
    ): Prisma__divisionsClient<$Result.GetResult<Prisma.$divisionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Divisions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {divisionsFindFirstOrThrowArgs} args - Arguments to find a Divisions
     * @example
     * // Get one Divisions
     * const divisions = await prisma.divisions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends divisionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, divisionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__divisionsClient<$Result.GetResult<Prisma.$divisionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Divisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {divisionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Divisions
     * const divisions = await prisma.divisions.findMany()
     * 
     * // Get first 10 Divisions
     * const divisions = await prisma.divisions.findMany({ take: 10 })
     * 
     * // Only select the `division_id`
     * const divisionsWithDivision_idOnly = await prisma.divisions.findMany({ select: { division_id: true } })
     * 
    **/
    findMany<T extends divisionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, divisionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$divisionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Divisions.
     * @param {divisionsCreateArgs} args - Arguments to create a Divisions.
     * @example
     * // Create one Divisions
     * const Divisions = await prisma.divisions.create({
     *   data: {
     *     // ... data to create a Divisions
     *   }
     * })
     * 
    **/
    create<T extends divisionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, divisionsCreateArgs<ExtArgs>>
    ): Prisma__divisionsClient<$Result.GetResult<Prisma.$divisionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Divisions.
     *     @param {divisionsCreateManyArgs} args - Arguments to create many Divisions.
     *     @example
     *     // Create many Divisions
     *     const divisions = await prisma.divisions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends divisionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, divisionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Divisions.
     * @param {divisionsDeleteArgs} args - Arguments to delete one Divisions.
     * @example
     * // Delete one Divisions
     * const Divisions = await prisma.divisions.delete({
     *   where: {
     *     // ... filter to delete one Divisions
     *   }
     * })
     * 
    **/
    delete<T extends divisionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, divisionsDeleteArgs<ExtArgs>>
    ): Prisma__divisionsClient<$Result.GetResult<Prisma.$divisionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Divisions.
     * @param {divisionsUpdateArgs} args - Arguments to update one Divisions.
     * @example
     * // Update one Divisions
     * const divisions = await prisma.divisions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends divisionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, divisionsUpdateArgs<ExtArgs>>
    ): Prisma__divisionsClient<$Result.GetResult<Prisma.$divisionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Divisions.
     * @param {divisionsDeleteManyArgs} args - Arguments to filter Divisions to delete.
     * @example
     * // Delete a few Divisions
     * const { count } = await prisma.divisions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends divisionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, divisionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Divisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {divisionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Divisions
     * const divisions = await prisma.divisions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends divisionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, divisionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Divisions.
     * @param {divisionsUpsertArgs} args - Arguments to update or create a Divisions.
     * @example
     * // Update or create a Divisions
     * const divisions = await prisma.divisions.upsert({
     *   create: {
     *     // ... data to create a Divisions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Divisions we want to update
     *   }
     * })
    **/
    upsert<T extends divisionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, divisionsUpsertArgs<ExtArgs>>
    ): Prisma__divisionsClient<$Result.GetResult<Prisma.$divisionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Divisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {divisionsCountArgs} args - Arguments to filter Divisions to count.
     * @example
     * // Count the number of Divisions
     * const count = await prisma.divisions.count({
     *   where: {
     *     // ... the filter for the Divisions we want to count
     *   }
     * })
    **/
    count<T extends divisionsCountArgs>(
      args?: Subset<T, divisionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DivisionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Divisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DivisionsAggregateArgs>(args: Subset<T, DivisionsAggregateArgs>): Prisma.PrismaPromise<GetDivisionsAggregateType<T>>

    /**
     * Group by Divisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {divisionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends divisionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: divisionsGroupByArgs['orderBy'] }
        : { orderBy?: divisionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, divisionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDivisionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the divisions model
   */
  readonly fields: divisionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for divisions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__divisionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the divisions model
   */ 
  interface divisionsFieldRefs {
    readonly division_id: FieldRef<"divisions", 'Int'>
    readonly division_name: FieldRef<"divisions", 'String'>
    readonly division_name_bn: FieldRef<"divisions", 'String'>
    readonly division_slug: FieldRef<"divisions", 'String'>
    readonly deletable: FieldRef<"divisions", 'Int'>
    readonly created_at: FieldRef<"divisions", 'DateTime'>
    readonly updated_at: FieldRef<"divisions", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * divisions findUnique
   */
  export type divisionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the divisions
     */
    select?: divisionsSelect<ExtArgs> | null
    /**
     * Filter, which divisions to fetch.
     */
    where: divisionsWhereUniqueInput
  }


  /**
   * divisions findUniqueOrThrow
   */
  export type divisionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the divisions
     */
    select?: divisionsSelect<ExtArgs> | null
    /**
     * Filter, which divisions to fetch.
     */
    where: divisionsWhereUniqueInput
  }


  /**
   * divisions findFirst
   */
  export type divisionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the divisions
     */
    select?: divisionsSelect<ExtArgs> | null
    /**
     * Filter, which divisions to fetch.
     */
    where?: divisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of divisions to fetch.
     */
    orderBy?: divisionsOrderByWithRelationInput | divisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for divisions.
     */
    cursor?: divisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` divisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of divisions.
     */
    distinct?: DivisionsScalarFieldEnum | DivisionsScalarFieldEnum[]
  }


  /**
   * divisions findFirstOrThrow
   */
  export type divisionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the divisions
     */
    select?: divisionsSelect<ExtArgs> | null
    /**
     * Filter, which divisions to fetch.
     */
    where?: divisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of divisions to fetch.
     */
    orderBy?: divisionsOrderByWithRelationInput | divisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for divisions.
     */
    cursor?: divisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` divisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of divisions.
     */
    distinct?: DivisionsScalarFieldEnum | DivisionsScalarFieldEnum[]
  }


  /**
   * divisions findMany
   */
  export type divisionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the divisions
     */
    select?: divisionsSelect<ExtArgs> | null
    /**
     * Filter, which divisions to fetch.
     */
    where?: divisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of divisions to fetch.
     */
    orderBy?: divisionsOrderByWithRelationInput | divisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing divisions.
     */
    cursor?: divisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` divisions.
     */
    skip?: number
    distinct?: DivisionsScalarFieldEnum | DivisionsScalarFieldEnum[]
  }


  /**
   * divisions create
   */
  export type divisionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the divisions
     */
    select?: divisionsSelect<ExtArgs> | null
    /**
     * The data needed to create a divisions.
     */
    data: XOR<divisionsCreateInput, divisionsUncheckedCreateInput>
  }


  /**
   * divisions createMany
   */
  export type divisionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many divisions.
     */
    data: divisionsCreateManyInput | divisionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * divisions update
   */
  export type divisionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the divisions
     */
    select?: divisionsSelect<ExtArgs> | null
    /**
     * The data needed to update a divisions.
     */
    data: XOR<divisionsUpdateInput, divisionsUncheckedUpdateInput>
    /**
     * Choose, which divisions to update.
     */
    where: divisionsWhereUniqueInput
  }


  /**
   * divisions updateMany
   */
  export type divisionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update divisions.
     */
    data: XOR<divisionsUpdateManyMutationInput, divisionsUncheckedUpdateManyInput>
    /**
     * Filter which divisions to update
     */
    where?: divisionsWhereInput
  }


  /**
   * divisions upsert
   */
  export type divisionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the divisions
     */
    select?: divisionsSelect<ExtArgs> | null
    /**
     * The filter to search for the divisions to update in case it exists.
     */
    where: divisionsWhereUniqueInput
    /**
     * In case the divisions found by the `where` argument doesn't exist, create a new divisions with this data.
     */
    create: XOR<divisionsCreateInput, divisionsUncheckedCreateInput>
    /**
     * In case the divisions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<divisionsUpdateInput, divisionsUncheckedUpdateInput>
  }


  /**
   * divisions delete
   */
  export type divisionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the divisions
     */
    select?: divisionsSelect<ExtArgs> | null
    /**
     * Filter which divisions to delete.
     */
    where: divisionsWhereUniqueInput
  }


  /**
   * divisions deleteMany
   */
  export type divisionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which divisions to delete
     */
    where?: divisionsWhereInput
  }


  /**
   * divisions without action
   */
  export type divisionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the divisions
     */
    select?: divisionsSelect<ExtArgs> | null
  }



  /**
   * Model elections
   */

  export type AggregateElections = {
    _count: ElectionsCountAggregateOutputType | null
    _avg: ElectionsAvgAggregateOutputType | null
    _sum: ElectionsSumAggregateOutputType | null
    _min: ElectionsMinAggregateOutputType | null
    _max: ElectionsMaxAggregateOutputType | null
  }

  export type ElectionsAvgAggregateOutputType = {
    id: number | null
    total_center: number | null
    casted_center: number | null
    party_one_votes: number | null
    party_two_votes: number | null
    party_three_votes: number | null
    party_four_votes: number | null
    status: number | null
    deletable: number | null
  }

  export type ElectionsSumAggregateOutputType = {
    id: number | null
    total_center: number | null
    casted_center: number | null
    party_one_votes: number | null
    party_two_votes: number | null
    party_three_votes: number | null
    party_four_votes: number | null
    status: number | null
    deletable: number | null
  }

  export type ElectionsMinAggregateOutputType = {
    id: number | null
    title: string | null
    total_center: number | null
    casted_center: number | null
    party_one_name: string | null
    party_two_name: string | null
    party_three_name: string | null
    party_four_name: string | null
    party_one_logo: string | null
    party_two_logo: string | null
    party_three_logo: string | null
    party_four_logo: string | null
    party_one_votes: number | null
    party_two_votes: number | null
    party_three_votes: number | null
    party_four_votes: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ElectionsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    total_center: number | null
    casted_center: number | null
    party_one_name: string | null
    party_two_name: string | null
    party_three_name: string | null
    party_four_name: string | null
    party_one_logo: string | null
    party_two_logo: string | null
    party_three_logo: string | null
    party_four_logo: string | null
    party_one_votes: number | null
    party_two_votes: number | null
    party_three_votes: number | null
    party_four_votes: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ElectionsCountAggregateOutputType = {
    id: number
    title: number
    total_center: number
    casted_center: number
    party_one_name: number
    party_two_name: number
    party_three_name: number
    party_four_name: number
    party_one_logo: number
    party_two_logo: number
    party_three_logo: number
    party_four_logo: number
    party_one_votes: number
    party_two_votes: number
    party_three_votes: number
    party_four_votes: number
    status: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ElectionsAvgAggregateInputType = {
    id?: true
    total_center?: true
    casted_center?: true
    party_one_votes?: true
    party_two_votes?: true
    party_three_votes?: true
    party_four_votes?: true
    status?: true
    deletable?: true
  }

  export type ElectionsSumAggregateInputType = {
    id?: true
    total_center?: true
    casted_center?: true
    party_one_votes?: true
    party_two_votes?: true
    party_three_votes?: true
    party_four_votes?: true
    status?: true
    deletable?: true
  }

  export type ElectionsMinAggregateInputType = {
    id?: true
    title?: true
    total_center?: true
    casted_center?: true
    party_one_name?: true
    party_two_name?: true
    party_three_name?: true
    party_four_name?: true
    party_one_logo?: true
    party_two_logo?: true
    party_three_logo?: true
    party_four_logo?: true
    party_one_votes?: true
    party_two_votes?: true
    party_three_votes?: true
    party_four_votes?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type ElectionsMaxAggregateInputType = {
    id?: true
    title?: true
    total_center?: true
    casted_center?: true
    party_one_name?: true
    party_two_name?: true
    party_three_name?: true
    party_four_name?: true
    party_one_logo?: true
    party_two_logo?: true
    party_three_logo?: true
    party_four_logo?: true
    party_one_votes?: true
    party_two_votes?: true
    party_three_votes?: true
    party_four_votes?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type ElectionsCountAggregateInputType = {
    id?: true
    title?: true
    total_center?: true
    casted_center?: true
    party_one_name?: true
    party_two_name?: true
    party_three_name?: true
    party_four_name?: true
    party_one_logo?: true
    party_two_logo?: true
    party_three_logo?: true
    party_four_logo?: true
    party_one_votes?: true
    party_two_votes?: true
    party_three_votes?: true
    party_four_votes?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ElectionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which elections to aggregate.
     */
    where?: electionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of elections to fetch.
     */
    orderBy?: electionsOrderByWithRelationInput | electionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: electionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` elections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` elections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned elections
    **/
    _count?: true | ElectionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ElectionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ElectionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ElectionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ElectionsMaxAggregateInputType
  }

  export type GetElectionsAggregateType<T extends ElectionsAggregateArgs> = {
        [P in keyof T & keyof AggregateElections]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateElections[P]>
      : GetScalarType<T[P], AggregateElections[P]>
  }




  export type electionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: electionsWhereInput
    orderBy?: electionsOrderByWithAggregationInput | electionsOrderByWithAggregationInput[]
    by: ElectionsScalarFieldEnum[] | ElectionsScalarFieldEnum
    having?: electionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ElectionsCountAggregateInputType | true
    _avg?: ElectionsAvgAggregateInputType
    _sum?: ElectionsSumAggregateInputType
    _min?: ElectionsMinAggregateInputType
    _max?: ElectionsMaxAggregateInputType
  }

  export type ElectionsGroupByOutputType = {
    id: number
    title: string | null
    total_center: number | null
    casted_center: number | null
    party_one_name: string | null
    party_two_name: string | null
    party_three_name: string | null
    party_four_name: string | null
    party_one_logo: string | null
    party_two_logo: string | null
    party_three_logo: string | null
    party_four_logo: string | null
    party_one_votes: number | null
    party_two_votes: number | null
    party_three_votes: number | null
    party_four_votes: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
    _count: ElectionsCountAggregateOutputType | null
    _avg: ElectionsAvgAggregateOutputType | null
    _sum: ElectionsSumAggregateOutputType | null
    _min: ElectionsMinAggregateOutputType | null
    _max: ElectionsMaxAggregateOutputType | null
  }

  type GetElectionsGroupByPayload<T extends electionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ElectionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ElectionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ElectionsGroupByOutputType[P]>
            : GetScalarType<T[P], ElectionsGroupByOutputType[P]>
        }
      >
    >


  export type electionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    total_center?: boolean
    casted_center?: boolean
    party_one_name?: boolean
    party_two_name?: boolean
    party_three_name?: boolean
    party_four_name?: boolean
    party_one_logo?: boolean
    party_two_logo?: boolean
    party_three_logo?: boolean
    party_four_logo?: boolean
    party_one_votes?: boolean
    party_two_votes?: boolean
    party_three_votes?: boolean
    party_four_votes?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["elections"]>

  export type electionsSelectScalar = {
    id?: boolean
    title?: boolean
    total_center?: boolean
    casted_center?: boolean
    party_one_name?: boolean
    party_two_name?: boolean
    party_three_name?: boolean
    party_four_name?: boolean
    party_one_logo?: boolean
    party_two_logo?: boolean
    party_three_logo?: boolean
    party_four_logo?: boolean
    party_one_votes?: boolean
    party_two_votes?: boolean
    party_three_votes?: boolean
    party_four_votes?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $electionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "elections"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string | null
      total_center: number | null
      casted_center: number | null
      party_one_name: string | null
      party_two_name: string | null
      party_three_name: string | null
      party_four_name: string | null
      party_one_logo: string | null
      party_two_logo: string | null
      party_three_logo: string | null
      party_four_logo: string | null
      party_one_votes: number | null
      party_two_votes: number | null
      party_three_votes: number | null
      party_four_votes: number | null
      status: number | null
      deletable: number | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["elections"]>
    composites: {}
  }


  type electionsGetPayload<S extends boolean | null | undefined | electionsDefaultArgs> = $Result.GetResult<Prisma.$electionsPayload, S>

  type electionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<electionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ElectionsCountAggregateInputType | true
    }

  export interface electionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['elections'], meta: { name: 'elections' } }
    /**
     * Find zero or one Elections that matches the filter.
     * @param {electionsFindUniqueArgs} args - Arguments to find a Elections
     * @example
     * // Get one Elections
     * const elections = await prisma.elections.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends electionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, electionsFindUniqueArgs<ExtArgs>>
    ): Prisma__electionsClient<$Result.GetResult<Prisma.$electionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Elections that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {electionsFindUniqueOrThrowArgs} args - Arguments to find a Elections
     * @example
     * // Get one Elections
     * const elections = await prisma.elections.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends electionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, electionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__electionsClient<$Result.GetResult<Prisma.$electionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Elections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {electionsFindFirstArgs} args - Arguments to find a Elections
     * @example
     * // Get one Elections
     * const elections = await prisma.elections.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends electionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, electionsFindFirstArgs<ExtArgs>>
    ): Prisma__electionsClient<$Result.GetResult<Prisma.$electionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Elections that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {electionsFindFirstOrThrowArgs} args - Arguments to find a Elections
     * @example
     * // Get one Elections
     * const elections = await prisma.elections.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends electionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, electionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__electionsClient<$Result.GetResult<Prisma.$electionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Elections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {electionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Elections
     * const elections = await prisma.elections.findMany()
     * 
     * // Get first 10 Elections
     * const elections = await prisma.elections.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const electionsWithIdOnly = await prisma.elections.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends electionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, electionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$electionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Elections.
     * @param {electionsCreateArgs} args - Arguments to create a Elections.
     * @example
     * // Create one Elections
     * const Elections = await prisma.elections.create({
     *   data: {
     *     // ... data to create a Elections
     *   }
     * })
     * 
    **/
    create<T extends electionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, electionsCreateArgs<ExtArgs>>
    ): Prisma__electionsClient<$Result.GetResult<Prisma.$electionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Elections.
     *     @param {electionsCreateManyArgs} args - Arguments to create many Elections.
     *     @example
     *     // Create many Elections
     *     const elections = await prisma.elections.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends electionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, electionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Elections.
     * @param {electionsDeleteArgs} args - Arguments to delete one Elections.
     * @example
     * // Delete one Elections
     * const Elections = await prisma.elections.delete({
     *   where: {
     *     // ... filter to delete one Elections
     *   }
     * })
     * 
    **/
    delete<T extends electionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, electionsDeleteArgs<ExtArgs>>
    ): Prisma__electionsClient<$Result.GetResult<Prisma.$electionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Elections.
     * @param {electionsUpdateArgs} args - Arguments to update one Elections.
     * @example
     * // Update one Elections
     * const elections = await prisma.elections.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends electionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, electionsUpdateArgs<ExtArgs>>
    ): Prisma__electionsClient<$Result.GetResult<Prisma.$electionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Elections.
     * @param {electionsDeleteManyArgs} args - Arguments to filter Elections to delete.
     * @example
     * // Delete a few Elections
     * const { count } = await prisma.elections.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends electionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, electionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Elections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {electionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Elections
     * const elections = await prisma.elections.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends electionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, electionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Elections.
     * @param {electionsUpsertArgs} args - Arguments to update or create a Elections.
     * @example
     * // Update or create a Elections
     * const elections = await prisma.elections.upsert({
     *   create: {
     *     // ... data to create a Elections
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Elections we want to update
     *   }
     * })
    **/
    upsert<T extends electionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, electionsUpsertArgs<ExtArgs>>
    ): Prisma__electionsClient<$Result.GetResult<Prisma.$electionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Elections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {electionsCountArgs} args - Arguments to filter Elections to count.
     * @example
     * // Count the number of Elections
     * const count = await prisma.elections.count({
     *   where: {
     *     // ... the filter for the Elections we want to count
     *   }
     * })
    **/
    count<T extends electionsCountArgs>(
      args?: Subset<T, electionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ElectionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Elections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElectionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ElectionsAggregateArgs>(args: Subset<T, ElectionsAggregateArgs>): Prisma.PrismaPromise<GetElectionsAggregateType<T>>

    /**
     * Group by Elections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {electionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends electionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: electionsGroupByArgs['orderBy'] }
        : { orderBy?: electionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, electionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetElectionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the elections model
   */
  readonly fields: electionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for elections.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__electionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the elections model
   */ 
  interface electionsFieldRefs {
    readonly id: FieldRef<"elections", 'Int'>
    readonly title: FieldRef<"elections", 'String'>
    readonly total_center: FieldRef<"elections", 'Int'>
    readonly casted_center: FieldRef<"elections", 'Int'>
    readonly party_one_name: FieldRef<"elections", 'String'>
    readonly party_two_name: FieldRef<"elections", 'String'>
    readonly party_three_name: FieldRef<"elections", 'String'>
    readonly party_four_name: FieldRef<"elections", 'String'>
    readonly party_one_logo: FieldRef<"elections", 'String'>
    readonly party_two_logo: FieldRef<"elections", 'String'>
    readonly party_three_logo: FieldRef<"elections", 'String'>
    readonly party_four_logo: FieldRef<"elections", 'String'>
    readonly party_one_votes: FieldRef<"elections", 'Int'>
    readonly party_two_votes: FieldRef<"elections", 'Int'>
    readonly party_three_votes: FieldRef<"elections", 'Int'>
    readonly party_four_votes: FieldRef<"elections", 'Int'>
    readonly status: FieldRef<"elections", 'Int'>
    readonly deletable: FieldRef<"elections", 'Int'>
    readonly created_at: FieldRef<"elections", 'DateTime'>
    readonly updated_at: FieldRef<"elections", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * elections findUnique
   */
  export type electionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the elections
     */
    select?: electionsSelect<ExtArgs> | null
    /**
     * Filter, which elections to fetch.
     */
    where: electionsWhereUniqueInput
  }


  /**
   * elections findUniqueOrThrow
   */
  export type electionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the elections
     */
    select?: electionsSelect<ExtArgs> | null
    /**
     * Filter, which elections to fetch.
     */
    where: electionsWhereUniqueInput
  }


  /**
   * elections findFirst
   */
  export type electionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the elections
     */
    select?: electionsSelect<ExtArgs> | null
    /**
     * Filter, which elections to fetch.
     */
    where?: electionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of elections to fetch.
     */
    orderBy?: electionsOrderByWithRelationInput | electionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for elections.
     */
    cursor?: electionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` elections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` elections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of elections.
     */
    distinct?: ElectionsScalarFieldEnum | ElectionsScalarFieldEnum[]
  }


  /**
   * elections findFirstOrThrow
   */
  export type electionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the elections
     */
    select?: electionsSelect<ExtArgs> | null
    /**
     * Filter, which elections to fetch.
     */
    where?: electionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of elections to fetch.
     */
    orderBy?: electionsOrderByWithRelationInput | electionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for elections.
     */
    cursor?: electionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` elections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` elections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of elections.
     */
    distinct?: ElectionsScalarFieldEnum | ElectionsScalarFieldEnum[]
  }


  /**
   * elections findMany
   */
  export type electionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the elections
     */
    select?: electionsSelect<ExtArgs> | null
    /**
     * Filter, which elections to fetch.
     */
    where?: electionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of elections to fetch.
     */
    orderBy?: electionsOrderByWithRelationInput | electionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing elections.
     */
    cursor?: electionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` elections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` elections.
     */
    skip?: number
    distinct?: ElectionsScalarFieldEnum | ElectionsScalarFieldEnum[]
  }


  /**
   * elections create
   */
  export type electionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the elections
     */
    select?: electionsSelect<ExtArgs> | null
    /**
     * The data needed to create a elections.
     */
    data?: XOR<electionsCreateInput, electionsUncheckedCreateInput>
  }


  /**
   * elections createMany
   */
  export type electionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many elections.
     */
    data: electionsCreateManyInput | electionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * elections update
   */
  export type electionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the elections
     */
    select?: electionsSelect<ExtArgs> | null
    /**
     * The data needed to update a elections.
     */
    data: XOR<electionsUpdateInput, electionsUncheckedUpdateInput>
    /**
     * Choose, which elections to update.
     */
    where: electionsWhereUniqueInput
  }


  /**
   * elections updateMany
   */
  export type electionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update elections.
     */
    data: XOR<electionsUpdateManyMutationInput, electionsUncheckedUpdateManyInput>
    /**
     * Filter which elections to update
     */
    where?: electionsWhereInput
  }


  /**
   * elections upsert
   */
  export type electionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the elections
     */
    select?: electionsSelect<ExtArgs> | null
    /**
     * The filter to search for the elections to update in case it exists.
     */
    where: electionsWhereUniqueInput
    /**
     * In case the elections found by the `where` argument doesn't exist, create a new elections with this data.
     */
    create: XOR<electionsCreateInput, electionsUncheckedCreateInput>
    /**
     * In case the elections was found with the provided `where` argument, update it with this data.
     */
    update: XOR<electionsUpdateInput, electionsUncheckedUpdateInput>
  }


  /**
   * elections delete
   */
  export type electionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the elections
     */
    select?: electionsSelect<ExtArgs> | null
    /**
     * Filter which elections to delete.
     */
    where: electionsWhereUniqueInput
  }


  /**
   * elections deleteMany
   */
  export type electionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which elections to delete
     */
    where?: electionsWhereInput
  }


  /**
   * elections without action
   */
  export type electionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the elections
     */
    select?: electionsSelect<ExtArgs> | null
  }



  /**
   * Model epaper_pages
   */

  export type AggregateEpaper_pages = {
    _count: Epaper_pagesCountAggregateOutputType | null
    _avg: Epaper_pagesAvgAggregateOutputType | null
    _sum: Epaper_pagesSumAggregateOutputType | null
    _min: Epaper_pagesMinAggregateOutputType | null
    _max: Epaper_pagesMaxAggregateOutputType | null
  }

  export type Epaper_pagesAvgAggregateOutputType = {
    id: number | null
    epaper_id: number | null
    page_no: number | null
    user_id: number | null
    deletable: number | null
  }

  export type Epaper_pagesSumAggregateOutputType = {
    id: number | null
    epaper_id: number | null
    page_no: number | null
    user_id: number | null
    deletable: number | null
  }

  export type Epaper_pagesMinAggregateOutputType = {
    id: number | null
    epaper_id: number | null
    img_path: string | null
    img_thumb_path: string | null
    img_large_path: string | null
    page_no: number | null
    user_id: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Epaper_pagesMaxAggregateOutputType = {
    id: number | null
    epaper_id: number | null
    img_path: string | null
    img_thumb_path: string | null
    img_large_path: string | null
    page_no: number | null
    user_id: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Epaper_pagesCountAggregateOutputType = {
    id: number
    epaper_id: number
    img_path: number
    img_thumb_path: number
    img_large_path: number
    page_no: number
    user_id: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Epaper_pagesAvgAggregateInputType = {
    id?: true
    epaper_id?: true
    page_no?: true
    user_id?: true
    deletable?: true
  }

  export type Epaper_pagesSumAggregateInputType = {
    id?: true
    epaper_id?: true
    page_no?: true
    user_id?: true
    deletable?: true
  }

  export type Epaper_pagesMinAggregateInputType = {
    id?: true
    epaper_id?: true
    img_path?: true
    img_thumb_path?: true
    img_large_path?: true
    page_no?: true
    user_id?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Epaper_pagesMaxAggregateInputType = {
    id?: true
    epaper_id?: true
    img_path?: true
    img_thumb_path?: true
    img_large_path?: true
    page_no?: true
    user_id?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Epaper_pagesCountAggregateInputType = {
    id?: true
    epaper_id?: true
    img_path?: true
    img_thumb_path?: true
    img_large_path?: true
    page_no?: true
    user_id?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Epaper_pagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which epaper_pages to aggregate.
     */
    where?: epaper_pagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epaper_pages to fetch.
     */
    orderBy?: epaper_pagesOrderByWithRelationInput | epaper_pagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: epaper_pagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epaper_pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epaper_pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned epaper_pages
    **/
    _count?: true | Epaper_pagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Epaper_pagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Epaper_pagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Epaper_pagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Epaper_pagesMaxAggregateInputType
  }

  export type GetEpaper_pagesAggregateType<T extends Epaper_pagesAggregateArgs> = {
        [P in keyof T & keyof AggregateEpaper_pages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEpaper_pages[P]>
      : GetScalarType<T[P], AggregateEpaper_pages[P]>
  }




  export type epaper_pagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: epaper_pagesWhereInput
    orderBy?: epaper_pagesOrderByWithAggregationInput | epaper_pagesOrderByWithAggregationInput[]
    by: Epaper_pagesScalarFieldEnum[] | Epaper_pagesScalarFieldEnum
    having?: epaper_pagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Epaper_pagesCountAggregateInputType | true
    _avg?: Epaper_pagesAvgAggregateInputType
    _sum?: Epaper_pagesSumAggregateInputType
    _min?: Epaper_pagesMinAggregateInputType
    _max?: Epaper_pagesMaxAggregateInputType
  }

  export type Epaper_pagesGroupByOutputType = {
    id: number
    epaper_id: number
    img_path: string | null
    img_thumb_path: string | null
    img_large_path: string | null
    page_no: number
    user_id: number
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
    _count: Epaper_pagesCountAggregateOutputType | null
    _avg: Epaper_pagesAvgAggregateOutputType | null
    _sum: Epaper_pagesSumAggregateOutputType | null
    _min: Epaper_pagesMinAggregateOutputType | null
    _max: Epaper_pagesMaxAggregateOutputType | null
  }

  type GetEpaper_pagesGroupByPayload<T extends epaper_pagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Epaper_pagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Epaper_pagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Epaper_pagesGroupByOutputType[P]>
            : GetScalarType<T[P], Epaper_pagesGroupByOutputType[P]>
        }
      >
    >


  export type epaper_pagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    epaper_id?: boolean
    img_path?: boolean
    img_thumb_path?: boolean
    img_large_path?: boolean
    page_no?: boolean
    user_id?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["epaper_pages"]>

  export type epaper_pagesSelectScalar = {
    id?: boolean
    epaper_id?: boolean
    img_path?: boolean
    img_thumb_path?: boolean
    img_large_path?: boolean
    page_no?: boolean
    user_id?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $epaper_pagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "epaper_pages"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      epaper_id: number
      img_path: string | null
      img_thumb_path: string | null
      img_large_path: string | null
      page_no: number
      user_id: number
      deletable: number | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["epaper_pages"]>
    composites: {}
  }


  type epaper_pagesGetPayload<S extends boolean | null | undefined | epaper_pagesDefaultArgs> = $Result.GetResult<Prisma.$epaper_pagesPayload, S>

  type epaper_pagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<epaper_pagesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Epaper_pagesCountAggregateInputType | true
    }

  export interface epaper_pagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['epaper_pages'], meta: { name: 'epaper_pages' } }
    /**
     * Find zero or one Epaper_pages that matches the filter.
     * @param {epaper_pagesFindUniqueArgs} args - Arguments to find a Epaper_pages
     * @example
     * // Get one Epaper_pages
     * const epaper_pages = await prisma.epaper_pages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends epaper_pagesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, epaper_pagesFindUniqueArgs<ExtArgs>>
    ): Prisma__epaper_pagesClient<$Result.GetResult<Prisma.$epaper_pagesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Epaper_pages that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {epaper_pagesFindUniqueOrThrowArgs} args - Arguments to find a Epaper_pages
     * @example
     * // Get one Epaper_pages
     * const epaper_pages = await prisma.epaper_pages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends epaper_pagesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, epaper_pagesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__epaper_pagesClient<$Result.GetResult<Prisma.$epaper_pagesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Epaper_pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epaper_pagesFindFirstArgs} args - Arguments to find a Epaper_pages
     * @example
     * // Get one Epaper_pages
     * const epaper_pages = await prisma.epaper_pages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends epaper_pagesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, epaper_pagesFindFirstArgs<ExtArgs>>
    ): Prisma__epaper_pagesClient<$Result.GetResult<Prisma.$epaper_pagesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Epaper_pages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epaper_pagesFindFirstOrThrowArgs} args - Arguments to find a Epaper_pages
     * @example
     * // Get one Epaper_pages
     * const epaper_pages = await prisma.epaper_pages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends epaper_pagesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, epaper_pagesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__epaper_pagesClient<$Result.GetResult<Prisma.$epaper_pagesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Epaper_pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epaper_pagesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Epaper_pages
     * const epaper_pages = await prisma.epaper_pages.findMany()
     * 
     * // Get first 10 Epaper_pages
     * const epaper_pages = await prisma.epaper_pages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const epaper_pagesWithIdOnly = await prisma.epaper_pages.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends epaper_pagesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, epaper_pagesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$epaper_pagesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Epaper_pages.
     * @param {epaper_pagesCreateArgs} args - Arguments to create a Epaper_pages.
     * @example
     * // Create one Epaper_pages
     * const Epaper_pages = await prisma.epaper_pages.create({
     *   data: {
     *     // ... data to create a Epaper_pages
     *   }
     * })
     * 
    **/
    create<T extends epaper_pagesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, epaper_pagesCreateArgs<ExtArgs>>
    ): Prisma__epaper_pagesClient<$Result.GetResult<Prisma.$epaper_pagesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Epaper_pages.
     *     @param {epaper_pagesCreateManyArgs} args - Arguments to create many Epaper_pages.
     *     @example
     *     // Create many Epaper_pages
     *     const epaper_pages = await prisma.epaper_pages.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends epaper_pagesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, epaper_pagesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Epaper_pages.
     * @param {epaper_pagesDeleteArgs} args - Arguments to delete one Epaper_pages.
     * @example
     * // Delete one Epaper_pages
     * const Epaper_pages = await prisma.epaper_pages.delete({
     *   where: {
     *     // ... filter to delete one Epaper_pages
     *   }
     * })
     * 
    **/
    delete<T extends epaper_pagesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, epaper_pagesDeleteArgs<ExtArgs>>
    ): Prisma__epaper_pagesClient<$Result.GetResult<Prisma.$epaper_pagesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Epaper_pages.
     * @param {epaper_pagesUpdateArgs} args - Arguments to update one Epaper_pages.
     * @example
     * // Update one Epaper_pages
     * const epaper_pages = await prisma.epaper_pages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends epaper_pagesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, epaper_pagesUpdateArgs<ExtArgs>>
    ): Prisma__epaper_pagesClient<$Result.GetResult<Prisma.$epaper_pagesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Epaper_pages.
     * @param {epaper_pagesDeleteManyArgs} args - Arguments to filter Epaper_pages to delete.
     * @example
     * // Delete a few Epaper_pages
     * const { count } = await prisma.epaper_pages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends epaper_pagesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, epaper_pagesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Epaper_pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epaper_pagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Epaper_pages
     * const epaper_pages = await prisma.epaper_pages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends epaper_pagesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, epaper_pagesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Epaper_pages.
     * @param {epaper_pagesUpsertArgs} args - Arguments to update or create a Epaper_pages.
     * @example
     * // Update or create a Epaper_pages
     * const epaper_pages = await prisma.epaper_pages.upsert({
     *   create: {
     *     // ... data to create a Epaper_pages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Epaper_pages we want to update
     *   }
     * })
    **/
    upsert<T extends epaper_pagesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, epaper_pagesUpsertArgs<ExtArgs>>
    ): Prisma__epaper_pagesClient<$Result.GetResult<Prisma.$epaper_pagesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Epaper_pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epaper_pagesCountArgs} args - Arguments to filter Epaper_pages to count.
     * @example
     * // Count the number of Epaper_pages
     * const count = await prisma.epaper_pages.count({
     *   where: {
     *     // ... the filter for the Epaper_pages we want to count
     *   }
     * })
    **/
    count<T extends epaper_pagesCountArgs>(
      args?: Subset<T, epaper_pagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Epaper_pagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Epaper_pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Epaper_pagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Epaper_pagesAggregateArgs>(args: Subset<T, Epaper_pagesAggregateArgs>): Prisma.PrismaPromise<GetEpaper_pagesAggregateType<T>>

    /**
     * Group by Epaper_pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epaper_pagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends epaper_pagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: epaper_pagesGroupByArgs['orderBy'] }
        : { orderBy?: epaper_pagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, epaper_pagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEpaper_pagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the epaper_pages model
   */
  readonly fields: epaper_pagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for epaper_pages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__epaper_pagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the epaper_pages model
   */ 
  interface epaper_pagesFieldRefs {
    readonly id: FieldRef<"epaper_pages", 'Int'>
    readonly epaper_id: FieldRef<"epaper_pages", 'Int'>
    readonly img_path: FieldRef<"epaper_pages", 'String'>
    readonly img_thumb_path: FieldRef<"epaper_pages", 'String'>
    readonly img_large_path: FieldRef<"epaper_pages", 'String'>
    readonly page_no: FieldRef<"epaper_pages", 'Int'>
    readonly user_id: FieldRef<"epaper_pages", 'Int'>
    readonly deletable: FieldRef<"epaper_pages", 'Int'>
    readonly created_at: FieldRef<"epaper_pages", 'DateTime'>
    readonly updated_at: FieldRef<"epaper_pages", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * epaper_pages findUnique
   */
  export type epaper_pagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epaper_pages
     */
    select?: epaper_pagesSelect<ExtArgs> | null
    /**
     * Filter, which epaper_pages to fetch.
     */
    where: epaper_pagesWhereUniqueInput
  }


  /**
   * epaper_pages findUniqueOrThrow
   */
  export type epaper_pagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epaper_pages
     */
    select?: epaper_pagesSelect<ExtArgs> | null
    /**
     * Filter, which epaper_pages to fetch.
     */
    where: epaper_pagesWhereUniqueInput
  }


  /**
   * epaper_pages findFirst
   */
  export type epaper_pagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epaper_pages
     */
    select?: epaper_pagesSelect<ExtArgs> | null
    /**
     * Filter, which epaper_pages to fetch.
     */
    where?: epaper_pagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epaper_pages to fetch.
     */
    orderBy?: epaper_pagesOrderByWithRelationInput | epaper_pagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for epaper_pages.
     */
    cursor?: epaper_pagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epaper_pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epaper_pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of epaper_pages.
     */
    distinct?: Epaper_pagesScalarFieldEnum | Epaper_pagesScalarFieldEnum[]
  }


  /**
   * epaper_pages findFirstOrThrow
   */
  export type epaper_pagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epaper_pages
     */
    select?: epaper_pagesSelect<ExtArgs> | null
    /**
     * Filter, which epaper_pages to fetch.
     */
    where?: epaper_pagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epaper_pages to fetch.
     */
    orderBy?: epaper_pagesOrderByWithRelationInput | epaper_pagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for epaper_pages.
     */
    cursor?: epaper_pagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epaper_pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epaper_pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of epaper_pages.
     */
    distinct?: Epaper_pagesScalarFieldEnum | Epaper_pagesScalarFieldEnum[]
  }


  /**
   * epaper_pages findMany
   */
  export type epaper_pagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epaper_pages
     */
    select?: epaper_pagesSelect<ExtArgs> | null
    /**
     * Filter, which epaper_pages to fetch.
     */
    where?: epaper_pagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epaper_pages to fetch.
     */
    orderBy?: epaper_pagesOrderByWithRelationInput | epaper_pagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing epaper_pages.
     */
    cursor?: epaper_pagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epaper_pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epaper_pages.
     */
    skip?: number
    distinct?: Epaper_pagesScalarFieldEnum | Epaper_pagesScalarFieldEnum[]
  }


  /**
   * epaper_pages create
   */
  export type epaper_pagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epaper_pages
     */
    select?: epaper_pagesSelect<ExtArgs> | null
    /**
     * The data needed to create a epaper_pages.
     */
    data: XOR<epaper_pagesCreateInput, epaper_pagesUncheckedCreateInput>
  }


  /**
   * epaper_pages createMany
   */
  export type epaper_pagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many epaper_pages.
     */
    data: epaper_pagesCreateManyInput | epaper_pagesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * epaper_pages update
   */
  export type epaper_pagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epaper_pages
     */
    select?: epaper_pagesSelect<ExtArgs> | null
    /**
     * The data needed to update a epaper_pages.
     */
    data: XOR<epaper_pagesUpdateInput, epaper_pagesUncheckedUpdateInput>
    /**
     * Choose, which epaper_pages to update.
     */
    where: epaper_pagesWhereUniqueInput
  }


  /**
   * epaper_pages updateMany
   */
  export type epaper_pagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update epaper_pages.
     */
    data: XOR<epaper_pagesUpdateManyMutationInput, epaper_pagesUncheckedUpdateManyInput>
    /**
     * Filter which epaper_pages to update
     */
    where?: epaper_pagesWhereInput
  }


  /**
   * epaper_pages upsert
   */
  export type epaper_pagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epaper_pages
     */
    select?: epaper_pagesSelect<ExtArgs> | null
    /**
     * The filter to search for the epaper_pages to update in case it exists.
     */
    where: epaper_pagesWhereUniqueInput
    /**
     * In case the epaper_pages found by the `where` argument doesn't exist, create a new epaper_pages with this data.
     */
    create: XOR<epaper_pagesCreateInput, epaper_pagesUncheckedCreateInput>
    /**
     * In case the epaper_pages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<epaper_pagesUpdateInput, epaper_pagesUncheckedUpdateInput>
  }


  /**
   * epaper_pages delete
   */
  export type epaper_pagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epaper_pages
     */
    select?: epaper_pagesSelect<ExtArgs> | null
    /**
     * Filter which epaper_pages to delete.
     */
    where: epaper_pagesWhereUniqueInput
  }


  /**
   * epaper_pages deleteMany
   */
  export type epaper_pagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which epaper_pages to delete
     */
    where?: epaper_pagesWhereInput
  }


  /**
   * epaper_pages without action
   */
  export type epaper_pagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epaper_pages
     */
    select?: epaper_pagesSelect<ExtArgs> | null
  }



  /**
   * Model epapers
   */

  export type AggregateEpapers = {
    _count: EpapersCountAggregateOutputType | null
    _avg: EpapersAvgAggregateOutputType | null
    _sum: EpapersSumAggregateOutputType | null
    _min: EpapersMinAggregateOutputType | null
    _max: EpapersMaxAggregateOutputType | null
  }

  export type EpapersAvgAggregateOutputType = {
    id: number | null
    total_page: number | null
    user_id: number | null
    status: number | null
    deletable: number | null
  }

  export type EpapersSumAggregateOutputType = {
    id: number | null
    total_page: number | null
    user_id: number | null
    status: number | null
    deletable: number | null
  }

  export type EpapersMinAggregateOutputType = {
    id: number | null
    paper_date: Date | null
    total_page: number | null
    meta_keywords: string | null
    meta_description: string | null
    og_img_path: string | null
    user_id: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type EpapersMaxAggregateOutputType = {
    id: number | null
    paper_date: Date | null
    total_page: number | null
    meta_keywords: string | null
    meta_description: string | null
    og_img_path: string | null
    user_id: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type EpapersCountAggregateOutputType = {
    id: number
    paper_date: number
    total_page: number
    meta_keywords: number
    meta_description: number
    og_img_path: number
    user_id: number
    status: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type EpapersAvgAggregateInputType = {
    id?: true
    total_page?: true
    user_id?: true
    status?: true
    deletable?: true
  }

  export type EpapersSumAggregateInputType = {
    id?: true
    total_page?: true
    user_id?: true
    status?: true
    deletable?: true
  }

  export type EpapersMinAggregateInputType = {
    id?: true
    paper_date?: true
    total_page?: true
    meta_keywords?: true
    meta_description?: true
    og_img_path?: true
    user_id?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type EpapersMaxAggregateInputType = {
    id?: true
    paper_date?: true
    total_page?: true
    meta_keywords?: true
    meta_description?: true
    og_img_path?: true
    user_id?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type EpapersCountAggregateInputType = {
    id?: true
    paper_date?: true
    total_page?: true
    meta_keywords?: true
    meta_description?: true
    og_img_path?: true
    user_id?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type EpapersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which epapers to aggregate.
     */
    where?: epapersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epapers to fetch.
     */
    orderBy?: epapersOrderByWithRelationInput | epapersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: epapersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epapers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epapers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned epapers
    **/
    _count?: true | EpapersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EpapersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EpapersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EpapersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EpapersMaxAggregateInputType
  }

  export type GetEpapersAggregateType<T extends EpapersAggregateArgs> = {
        [P in keyof T & keyof AggregateEpapers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEpapers[P]>
      : GetScalarType<T[P], AggregateEpapers[P]>
  }




  export type epapersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: epapersWhereInput
    orderBy?: epapersOrderByWithAggregationInput | epapersOrderByWithAggregationInput[]
    by: EpapersScalarFieldEnum[] | EpapersScalarFieldEnum
    having?: epapersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EpapersCountAggregateInputType | true
    _avg?: EpapersAvgAggregateInputType
    _sum?: EpapersSumAggregateInputType
    _min?: EpapersMinAggregateInputType
    _max?: EpapersMaxAggregateInputType
  }

  export type EpapersGroupByOutputType = {
    id: number
    paper_date: Date | null
    total_page: number | null
    meta_keywords: string | null
    meta_description: string | null
    og_img_path: string | null
    user_id: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
    _count: EpapersCountAggregateOutputType | null
    _avg: EpapersAvgAggregateOutputType | null
    _sum: EpapersSumAggregateOutputType | null
    _min: EpapersMinAggregateOutputType | null
    _max: EpapersMaxAggregateOutputType | null
  }

  type GetEpapersGroupByPayload<T extends epapersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EpapersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EpapersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EpapersGroupByOutputType[P]>
            : GetScalarType<T[P], EpapersGroupByOutputType[P]>
        }
      >
    >


  export type epapersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paper_date?: boolean
    total_page?: boolean
    meta_keywords?: boolean
    meta_description?: boolean
    og_img_path?: boolean
    user_id?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["epapers"]>

  export type epapersSelectScalar = {
    id?: boolean
    paper_date?: boolean
    total_page?: boolean
    meta_keywords?: boolean
    meta_description?: boolean
    og_img_path?: boolean
    user_id?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $epapersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "epapers"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      paper_date: Date | null
      total_page: number | null
      meta_keywords: string | null
      meta_description: string | null
      og_img_path: string | null
      user_id: number | null
      status: number | null
      deletable: number | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["epapers"]>
    composites: {}
  }


  type epapersGetPayload<S extends boolean | null | undefined | epapersDefaultArgs> = $Result.GetResult<Prisma.$epapersPayload, S>

  type epapersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<epapersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EpapersCountAggregateInputType | true
    }

  export interface epapersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['epapers'], meta: { name: 'epapers' } }
    /**
     * Find zero or one Epapers that matches the filter.
     * @param {epapersFindUniqueArgs} args - Arguments to find a Epapers
     * @example
     * // Get one Epapers
     * const epapers = await prisma.epapers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends epapersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, epapersFindUniqueArgs<ExtArgs>>
    ): Prisma__epapersClient<$Result.GetResult<Prisma.$epapersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Epapers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {epapersFindUniqueOrThrowArgs} args - Arguments to find a Epapers
     * @example
     * // Get one Epapers
     * const epapers = await prisma.epapers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends epapersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, epapersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__epapersClient<$Result.GetResult<Prisma.$epapersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Epapers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epapersFindFirstArgs} args - Arguments to find a Epapers
     * @example
     * // Get one Epapers
     * const epapers = await prisma.epapers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends epapersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, epapersFindFirstArgs<ExtArgs>>
    ): Prisma__epapersClient<$Result.GetResult<Prisma.$epapersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Epapers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epapersFindFirstOrThrowArgs} args - Arguments to find a Epapers
     * @example
     * // Get one Epapers
     * const epapers = await prisma.epapers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends epapersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, epapersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__epapersClient<$Result.GetResult<Prisma.$epapersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Epapers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epapersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Epapers
     * const epapers = await prisma.epapers.findMany()
     * 
     * // Get first 10 Epapers
     * const epapers = await prisma.epapers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const epapersWithIdOnly = await prisma.epapers.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends epapersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, epapersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$epapersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Epapers.
     * @param {epapersCreateArgs} args - Arguments to create a Epapers.
     * @example
     * // Create one Epapers
     * const Epapers = await prisma.epapers.create({
     *   data: {
     *     // ... data to create a Epapers
     *   }
     * })
     * 
    **/
    create<T extends epapersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, epapersCreateArgs<ExtArgs>>
    ): Prisma__epapersClient<$Result.GetResult<Prisma.$epapersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Epapers.
     *     @param {epapersCreateManyArgs} args - Arguments to create many Epapers.
     *     @example
     *     // Create many Epapers
     *     const epapers = await prisma.epapers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends epapersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, epapersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Epapers.
     * @param {epapersDeleteArgs} args - Arguments to delete one Epapers.
     * @example
     * // Delete one Epapers
     * const Epapers = await prisma.epapers.delete({
     *   where: {
     *     // ... filter to delete one Epapers
     *   }
     * })
     * 
    **/
    delete<T extends epapersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, epapersDeleteArgs<ExtArgs>>
    ): Prisma__epapersClient<$Result.GetResult<Prisma.$epapersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Epapers.
     * @param {epapersUpdateArgs} args - Arguments to update one Epapers.
     * @example
     * // Update one Epapers
     * const epapers = await prisma.epapers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends epapersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, epapersUpdateArgs<ExtArgs>>
    ): Prisma__epapersClient<$Result.GetResult<Prisma.$epapersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Epapers.
     * @param {epapersDeleteManyArgs} args - Arguments to filter Epapers to delete.
     * @example
     * // Delete a few Epapers
     * const { count } = await prisma.epapers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends epapersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, epapersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Epapers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epapersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Epapers
     * const epapers = await prisma.epapers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends epapersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, epapersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Epapers.
     * @param {epapersUpsertArgs} args - Arguments to update or create a Epapers.
     * @example
     * // Update or create a Epapers
     * const epapers = await prisma.epapers.upsert({
     *   create: {
     *     // ... data to create a Epapers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Epapers we want to update
     *   }
     * })
    **/
    upsert<T extends epapersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, epapersUpsertArgs<ExtArgs>>
    ): Prisma__epapersClient<$Result.GetResult<Prisma.$epapersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Epapers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epapersCountArgs} args - Arguments to filter Epapers to count.
     * @example
     * // Count the number of Epapers
     * const count = await prisma.epapers.count({
     *   where: {
     *     // ... the filter for the Epapers we want to count
     *   }
     * })
    **/
    count<T extends epapersCountArgs>(
      args?: Subset<T, epapersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EpapersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Epapers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpapersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EpapersAggregateArgs>(args: Subset<T, EpapersAggregateArgs>): Prisma.PrismaPromise<GetEpapersAggregateType<T>>

    /**
     * Group by Epapers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epapersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends epapersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: epapersGroupByArgs['orderBy'] }
        : { orderBy?: epapersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, epapersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEpapersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the epapers model
   */
  readonly fields: epapersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for epapers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__epapersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the epapers model
   */ 
  interface epapersFieldRefs {
    readonly id: FieldRef<"epapers", 'Int'>
    readonly paper_date: FieldRef<"epapers", 'DateTime'>
    readonly total_page: FieldRef<"epapers", 'Int'>
    readonly meta_keywords: FieldRef<"epapers", 'String'>
    readonly meta_description: FieldRef<"epapers", 'String'>
    readonly og_img_path: FieldRef<"epapers", 'String'>
    readonly user_id: FieldRef<"epapers", 'Int'>
    readonly status: FieldRef<"epapers", 'Int'>
    readonly deletable: FieldRef<"epapers", 'Int'>
    readonly created_at: FieldRef<"epapers", 'DateTime'>
    readonly updated_at: FieldRef<"epapers", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * epapers findUnique
   */
  export type epapersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epapers
     */
    select?: epapersSelect<ExtArgs> | null
    /**
     * Filter, which epapers to fetch.
     */
    where: epapersWhereUniqueInput
  }


  /**
   * epapers findUniqueOrThrow
   */
  export type epapersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epapers
     */
    select?: epapersSelect<ExtArgs> | null
    /**
     * Filter, which epapers to fetch.
     */
    where: epapersWhereUniqueInput
  }


  /**
   * epapers findFirst
   */
  export type epapersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epapers
     */
    select?: epapersSelect<ExtArgs> | null
    /**
     * Filter, which epapers to fetch.
     */
    where?: epapersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epapers to fetch.
     */
    orderBy?: epapersOrderByWithRelationInput | epapersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for epapers.
     */
    cursor?: epapersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epapers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epapers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of epapers.
     */
    distinct?: EpapersScalarFieldEnum | EpapersScalarFieldEnum[]
  }


  /**
   * epapers findFirstOrThrow
   */
  export type epapersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epapers
     */
    select?: epapersSelect<ExtArgs> | null
    /**
     * Filter, which epapers to fetch.
     */
    where?: epapersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epapers to fetch.
     */
    orderBy?: epapersOrderByWithRelationInput | epapersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for epapers.
     */
    cursor?: epapersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epapers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epapers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of epapers.
     */
    distinct?: EpapersScalarFieldEnum | EpapersScalarFieldEnum[]
  }


  /**
   * epapers findMany
   */
  export type epapersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epapers
     */
    select?: epapersSelect<ExtArgs> | null
    /**
     * Filter, which epapers to fetch.
     */
    where?: epapersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epapers to fetch.
     */
    orderBy?: epapersOrderByWithRelationInput | epapersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing epapers.
     */
    cursor?: epapersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epapers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epapers.
     */
    skip?: number
    distinct?: EpapersScalarFieldEnum | EpapersScalarFieldEnum[]
  }


  /**
   * epapers create
   */
  export type epapersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epapers
     */
    select?: epapersSelect<ExtArgs> | null
    /**
     * The data needed to create a epapers.
     */
    data?: XOR<epapersCreateInput, epapersUncheckedCreateInput>
  }


  /**
   * epapers createMany
   */
  export type epapersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many epapers.
     */
    data: epapersCreateManyInput | epapersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * epapers update
   */
  export type epapersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epapers
     */
    select?: epapersSelect<ExtArgs> | null
    /**
     * The data needed to update a epapers.
     */
    data: XOR<epapersUpdateInput, epapersUncheckedUpdateInput>
    /**
     * Choose, which epapers to update.
     */
    where: epapersWhereUniqueInput
  }


  /**
   * epapers updateMany
   */
  export type epapersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update epapers.
     */
    data: XOR<epapersUpdateManyMutationInput, epapersUncheckedUpdateManyInput>
    /**
     * Filter which epapers to update
     */
    where?: epapersWhereInput
  }


  /**
   * epapers upsert
   */
  export type epapersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epapers
     */
    select?: epapersSelect<ExtArgs> | null
    /**
     * The filter to search for the epapers to update in case it exists.
     */
    where: epapersWhereUniqueInput
    /**
     * In case the epapers found by the `where` argument doesn't exist, create a new epapers with this data.
     */
    create: XOR<epapersCreateInput, epapersUncheckedCreateInput>
    /**
     * In case the epapers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<epapersUpdateInput, epapersUncheckedUpdateInput>
  }


  /**
   * epapers delete
   */
  export type epapersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epapers
     */
    select?: epapersSelect<ExtArgs> | null
    /**
     * Filter which epapers to delete.
     */
    where: epapersWhereUniqueInput
  }


  /**
   * epapers deleteMany
   */
  export type epapersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which epapers to delete
     */
    where?: epapersWhereInput
  }


  /**
   * epapers without action
   */
  export type epapersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epapers
     */
    select?: epapersSelect<ExtArgs> | null
  }



  /**
   * Model magazine_pages
   */

  export type AggregateMagazine_pages = {
    _count: Magazine_pagesCountAggregateOutputType | null
    _avg: Magazine_pagesAvgAggregateOutputType | null
    _sum: Magazine_pagesSumAggregateOutputType | null
    _min: Magazine_pagesMinAggregateOutputType | null
    _max: Magazine_pagesMaxAggregateOutputType | null
  }

  export type Magazine_pagesAvgAggregateOutputType = {
    id: number | null
    magazine_id: number | null
    counter: number | null
    user_id: number | null
    deletable: number | null
  }

  export type Magazine_pagesSumAggregateOutputType = {
    id: number | null
    magazine_id: number | null
    counter: number | null
    user_id: number | null
    deletable: number | null
  }

  export type Magazine_pagesMinAggregateOutputType = {
    id: number | null
    magazine_id: number | null
    img_path: string | null
    img_thumb_path: string | null
    img_large_path: string | null
    counter: number | null
    user_id: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Magazine_pagesMaxAggregateOutputType = {
    id: number | null
    magazine_id: number | null
    img_path: string | null
    img_thumb_path: string | null
    img_large_path: string | null
    counter: number | null
    user_id: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Magazine_pagesCountAggregateOutputType = {
    id: number
    magazine_id: number
    img_path: number
    img_thumb_path: number
    img_large_path: number
    counter: number
    user_id: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Magazine_pagesAvgAggregateInputType = {
    id?: true
    magazine_id?: true
    counter?: true
    user_id?: true
    deletable?: true
  }

  export type Magazine_pagesSumAggregateInputType = {
    id?: true
    magazine_id?: true
    counter?: true
    user_id?: true
    deletable?: true
  }

  export type Magazine_pagesMinAggregateInputType = {
    id?: true
    magazine_id?: true
    img_path?: true
    img_thumb_path?: true
    img_large_path?: true
    counter?: true
    user_id?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Magazine_pagesMaxAggregateInputType = {
    id?: true
    magazine_id?: true
    img_path?: true
    img_thumb_path?: true
    img_large_path?: true
    counter?: true
    user_id?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Magazine_pagesCountAggregateInputType = {
    id?: true
    magazine_id?: true
    img_path?: true
    img_thumb_path?: true
    img_large_path?: true
    counter?: true
    user_id?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Magazine_pagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which magazine_pages to aggregate.
     */
    where?: magazine_pagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of magazine_pages to fetch.
     */
    orderBy?: magazine_pagesOrderByWithRelationInput | magazine_pagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: magazine_pagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` magazine_pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` magazine_pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned magazine_pages
    **/
    _count?: true | Magazine_pagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Magazine_pagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Magazine_pagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Magazine_pagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Magazine_pagesMaxAggregateInputType
  }

  export type GetMagazine_pagesAggregateType<T extends Magazine_pagesAggregateArgs> = {
        [P in keyof T & keyof AggregateMagazine_pages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMagazine_pages[P]>
      : GetScalarType<T[P], AggregateMagazine_pages[P]>
  }




  export type magazine_pagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: magazine_pagesWhereInput
    orderBy?: magazine_pagesOrderByWithAggregationInput | magazine_pagesOrderByWithAggregationInput[]
    by: Magazine_pagesScalarFieldEnum[] | Magazine_pagesScalarFieldEnum
    having?: magazine_pagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Magazine_pagesCountAggregateInputType | true
    _avg?: Magazine_pagesAvgAggregateInputType
    _sum?: Magazine_pagesSumAggregateInputType
    _min?: Magazine_pagesMinAggregateInputType
    _max?: Magazine_pagesMaxAggregateInputType
  }

  export type Magazine_pagesGroupByOutputType = {
    id: number
    magazine_id: number
    img_path: string | null
    img_thumb_path: string | null
    img_large_path: string | null
    counter: number
    user_id: number
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
    _count: Magazine_pagesCountAggregateOutputType | null
    _avg: Magazine_pagesAvgAggregateOutputType | null
    _sum: Magazine_pagesSumAggregateOutputType | null
    _min: Magazine_pagesMinAggregateOutputType | null
    _max: Magazine_pagesMaxAggregateOutputType | null
  }

  type GetMagazine_pagesGroupByPayload<T extends magazine_pagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Magazine_pagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Magazine_pagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Magazine_pagesGroupByOutputType[P]>
            : GetScalarType<T[P], Magazine_pagesGroupByOutputType[P]>
        }
      >
    >


  export type magazine_pagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    magazine_id?: boolean
    img_path?: boolean
    img_thumb_path?: boolean
    img_large_path?: boolean
    counter?: boolean
    user_id?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["magazine_pages"]>

  export type magazine_pagesSelectScalar = {
    id?: boolean
    magazine_id?: boolean
    img_path?: boolean
    img_thumb_path?: boolean
    img_large_path?: boolean
    counter?: boolean
    user_id?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $magazine_pagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "magazine_pages"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      magazine_id: number
      img_path: string | null
      img_thumb_path: string | null
      img_large_path: string | null
      counter: number
      user_id: number
      deletable: number | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["magazine_pages"]>
    composites: {}
  }


  type magazine_pagesGetPayload<S extends boolean | null | undefined | magazine_pagesDefaultArgs> = $Result.GetResult<Prisma.$magazine_pagesPayload, S>

  type magazine_pagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<magazine_pagesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Magazine_pagesCountAggregateInputType | true
    }

  export interface magazine_pagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['magazine_pages'], meta: { name: 'magazine_pages' } }
    /**
     * Find zero or one Magazine_pages that matches the filter.
     * @param {magazine_pagesFindUniqueArgs} args - Arguments to find a Magazine_pages
     * @example
     * // Get one Magazine_pages
     * const magazine_pages = await prisma.magazine_pages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends magazine_pagesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, magazine_pagesFindUniqueArgs<ExtArgs>>
    ): Prisma__magazine_pagesClient<$Result.GetResult<Prisma.$magazine_pagesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Magazine_pages that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {magazine_pagesFindUniqueOrThrowArgs} args - Arguments to find a Magazine_pages
     * @example
     * // Get one Magazine_pages
     * const magazine_pages = await prisma.magazine_pages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends magazine_pagesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, magazine_pagesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__magazine_pagesClient<$Result.GetResult<Prisma.$magazine_pagesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Magazine_pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {magazine_pagesFindFirstArgs} args - Arguments to find a Magazine_pages
     * @example
     * // Get one Magazine_pages
     * const magazine_pages = await prisma.magazine_pages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends magazine_pagesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, magazine_pagesFindFirstArgs<ExtArgs>>
    ): Prisma__magazine_pagesClient<$Result.GetResult<Prisma.$magazine_pagesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Magazine_pages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {magazine_pagesFindFirstOrThrowArgs} args - Arguments to find a Magazine_pages
     * @example
     * // Get one Magazine_pages
     * const magazine_pages = await prisma.magazine_pages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends magazine_pagesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, magazine_pagesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__magazine_pagesClient<$Result.GetResult<Prisma.$magazine_pagesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Magazine_pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {magazine_pagesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Magazine_pages
     * const magazine_pages = await prisma.magazine_pages.findMany()
     * 
     * // Get first 10 Magazine_pages
     * const magazine_pages = await prisma.magazine_pages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const magazine_pagesWithIdOnly = await prisma.magazine_pages.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends magazine_pagesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, magazine_pagesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$magazine_pagesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Magazine_pages.
     * @param {magazine_pagesCreateArgs} args - Arguments to create a Magazine_pages.
     * @example
     * // Create one Magazine_pages
     * const Magazine_pages = await prisma.magazine_pages.create({
     *   data: {
     *     // ... data to create a Magazine_pages
     *   }
     * })
     * 
    **/
    create<T extends magazine_pagesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, magazine_pagesCreateArgs<ExtArgs>>
    ): Prisma__magazine_pagesClient<$Result.GetResult<Prisma.$magazine_pagesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Magazine_pages.
     *     @param {magazine_pagesCreateManyArgs} args - Arguments to create many Magazine_pages.
     *     @example
     *     // Create many Magazine_pages
     *     const magazine_pages = await prisma.magazine_pages.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends magazine_pagesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, magazine_pagesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Magazine_pages.
     * @param {magazine_pagesDeleteArgs} args - Arguments to delete one Magazine_pages.
     * @example
     * // Delete one Magazine_pages
     * const Magazine_pages = await prisma.magazine_pages.delete({
     *   where: {
     *     // ... filter to delete one Magazine_pages
     *   }
     * })
     * 
    **/
    delete<T extends magazine_pagesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, magazine_pagesDeleteArgs<ExtArgs>>
    ): Prisma__magazine_pagesClient<$Result.GetResult<Prisma.$magazine_pagesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Magazine_pages.
     * @param {magazine_pagesUpdateArgs} args - Arguments to update one Magazine_pages.
     * @example
     * // Update one Magazine_pages
     * const magazine_pages = await prisma.magazine_pages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends magazine_pagesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, magazine_pagesUpdateArgs<ExtArgs>>
    ): Prisma__magazine_pagesClient<$Result.GetResult<Prisma.$magazine_pagesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Magazine_pages.
     * @param {magazine_pagesDeleteManyArgs} args - Arguments to filter Magazine_pages to delete.
     * @example
     * // Delete a few Magazine_pages
     * const { count } = await prisma.magazine_pages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends magazine_pagesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, magazine_pagesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Magazine_pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {magazine_pagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Magazine_pages
     * const magazine_pages = await prisma.magazine_pages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends magazine_pagesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, magazine_pagesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Magazine_pages.
     * @param {magazine_pagesUpsertArgs} args - Arguments to update or create a Magazine_pages.
     * @example
     * // Update or create a Magazine_pages
     * const magazine_pages = await prisma.magazine_pages.upsert({
     *   create: {
     *     // ... data to create a Magazine_pages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Magazine_pages we want to update
     *   }
     * })
    **/
    upsert<T extends magazine_pagesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, magazine_pagesUpsertArgs<ExtArgs>>
    ): Prisma__magazine_pagesClient<$Result.GetResult<Prisma.$magazine_pagesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Magazine_pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {magazine_pagesCountArgs} args - Arguments to filter Magazine_pages to count.
     * @example
     * // Count the number of Magazine_pages
     * const count = await prisma.magazine_pages.count({
     *   where: {
     *     // ... the filter for the Magazine_pages we want to count
     *   }
     * })
    **/
    count<T extends magazine_pagesCountArgs>(
      args?: Subset<T, magazine_pagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Magazine_pagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Magazine_pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Magazine_pagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Magazine_pagesAggregateArgs>(args: Subset<T, Magazine_pagesAggregateArgs>): Prisma.PrismaPromise<GetMagazine_pagesAggregateType<T>>

    /**
     * Group by Magazine_pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {magazine_pagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends magazine_pagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: magazine_pagesGroupByArgs['orderBy'] }
        : { orderBy?: magazine_pagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, magazine_pagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMagazine_pagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the magazine_pages model
   */
  readonly fields: magazine_pagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for magazine_pages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__magazine_pagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the magazine_pages model
   */ 
  interface magazine_pagesFieldRefs {
    readonly id: FieldRef<"magazine_pages", 'Int'>
    readonly magazine_id: FieldRef<"magazine_pages", 'Int'>
    readonly img_path: FieldRef<"magazine_pages", 'String'>
    readonly img_thumb_path: FieldRef<"magazine_pages", 'String'>
    readonly img_large_path: FieldRef<"magazine_pages", 'String'>
    readonly counter: FieldRef<"magazine_pages", 'Int'>
    readonly user_id: FieldRef<"magazine_pages", 'Int'>
    readonly deletable: FieldRef<"magazine_pages", 'Int'>
    readonly created_at: FieldRef<"magazine_pages", 'DateTime'>
    readonly updated_at: FieldRef<"magazine_pages", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * magazine_pages findUnique
   */
  export type magazine_pagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazine_pages
     */
    select?: magazine_pagesSelect<ExtArgs> | null
    /**
     * Filter, which magazine_pages to fetch.
     */
    where: magazine_pagesWhereUniqueInput
  }


  /**
   * magazine_pages findUniqueOrThrow
   */
  export type magazine_pagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazine_pages
     */
    select?: magazine_pagesSelect<ExtArgs> | null
    /**
     * Filter, which magazine_pages to fetch.
     */
    where: magazine_pagesWhereUniqueInput
  }


  /**
   * magazine_pages findFirst
   */
  export type magazine_pagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazine_pages
     */
    select?: magazine_pagesSelect<ExtArgs> | null
    /**
     * Filter, which magazine_pages to fetch.
     */
    where?: magazine_pagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of magazine_pages to fetch.
     */
    orderBy?: magazine_pagesOrderByWithRelationInput | magazine_pagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for magazine_pages.
     */
    cursor?: magazine_pagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` magazine_pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` magazine_pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of magazine_pages.
     */
    distinct?: Magazine_pagesScalarFieldEnum | Magazine_pagesScalarFieldEnum[]
  }


  /**
   * magazine_pages findFirstOrThrow
   */
  export type magazine_pagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazine_pages
     */
    select?: magazine_pagesSelect<ExtArgs> | null
    /**
     * Filter, which magazine_pages to fetch.
     */
    where?: magazine_pagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of magazine_pages to fetch.
     */
    orderBy?: magazine_pagesOrderByWithRelationInput | magazine_pagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for magazine_pages.
     */
    cursor?: magazine_pagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` magazine_pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` magazine_pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of magazine_pages.
     */
    distinct?: Magazine_pagesScalarFieldEnum | Magazine_pagesScalarFieldEnum[]
  }


  /**
   * magazine_pages findMany
   */
  export type magazine_pagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazine_pages
     */
    select?: magazine_pagesSelect<ExtArgs> | null
    /**
     * Filter, which magazine_pages to fetch.
     */
    where?: magazine_pagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of magazine_pages to fetch.
     */
    orderBy?: magazine_pagesOrderByWithRelationInput | magazine_pagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing magazine_pages.
     */
    cursor?: magazine_pagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` magazine_pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` magazine_pages.
     */
    skip?: number
    distinct?: Magazine_pagesScalarFieldEnum | Magazine_pagesScalarFieldEnum[]
  }


  /**
   * magazine_pages create
   */
  export type magazine_pagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazine_pages
     */
    select?: magazine_pagesSelect<ExtArgs> | null
    /**
     * The data needed to create a magazine_pages.
     */
    data: XOR<magazine_pagesCreateInput, magazine_pagesUncheckedCreateInput>
  }


  /**
   * magazine_pages createMany
   */
  export type magazine_pagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many magazine_pages.
     */
    data: magazine_pagesCreateManyInput | magazine_pagesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * magazine_pages update
   */
  export type magazine_pagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazine_pages
     */
    select?: magazine_pagesSelect<ExtArgs> | null
    /**
     * The data needed to update a magazine_pages.
     */
    data: XOR<magazine_pagesUpdateInput, magazine_pagesUncheckedUpdateInput>
    /**
     * Choose, which magazine_pages to update.
     */
    where: magazine_pagesWhereUniqueInput
  }


  /**
   * magazine_pages updateMany
   */
  export type magazine_pagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update magazine_pages.
     */
    data: XOR<magazine_pagesUpdateManyMutationInput, magazine_pagesUncheckedUpdateManyInput>
    /**
     * Filter which magazine_pages to update
     */
    where?: magazine_pagesWhereInput
  }


  /**
   * magazine_pages upsert
   */
  export type magazine_pagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazine_pages
     */
    select?: magazine_pagesSelect<ExtArgs> | null
    /**
     * The filter to search for the magazine_pages to update in case it exists.
     */
    where: magazine_pagesWhereUniqueInput
    /**
     * In case the magazine_pages found by the `where` argument doesn't exist, create a new magazine_pages with this data.
     */
    create: XOR<magazine_pagesCreateInput, magazine_pagesUncheckedCreateInput>
    /**
     * In case the magazine_pages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<magazine_pagesUpdateInput, magazine_pagesUncheckedUpdateInput>
  }


  /**
   * magazine_pages delete
   */
  export type magazine_pagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazine_pages
     */
    select?: magazine_pagesSelect<ExtArgs> | null
    /**
     * Filter which magazine_pages to delete.
     */
    where: magazine_pagesWhereUniqueInput
  }


  /**
   * magazine_pages deleteMany
   */
  export type magazine_pagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which magazine_pages to delete
     */
    where?: magazine_pagesWhereInput
  }


  /**
   * magazine_pages without action
   */
  export type magazine_pagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazine_pages
     */
    select?: magazine_pagesSelect<ExtArgs> | null
  }



  /**
   * Model magazines
   */

  export type AggregateMagazines = {
    _count: MagazinesCountAggregateOutputType | null
    _avg: MagazinesAvgAggregateOutputType | null
    _sum: MagazinesSumAggregateOutputType | null
    _min: MagazinesMinAggregateOutputType | null
    _max: MagazinesMaxAggregateOutputType | null
  }

  export type MagazinesAvgAggregateOutputType = {
    id: number | null
    total_page: number | null
    user_id: number | null
    status: number | null
    deletable: number | null
  }

  export type MagazinesSumAggregateOutputType = {
    id: number | null
    total_page: number | null
    user_id: number | null
    status: number | null
    deletable: number | null
  }

  export type MagazinesMinAggregateOutputType = {
    id: number | null
    name: string | null
    total_page: number | null
    meta_keywords: string | null
    meta_description: string | null
    og_img_path: string | null
    user_id: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MagazinesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    total_page: number | null
    meta_keywords: string | null
    meta_description: string | null
    og_img_path: string | null
    user_id: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MagazinesCountAggregateOutputType = {
    id: number
    name: number
    total_page: number
    meta_keywords: number
    meta_description: number
    og_img_path: number
    user_id: number
    status: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type MagazinesAvgAggregateInputType = {
    id?: true
    total_page?: true
    user_id?: true
    status?: true
    deletable?: true
  }

  export type MagazinesSumAggregateInputType = {
    id?: true
    total_page?: true
    user_id?: true
    status?: true
    deletable?: true
  }

  export type MagazinesMinAggregateInputType = {
    id?: true
    name?: true
    total_page?: true
    meta_keywords?: true
    meta_description?: true
    og_img_path?: true
    user_id?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type MagazinesMaxAggregateInputType = {
    id?: true
    name?: true
    total_page?: true
    meta_keywords?: true
    meta_description?: true
    og_img_path?: true
    user_id?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type MagazinesCountAggregateInputType = {
    id?: true
    name?: true
    total_page?: true
    meta_keywords?: true
    meta_description?: true
    og_img_path?: true
    user_id?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type MagazinesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which magazines to aggregate.
     */
    where?: magazinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of magazines to fetch.
     */
    orderBy?: magazinesOrderByWithRelationInput | magazinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: magazinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` magazines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` magazines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned magazines
    **/
    _count?: true | MagazinesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MagazinesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MagazinesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MagazinesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MagazinesMaxAggregateInputType
  }

  export type GetMagazinesAggregateType<T extends MagazinesAggregateArgs> = {
        [P in keyof T & keyof AggregateMagazines]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMagazines[P]>
      : GetScalarType<T[P], AggregateMagazines[P]>
  }




  export type magazinesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: magazinesWhereInput
    orderBy?: magazinesOrderByWithAggregationInput | magazinesOrderByWithAggregationInput[]
    by: MagazinesScalarFieldEnum[] | MagazinesScalarFieldEnum
    having?: magazinesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MagazinesCountAggregateInputType | true
    _avg?: MagazinesAvgAggregateInputType
    _sum?: MagazinesSumAggregateInputType
    _min?: MagazinesMinAggregateInputType
    _max?: MagazinesMaxAggregateInputType
  }

  export type MagazinesGroupByOutputType = {
    id: number
    name: string | null
    total_page: number | null
    meta_keywords: string | null
    meta_description: string
    og_img_path: string | null
    user_id: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
    _count: MagazinesCountAggregateOutputType | null
    _avg: MagazinesAvgAggregateOutputType | null
    _sum: MagazinesSumAggregateOutputType | null
    _min: MagazinesMinAggregateOutputType | null
    _max: MagazinesMaxAggregateOutputType | null
  }

  type GetMagazinesGroupByPayload<T extends magazinesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MagazinesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MagazinesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MagazinesGroupByOutputType[P]>
            : GetScalarType<T[P], MagazinesGroupByOutputType[P]>
        }
      >
    >


  export type magazinesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    total_page?: boolean
    meta_keywords?: boolean
    meta_description?: boolean
    og_img_path?: boolean
    user_id?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["magazines"]>

  export type magazinesSelectScalar = {
    id?: boolean
    name?: boolean
    total_page?: boolean
    meta_keywords?: boolean
    meta_description?: boolean
    og_img_path?: boolean
    user_id?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $magazinesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "magazines"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      total_page: number | null
      meta_keywords: string | null
      meta_description: string
      og_img_path: string | null
      user_id: number | null
      status: number | null
      deletable: number | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["magazines"]>
    composites: {}
  }


  type magazinesGetPayload<S extends boolean | null | undefined | magazinesDefaultArgs> = $Result.GetResult<Prisma.$magazinesPayload, S>

  type magazinesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<magazinesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MagazinesCountAggregateInputType | true
    }

  export interface magazinesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['magazines'], meta: { name: 'magazines' } }
    /**
     * Find zero or one Magazines that matches the filter.
     * @param {magazinesFindUniqueArgs} args - Arguments to find a Magazines
     * @example
     * // Get one Magazines
     * const magazines = await prisma.magazines.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends magazinesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, magazinesFindUniqueArgs<ExtArgs>>
    ): Prisma__magazinesClient<$Result.GetResult<Prisma.$magazinesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Magazines that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {magazinesFindUniqueOrThrowArgs} args - Arguments to find a Magazines
     * @example
     * // Get one Magazines
     * const magazines = await prisma.magazines.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends magazinesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, magazinesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__magazinesClient<$Result.GetResult<Prisma.$magazinesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Magazines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {magazinesFindFirstArgs} args - Arguments to find a Magazines
     * @example
     * // Get one Magazines
     * const magazines = await prisma.magazines.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends magazinesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, magazinesFindFirstArgs<ExtArgs>>
    ): Prisma__magazinesClient<$Result.GetResult<Prisma.$magazinesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Magazines that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {magazinesFindFirstOrThrowArgs} args - Arguments to find a Magazines
     * @example
     * // Get one Magazines
     * const magazines = await prisma.magazines.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends magazinesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, magazinesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__magazinesClient<$Result.GetResult<Prisma.$magazinesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Magazines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {magazinesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Magazines
     * const magazines = await prisma.magazines.findMany()
     * 
     * // Get first 10 Magazines
     * const magazines = await prisma.magazines.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const magazinesWithIdOnly = await prisma.magazines.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends magazinesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, magazinesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$magazinesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Magazines.
     * @param {magazinesCreateArgs} args - Arguments to create a Magazines.
     * @example
     * // Create one Magazines
     * const Magazines = await prisma.magazines.create({
     *   data: {
     *     // ... data to create a Magazines
     *   }
     * })
     * 
    **/
    create<T extends magazinesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, magazinesCreateArgs<ExtArgs>>
    ): Prisma__magazinesClient<$Result.GetResult<Prisma.$magazinesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Magazines.
     *     @param {magazinesCreateManyArgs} args - Arguments to create many Magazines.
     *     @example
     *     // Create many Magazines
     *     const magazines = await prisma.magazines.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends magazinesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, magazinesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Magazines.
     * @param {magazinesDeleteArgs} args - Arguments to delete one Magazines.
     * @example
     * // Delete one Magazines
     * const Magazines = await prisma.magazines.delete({
     *   where: {
     *     // ... filter to delete one Magazines
     *   }
     * })
     * 
    **/
    delete<T extends magazinesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, magazinesDeleteArgs<ExtArgs>>
    ): Prisma__magazinesClient<$Result.GetResult<Prisma.$magazinesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Magazines.
     * @param {magazinesUpdateArgs} args - Arguments to update one Magazines.
     * @example
     * // Update one Magazines
     * const magazines = await prisma.magazines.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends magazinesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, magazinesUpdateArgs<ExtArgs>>
    ): Prisma__magazinesClient<$Result.GetResult<Prisma.$magazinesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Magazines.
     * @param {magazinesDeleteManyArgs} args - Arguments to filter Magazines to delete.
     * @example
     * // Delete a few Magazines
     * const { count } = await prisma.magazines.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends magazinesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, magazinesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Magazines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {magazinesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Magazines
     * const magazines = await prisma.magazines.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends magazinesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, magazinesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Magazines.
     * @param {magazinesUpsertArgs} args - Arguments to update or create a Magazines.
     * @example
     * // Update or create a Magazines
     * const magazines = await prisma.magazines.upsert({
     *   create: {
     *     // ... data to create a Magazines
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Magazines we want to update
     *   }
     * })
    **/
    upsert<T extends magazinesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, magazinesUpsertArgs<ExtArgs>>
    ): Prisma__magazinesClient<$Result.GetResult<Prisma.$magazinesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Magazines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {magazinesCountArgs} args - Arguments to filter Magazines to count.
     * @example
     * // Count the number of Magazines
     * const count = await prisma.magazines.count({
     *   where: {
     *     // ... the filter for the Magazines we want to count
     *   }
     * })
    **/
    count<T extends magazinesCountArgs>(
      args?: Subset<T, magazinesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MagazinesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Magazines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagazinesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MagazinesAggregateArgs>(args: Subset<T, MagazinesAggregateArgs>): Prisma.PrismaPromise<GetMagazinesAggregateType<T>>

    /**
     * Group by Magazines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {magazinesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends magazinesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: magazinesGroupByArgs['orderBy'] }
        : { orderBy?: magazinesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, magazinesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMagazinesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the magazines model
   */
  readonly fields: magazinesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for magazines.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__magazinesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the magazines model
   */ 
  interface magazinesFieldRefs {
    readonly id: FieldRef<"magazines", 'Int'>
    readonly name: FieldRef<"magazines", 'String'>
    readonly total_page: FieldRef<"magazines", 'Int'>
    readonly meta_keywords: FieldRef<"magazines", 'String'>
    readonly meta_description: FieldRef<"magazines", 'String'>
    readonly og_img_path: FieldRef<"magazines", 'String'>
    readonly user_id: FieldRef<"magazines", 'Int'>
    readonly status: FieldRef<"magazines", 'Int'>
    readonly deletable: FieldRef<"magazines", 'Int'>
    readonly created_at: FieldRef<"magazines", 'DateTime'>
    readonly updated_at: FieldRef<"magazines", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * magazines findUnique
   */
  export type magazinesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazines
     */
    select?: magazinesSelect<ExtArgs> | null
    /**
     * Filter, which magazines to fetch.
     */
    where: magazinesWhereUniqueInput
  }


  /**
   * magazines findUniqueOrThrow
   */
  export type magazinesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazines
     */
    select?: magazinesSelect<ExtArgs> | null
    /**
     * Filter, which magazines to fetch.
     */
    where: magazinesWhereUniqueInput
  }


  /**
   * magazines findFirst
   */
  export type magazinesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazines
     */
    select?: magazinesSelect<ExtArgs> | null
    /**
     * Filter, which magazines to fetch.
     */
    where?: magazinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of magazines to fetch.
     */
    orderBy?: magazinesOrderByWithRelationInput | magazinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for magazines.
     */
    cursor?: magazinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` magazines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` magazines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of magazines.
     */
    distinct?: MagazinesScalarFieldEnum | MagazinesScalarFieldEnum[]
  }


  /**
   * magazines findFirstOrThrow
   */
  export type magazinesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazines
     */
    select?: magazinesSelect<ExtArgs> | null
    /**
     * Filter, which magazines to fetch.
     */
    where?: magazinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of magazines to fetch.
     */
    orderBy?: magazinesOrderByWithRelationInput | magazinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for magazines.
     */
    cursor?: magazinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` magazines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` magazines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of magazines.
     */
    distinct?: MagazinesScalarFieldEnum | MagazinesScalarFieldEnum[]
  }


  /**
   * magazines findMany
   */
  export type magazinesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazines
     */
    select?: magazinesSelect<ExtArgs> | null
    /**
     * Filter, which magazines to fetch.
     */
    where?: magazinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of magazines to fetch.
     */
    orderBy?: magazinesOrderByWithRelationInput | magazinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing magazines.
     */
    cursor?: magazinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` magazines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` magazines.
     */
    skip?: number
    distinct?: MagazinesScalarFieldEnum | MagazinesScalarFieldEnum[]
  }


  /**
   * magazines create
   */
  export type magazinesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazines
     */
    select?: magazinesSelect<ExtArgs> | null
    /**
     * The data needed to create a magazines.
     */
    data: XOR<magazinesCreateInput, magazinesUncheckedCreateInput>
  }


  /**
   * magazines createMany
   */
  export type magazinesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many magazines.
     */
    data: magazinesCreateManyInput | magazinesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * magazines update
   */
  export type magazinesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazines
     */
    select?: magazinesSelect<ExtArgs> | null
    /**
     * The data needed to update a magazines.
     */
    data: XOR<magazinesUpdateInput, magazinesUncheckedUpdateInput>
    /**
     * Choose, which magazines to update.
     */
    where: magazinesWhereUniqueInput
  }


  /**
   * magazines updateMany
   */
  export type magazinesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update magazines.
     */
    data: XOR<magazinesUpdateManyMutationInput, magazinesUncheckedUpdateManyInput>
    /**
     * Filter which magazines to update
     */
    where?: magazinesWhereInput
  }


  /**
   * magazines upsert
   */
  export type magazinesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazines
     */
    select?: magazinesSelect<ExtArgs> | null
    /**
     * The filter to search for the magazines to update in case it exists.
     */
    where: magazinesWhereUniqueInput
    /**
     * In case the magazines found by the `where` argument doesn't exist, create a new magazines with this data.
     */
    create: XOR<magazinesCreateInput, magazinesUncheckedCreateInput>
    /**
     * In case the magazines was found with the provided `where` argument, update it with this data.
     */
    update: XOR<magazinesUpdateInput, magazinesUncheckedUpdateInput>
  }


  /**
   * magazines delete
   */
  export type magazinesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazines
     */
    select?: magazinesSelect<ExtArgs> | null
    /**
     * Filter which magazines to delete.
     */
    where: magazinesWhereUniqueInput
  }


  /**
   * magazines deleteMany
   */
  export type magazinesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which magazines to delete
     */
    where?: magazinesWhereInput
  }


  /**
   * magazines without action
   */
  export type magazinesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazines
     */
    select?: magazinesSelect<ExtArgs> | null
  }



  /**
   * Model manual_documents
   */

  export type AggregateManual_documents = {
    _count: Manual_documentsCountAggregateOutputType | null
    _avg: Manual_documentsAvgAggregateOutputType | null
    _sum: Manual_documentsSumAggregateOutputType | null
    _min: Manual_documentsMinAggregateOutputType | null
    _max: Manual_documentsMaxAggregateOutputType | null
  }

  export type Manual_documentsAvgAggregateOutputType = {
    doc_id: number | null
    deletable: number | null
  }

  export type Manual_documentsSumAggregateOutputType = {
    doc_id: number | null
    deletable: number | null
  }

  export type Manual_documentsMinAggregateOutputType = {
    doc_id: number | null
    doc_path: string | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Manual_documentsMaxAggregateOutputType = {
    doc_id: number | null
    doc_path: string | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Manual_documentsCountAggregateOutputType = {
    doc_id: number
    doc_path: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Manual_documentsAvgAggregateInputType = {
    doc_id?: true
    deletable?: true
  }

  export type Manual_documentsSumAggregateInputType = {
    doc_id?: true
    deletable?: true
  }

  export type Manual_documentsMinAggregateInputType = {
    doc_id?: true
    doc_path?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Manual_documentsMaxAggregateInputType = {
    doc_id?: true
    doc_path?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Manual_documentsCountAggregateInputType = {
    doc_id?: true
    doc_path?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Manual_documentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which manual_documents to aggregate.
     */
    where?: manual_documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manual_documents to fetch.
     */
    orderBy?: manual_documentsOrderByWithRelationInput | manual_documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: manual_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manual_documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manual_documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned manual_documents
    **/
    _count?: true | Manual_documentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Manual_documentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Manual_documentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Manual_documentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Manual_documentsMaxAggregateInputType
  }

  export type GetManual_documentsAggregateType<T extends Manual_documentsAggregateArgs> = {
        [P in keyof T & keyof AggregateManual_documents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManual_documents[P]>
      : GetScalarType<T[P], AggregateManual_documents[P]>
  }




  export type manual_documentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: manual_documentsWhereInput
    orderBy?: manual_documentsOrderByWithAggregationInput | manual_documentsOrderByWithAggregationInput[]
    by: Manual_documentsScalarFieldEnum[] | Manual_documentsScalarFieldEnum
    having?: manual_documentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Manual_documentsCountAggregateInputType | true
    _avg?: Manual_documentsAvgAggregateInputType
    _sum?: Manual_documentsSumAggregateInputType
    _min?: Manual_documentsMinAggregateInputType
    _max?: Manual_documentsMaxAggregateInputType
  }

  export type Manual_documentsGroupByOutputType = {
    doc_id: number
    doc_path: string
    deletable: number
    created_at: Date | null
    updated_at: Date | null
    _count: Manual_documentsCountAggregateOutputType | null
    _avg: Manual_documentsAvgAggregateOutputType | null
    _sum: Manual_documentsSumAggregateOutputType | null
    _min: Manual_documentsMinAggregateOutputType | null
    _max: Manual_documentsMaxAggregateOutputType | null
  }

  type GetManual_documentsGroupByPayload<T extends manual_documentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Manual_documentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Manual_documentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Manual_documentsGroupByOutputType[P]>
            : GetScalarType<T[P], Manual_documentsGroupByOutputType[P]>
        }
      >
    >


  export type manual_documentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    doc_id?: boolean
    doc_path?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["manual_documents"]>

  export type manual_documentsSelectScalar = {
    doc_id?: boolean
    doc_path?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $manual_documentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "manual_documents"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      doc_id: number
      doc_path: string
      deletable: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["manual_documents"]>
    composites: {}
  }


  type manual_documentsGetPayload<S extends boolean | null | undefined | manual_documentsDefaultArgs> = $Result.GetResult<Prisma.$manual_documentsPayload, S>

  type manual_documentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<manual_documentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Manual_documentsCountAggregateInputType | true
    }

  export interface manual_documentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['manual_documents'], meta: { name: 'manual_documents' } }
    /**
     * Find zero or one Manual_documents that matches the filter.
     * @param {manual_documentsFindUniqueArgs} args - Arguments to find a Manual_documents
     * @example
     * // Get one Manual_documents
     * const manual_documents = await prisma.manual_documents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends manual_documentsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, manual_documentsFindUniqueArgs<ExtArgs>>
    ): Prisma__manual_documentsClient<$Result.GetResult<Prisma.$manual_documentsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Manual_documents that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {manual_documentsFindUniqueOrThrowArgs} args - Arguments to find a Manual_documents
     * @example
     * // Get one Manual_documents
     * const manual_documents = await prisma.manual_documents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends manual_documentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, manual_documentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__manual_documentsClient<$Result.GetResult<Prisma.$manual_documentsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Manual_documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_documentsFindFirstArgs} args - Arguments to find a Manual_documents
     * @example
     * // Get one Manual_documents
     * const manual_documents = await prisma.manual_documents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends manual_documentsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, manual_documentsFindFirstArgs<ExtArgs>>
    ): Prisma__manual_documentsClient<$Result.GetResult<Prisma.$manual_documentsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Manual_documents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_documentsFindFirstOrThrowArgs} args - Arguments to find a Manual_documents
     * @example
     * // Get one Manual_documents
     * const manual_documents = await prisma.manual_documents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends manual_documentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, manual_documentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__manual_documentsClient<$Result.GetResult<Prisma.$manual_documentsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Manual_documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_documentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Manual_documents
     * const manual_documents = await prisma.manual_documents.findMany()
     * 
     * // Get first 10 Manual_documents
     * const manual_documents = await prisma.manual_documents.findMany({ take: 10 })
     * 
     * // Only select the `doc_id`
     * const manual_documentsWithDoc_idOnly = await prisma.manual_documents.findMany({ select: { doc_id: true } })
     * 
    **/
    findMany<T extends manual_documentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, manual_documentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$manual_documentsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Manual_documents.
     * @param {manual_documentsCreateArgs} args - Arguments to create a Manual_documents.
     * @example
     * // Create one Manual_documents
     * const Manual_documents = await prisma.manual_documents.create({
     *   data: {
     *     // ... data to create a Manual_documents
     *   }
     * })
     * 
    **/
    create<T extends manual_documentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, manual_documentsCreateArgs<ExtArgs>>
    ): Prisma__manual_documentsClient<$Result.GetResult<Prisma.$manual_documentsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Manual_documents.
     *     @param {manual_documentsCreateManyArgs} args - Arguments to create many Manual_documents.
     *     @example
     *     // Create many Manual_documents
     *     const manual_documents = await prisma.manual_documents.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends manual_documentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, manual_documentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Manual_documents.
     * @param {manual_documentsDeleteArgs} args - Arguments to delete one Manual_documents.
     * @example
     * // Delete one Manual_documents
     * const Manual_documents = await prisma.manual_documents.delete({
     *   where: {
     *     // ... filter to delete one Manual_documents
     *   }
     * })
     * 
    **/
    delete<T extends manual_documentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, manual_documentsDeleteArgs<ExtArgs>>
    ): Prisma__manual_documentsClient<$Result.GetResult<Prisma.$manual_documentsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Manual_documents.
     * @param {manual_documentsUpdateArgs} args - Arguments to update one Manual_documents.
     * @example
     * // Update one Manual_documents
     * const manual_documents = await prisma.manual_documents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends manual_documentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, manual_documentsUpdateArgs<ExtArgs>>
    ): Prisma__manual_documentsClient<$Result.GetResult<Prisma.$manual_documentsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Manual_documents.
     * @param {manual_documentsDeleteManyArgs} args - Arguments to filter Manual_documents to delete.
     * @example
     * // Delete a few Manual_documents
     * const { count } = await prisma.manual_documents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends manual_documentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, manual_documentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Manual_documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_documentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Manual_documents
     * const manual_documents = await prisma.manual_documents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends manual_documentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, manual_documentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Manual_documents.
     * @param {manual_documentsUpsertArgs} args - Arguments to update or create a Manual_documents.
     * @example
     * // Update or create a Manual_documents
     * const manual_documents = await prisma.manual_documents.upsert({
     *   create: {
     *     // ... data to create a Manual_documents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manual_documents we want to update
     *   }
     * })
    **/
    upsert<T extends manual_documentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, manual_documentsUpsertArgs<ExtArgs>>
    ): Prisma__manual_documentsClient<$Result.GetResult<Prisma.$manual_documentsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Manual_documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_documentsCountArgs} args - Arguments to filter Manual_documents to count.
     * @example
     * // Count the number of Manual_documents
     * const count = await prisma.manual_documents.count({
     *   where: {
     *     // ... the filter for the Manual_documents we want to count
     *   }
     * })
    **/
    count<T extends manual_documentsCountArgs>(
      args?: Subset<T, manual_documentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Manual_documentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manual_documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Manual_documentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Manual_documentsAggregateArgs>(args: Subset<T, Manual_documentsAggregateArgs>): Prisma.PrismaPromise<GetManual_documentsAggregateType<T>>

    /**
     * Group by Manual_documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_documentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends manual_documentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: manual_documentsGroupByArgs['orderBy'] }
        : { orderBy?: manual_documentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, manual_documentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManual_documentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the manual_documents model
   */
  readonly fields: manual_documentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for manual_documents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__manual_documentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the manual_documents model
   */ 
  interface manual_documentsFieldRefs {
    readonly doc_id: FieldRef<"manual_documents", 'Int'>
    readonly doc_path: FieldRef<"manual_documents", 'String'>
    readonly deletable: FieldRef<"manual_documents", 'Int'>
    readonly created_at: FieldRef<"manual_documents", 'DateTime'>
    readonly updated_at: FieldRef<"manual_documents", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * manual_documents findUnique
   */
  export type manual_documentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_documents
     */
    select?: manual_documentsSelect<ExtArgs> | null
    /**
     * Filter, which manual_documents to fetch.
     */
    where: manual_documentsWhereUniqueInput
  }


  /**
   * manual_documents findUniqueOrThrow
   */
  export type manual_documentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_documents
     */
    select?: manual_documentsSelect<ExtArgs> | null
    /**
     * Filter, which manual_documents to fetch.
     */
    where: manual_documentsWhereUniqueInput
  }


  /**
   * manual_documents findFirst
   */
  export type manual_documentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_documents
     */
    select?: manual_documentsSelect<ExtArgs> | null
    /**
     * Filter, which manual_documents to fetch.
     */
    where?: manual_documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manual_documents to fetch.
     */
    orderBy?: manual_documentsOrderByWithRelationInput | manual_documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for manual_documents.
     */
    cursor?: manual_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manual_documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manual_documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of manual_documents.
     */
    distinct?: Manual_documentsScalarFieldEnum | Manual_documentsScalarFieldEnum[]
  }


  /**
   * manual_documents findFirstOrThrow
   */
  export type manual_documentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_documents
     */
    select?: manual_documentsSelect<ExtArgs> | null
    /**
     * Filter, which manual_documents to fetch.
     */
    where?: manual_documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manual_documents to fetch.
     */
    orderBy?: manual_documentsOrderByWithRelationInput | manual_documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for manual_documents.
     */
    cursor?: manual_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manual_documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manual_documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of manual_documents.
     */
    distinct?: Manual_documentsScalarFieldEnum | Manual_documentsScalarFieldEnum[]
  }


  /**
   * manual_documents findMany
   */
  export type manual_documentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_documents
     */
    select?: manual_documentsSelect<ExtArgs> | null
    /**
     * Filter, which manual_documents to fetch.
     */
    where?: manual_documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manual_documents to fetch.
     */
    orderBy?: manual_documentsOrderByWithRelationInput | manual_documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing manual_documents.
     */
    cursor?: manual_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manual_documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manual_documents.
     */
    skip?: number
    distinct?: Manual_documentsScalarFieldEnum | Manual_documentsScalarFieldEnum[]
  }


  /**
   * manual_documents create
   */
  export type manual_documentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_documents
     */
    select?: manual_documentsSelect<ExtArgs> | null
    /**
     * The data needed to create a manual_documents.
     */
    data: XOR<manual_documentsCreateInput, manual_documentsUncheckedCreateInput>
  }


  /**
   * manual_documents createMany
   */
  export type manual_documentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many manual_documents.
     */
    data: manual_documentsCreateManyInput | manual_documentsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * manual_documents update
   */
  export type manual_documentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_documents
     */
    select?: manual_documentsSelect<ExtArgs> | null
    /**
     * The data needed to update a manual_documents.
     */
    data: XOR<manual_documentsUpdateInput, manual_documentsUncheckedUpdateInput>
    /**
     * Choose, which manual_documents to update.
     */
    where: manual_documentsWhereUniqueInput
  }


  /**
   * manual_documents updateMany
   */
  export type manual_documentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update manual_documents.
     */
    data: XOR<manual_documentsUpdateManyMutationInput, manual_documentsUncheckedUpdateManyInput>
    /**
     * Filter which manual_documents to update
     */
    where?: manual_documentsWhereInput
  }


  /**
   * manual_documents upsert
   */
  export type manual_documentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_documents
     */
    select?: manual_documentsSelect<ExtArgs> | null
    /**
     * The filter to search for the manual_documents to update in case it exists.
     */
    where: manual_documentsWhereUniqueInput
    /**
     * In case the manual_documents found by the `where` argument doesn't exist, create a new manual_documents with this data.
     */
    create: XOR<manual_documentsCreateInput, manual_documentsUncheckedCreateInput>
    /**
     * In case the manual_documents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<manual_documentsUpdateInput, manual_documentsUncheckedUpdateInput>
  }


  /**
   * manual_documents delete
   */
  export type manual_documentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_documents
     */
    select?: manual_documentsSelect<ExtArgs> | null
    /**
     * Filter which manual_documents to delete.
     */
    where: manual_documentsWhereUniqueInput
  }


  /**
   * manual_documents deleteMany
   */
  export type manual_documentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which manual_documents to delete
     */
    where?: manual_documentsWhereInput
  }


  /**
   * manual_documents without action
   */
  export type manual_documentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_documents
     */
    select?: manual_documentsSelect<ExtArgs> | null
  }



  /**
   * Model manual_photos
   */

  export type AggregateManual_photos = {
    _count: Manual_photosCountAggregateOutputType | null
    _avg: Manual_photosAvgAggregateOutputType | null
    _sum: Manual_photosSumAggregateOutputType | null
    _min: Manual_photosMinAggregateOutputType | null
    _max: Manual_photosMaxAggregateOutputType | null
  }

  export type Manual_photosAvgAggregateOutputType = {
    photo_id: number | null
    deletable: number | null
  }

  export type Manual_photosSumAggregateOutputType = {
    photo_id: number | null
    deletable: number | null
  }

  export type Manual_photosMinAggregateOutputType = {
    photo_id: number | null
    img_path: string | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Manual_photosMaxAggregateOutputType = {
    photo_id: number | null
    img_path: string | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Manual_photosCountAggregateOutputType = {
    photo_id: number
    img_path: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Manual_photosAvgAggregateInputType = {
    photo_id?: true
    deletable?: true
  }

  export type Manual_photosSumAggregateInputType = {
    photo_id?: true
    deletable?: true
  }

  export type Manual_photosMinAggregateInputType = {
    photo_id?: true
    img_path?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Manual_photosMaxAggregateInputType = {
    photo_id?: true
    img_path?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Manual_photosCountAggregateInputType = {
    photo_id?: true
    img_path?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Manual_photosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which manual_photos to aggregate.
     */
    where?: manual_photosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manual_photos to fetch.
     */
    orderBy?: manual_photosOrderByWithRelationInput | manual_photosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: manual_photosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manual_photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manual_photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned manual_photos
    **/
    _count?: true | Manual_photosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Manual_photosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Manual_photosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Manual_photosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Manual_photosMaxAggregateInputType
  }

  export type GetManual_photosAggregateType<T extends Manual_photosAggregateArgs> = {
        [P in keyof T & keyof AggregateManual_photos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManual_photos[P]>
      : GetScalarType<T[P], AggregateManual_photos[P]>
  }




  export type manual_photosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: manual_photosWhereInput
    orderBy?: manual_photosOrderByWithAggregationInput | manual_photosOrderByWithAggregationInput[]
    by: Manual_photosScalarFieldEnum[] | Manual_photosScalarFieldEnum
    having?: manual_photosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Manual_photosCountAggregateInputType | true
    _avg?: Manual_photosAvgAggregateInputType
    _sum?: Manual_photosSumAggregateInputType
    _min?: Manual_photosMinAggregateInputType
    _max?: Manual_photosMaxAggregateInputType
  }

  export type Manual_photosGroupByOutputType = {
    photo_id: number
    img_path: string
    deletable: number
    created_at: Date | null
    updated_at: Date | null
    _count: Manual_photosCountAggregateOutputType | null
    _avg: Manual_photosAvgAggregateOutputType | null
    _sum: Manual_photosSumAggregateOutputType | null
    _min: Manual_photosMinAggregateOutputType | null
    _max: Manual_photosMaxAggregateOutputType | null
  }

  type GetManual_photosGroupByPayload<T extends manual_photosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Manual_photosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Manual_photosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Manual_photosGroupByOutputType[P]>
            : GetScalarType<T[P], Manual_photosGroupByOutputType[P]>
        }
      >
    >


  export type manual_photosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    photo_id?: boolean
    img_path?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["manual_photos"]>

  export type manual_photosSelectScalar = {
    photo_id?: boolean
    img_path?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $manual_photosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "manual_photos"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      photo_id: number
      img_path: string
      deletable: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["manual_photos"]>
    composites: {}
  }


  type manual_photosGetPayload<S extends boolean | null | undefined | manual_photosDefaultArgs> = $Result.GetResult<Prisma.$manual_photosPayload, S>

  type manual_photosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<manual_photosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Manual_photosCountAggregateInputType | true
    }

  export interface manual_photosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['manual_photos'], meta: { name: 'manual_photos' } }
    /**
     * Find zero or one Manual_photos that matches the filter.
     * @param {manual_photosFindUniqueArgs} args - Arguments to find a Manual_photos
     * @example
     * // Get one Manual_photos
     * const manual_photos = await prisma.manual_photos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends manual_photosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, manual_photosFindUniqueArgs<ExtArgs>>
    ): Prisma__manual_photosClient<$Result.GetResult<Prisma.$manual_photosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Manual_photos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {manual_photosFindUniqueOrThrowArgs} args - Arguments to find a Manual_photos
     * @example
     * // Get one Manual_photos
     * const manual_photos = await prisma.manual_photos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends manual_photosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, manual_photosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__manual_photosClient<$Result.GetResult<Prisma.$manual_photosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Manual_photos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_photosFindFirstArgs} args - Arguments to find a Manual_photos
     * @example
     * // Get one Manual_photos
     * const manual_photos = await prisma.manual_photos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends manual_photosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, manual_photosFindFirstArgs<ExtArgs>>
    ): Prisma__manual_photosClient<$Result.GetResult<Prisma.$manual_photosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Manual_photos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_photosFindFirstOrThrowArgs} args - Arguments to find a Manual_photos
     * @example
     * // Get one Manual_photos
     * const manual_photos = await prisma.manual_photos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends manual_photosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, manual_photosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__manual_photosClient<$Result.GetResult<Prisma.$manual_photosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Manual_photos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_photosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Manual_photos
     * const manual_photos = await prisma.manual_photos.findMany()
     * 
     * // Get first 10 Manual_photos
     * const manual_photos = await prisma.manual_photos.findMany({ take: 10 })
     * 
     * // Only select the `photo_id`
     * const manual_photosWithPhoto_idOnly = await prisma.manual_photos.findMany({ select: { photo_id: true } })
     * 
    **/
    findMany<T extends manual_photosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, manual_photosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$manual_photosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Manual_photos.
     * @param {manual_photosCreateArgs} args - Arguments to create a Manual_photos.
     * @example
     * // Create one Manual_photos
     * const Manual_photos = await prisma.manual_photos.create({
     *   data: {
     *     // ... data to create a Manual_photos
     *   }
     * })
     * 
    **/
    create<T extends manual_photosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, manual_photosCreateArgs<ExtArgs>>
    ): Prisma__manual_photosClient<$Result.GetResult<Prisma.$manual_photosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Manual_photos.
     *     @param {manual_photosCreateManyArgs} args - Arguments to create many Manual_photos.
     *     @example
     *     // Create many Manual_photos
     *     const manual_photos = await prisma.manual_photos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends manual_photosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, manual_photosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Manual_photos.
     * @param {manual_photosDeleteArgs} args - Arguments to delete one Manual_photos.
     * @example
     * // Delete one Manual_photos
     * const Manual_photos = await prisma.manual_photos.delete({
     *   where: {
     *     // ... filter to delete one Manual_photos
     *   }
     * })
     * 
    **/
    delete<T extends manual_photosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, manual_photosDeleteArgs<ExtArgs>>
    ): Prisma__manual_photosClient<$Result.GetResult<Prisma.$manual_photosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Manual_photos.
     * @param {manual_photosUpdateArgs} args - Arguments to update one Manual_photos.
     * @example
     * // Update one Manual_photos
     * const manual_photos = await prisma.manual_photos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends manual_photosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, manual_photosUpdateArgs<ExtArgs>>
    ): Prisma__manual_photosClient<$Result.GetResult<Prisma.$manual_photosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Manual_photos.
     * @param {manual_photosDeleteManyArgs} args - Arguments to filter Manual_photos to delete.
     * @example
     * // Delete a few Manual_photos
     * const { count } = await prisma.manual_photos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends manual_photosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, manual_photosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Manual_photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_photosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Manual_photos
     * const manual_photos = await prisma.manual_photos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends manual_photosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, manual_photosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Manual_photos.
     * @param {manual_photosUpsertArgs} args - Arguments to update or create a Manual_photos.
     * @example
     * // Update or create a Manual_photos
     * const manual_photos = await prisma.manual_photos.upsert({
     *   create: {
     *     // ... data to create a Manual_photos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manual_photos we want to update
     *   }
     * })
    **/
    upsert<T extends manual_photosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, manual_photosUpsertArgs<ExtArgs>>
    ): Prisma__manual_photosClient<$Result.GetResult<Prisma.$manual_photosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Manual_photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_photosCountArgs} args - Arguments to filter Manual_photos to count.
     * @example
     * // Count the number of Manual_photos
     * const count = await prisma.manual_photos.count({
     *   where: {
     *     // ... the filter for the Manual_photos we want to count
     *   }
     * })
    **/
    count<T extends manual_photosCountArgs>(
      args?: Subset<T, manual_photosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Manual_photosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manual_photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Manual_photosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Manual_photosAggregateArgs>(args: Subset<T, Manual_photosAggregateArgs>): Prisma.PrismaPromise<GetManual_photosAggregateType<T>>

    /**
     * Group by Manual_photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manual_photosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends manual_photosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: manual_photosGroupByArgs['orderBy'] }
        : { orderBy?: manual_photosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, manual_photosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManual_photosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the manual_photos model
   */
  readonly fields: manual_photosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for manual_photos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__manual_photosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the manual_photos model
   */ 
  interface manual_photosFieldRefs {
    readonly photo_id: FieldRef<"manual_photos", 'Int'>
    readonly img_path: FieldRef<"manual_photos", 'String'>
    readonly deletable: FieldRef<"manual_photos", 'Int'>
    readonly created_at: FieldRef<"manual_photos", 'DateTime'>
    readonly updated_at: FieldRef<"manual_photos", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * manual_photos findUnique
   */
  export type manual_photosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_photos
     */
    select?: manual_photosSelect<ExtArgs> | null
    /**
     * Filter, which manual_photos to fetch.
     */
    where: manual_photosWhereUniqueInput
  }


  /**
   * manual_photos findUniqueOrThrow
   */
  export type manual_photosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_photos
     */
    select?: manual_photosSelect<ExtArgs> | null
    /**
     * Filter, which manual_photos to fetch.
     */
    where: manual_photosWhereUniqueInput
  }


  /**
   * manual_photos findFirst
   */
  export type manual_photosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_photos
     */
    select?: manual_photosSelect<ExtArgs> | null
    /**
     * Filter, which manual_photos to fetch.
     */
    where?: manual_photosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manual_photos to fetch.
     */
    orderBy?: manual_photosOrderByWithRelationInput | manual_photosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for manual_photos.
     */
    cursor?: manual_photosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manual_photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manual_photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of manual_photos.
     */
    distinct?: Manual_photosScalarFieldEnum | Manual_photosScalarFieldEnum[]
  }


  /**
   * manual_photos findFirstOrThrow
   */
  export type manual_photosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_photos
     */
    select?: manual_photosSelect<ExtArgs> | null
    /**
     * Filter, which manual_photos to fetch.
     */
    where?: manual_photosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manual_photos to fetch.
     */
    orderBy?: manual_photosOrderByWithRelationInput | manual_photosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for manual_photos.
     */
    cursor?: manual_photosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manual_photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manual_photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of manual_photos.
     */
    distinct?: Manual_photosScalarFieldEnum | Manual_photosScalarFieldEnum[]
  }


  /**
   * manual_photos findMany
   */
  export type manual_photosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_photos
     */
    select?: manual_photosSelect<ExtArgs> | null
    /**
     * Filter, which manual_photos to fetch.
     */
    where?: manual_photosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manual_photos to fetch.
     */
    orderBy?: manual_photosOrderByWithRelationInput | manual_photosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing manual_photos.
     */
    cursor?: manual_photosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manual_photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manual_photos.
     */
    skip?: number
    distinct?: Manual_photosScalarFieldEnum | Manual_photosScalarFieldEnum[]
  }


  /**
   * manual_photos create
   */
  export type manual_photosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_photos
     */
    select?: manual_photosSelect<ExtArgs> | null
    /**
     * The data needed to create a manual_photos.
     */
    data: XOR<manual_photosCreateInput, manual_photosUncheckedCreateInput>
  }


  /**
   * manual_photos createMany
   */
  export type manual_photosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many manual_photos.
     */
    data: manual_photosCreateManyInput | manual_photosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * manual_photos update
   */
  export type manual_photosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_photos
     */
    select?: manual_photosSelect<ExtArgs> | null
    /**
     * The data needed to update a manual_photos.
     */
    data: XOR<manual_photosUpdateInput, manual_photosUncheckedUpdateInput>
    /**
     * Choose, which manual_photos to update.
     */
    where: manual_photosWhereUniqueInput
  }


  /**
   * manual_photos updateMany
   */
  export type manual_photosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update manual_photos.
     */
    data: XOR<manual_photosUpdateManyMutationInput, manual_photosUncheckedUpdateManyInput>
    /**
     * Filter which manual_photos to update
     */
    where?: manual_photosWhereInput
  }


  /**
   * manual_photos upsert
   */
  export type manual_photosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_photos
     */
    select?: manual_photosSelect<ExtArgs> | null
    /**
     * The filter to search for the manual_photos to update in case it exists.
     */
    where: manual_photosWhereUniqueInput
    /**
     * In case the manual_photos found by the `where` argument doesn't exist, create a new manual_photos with this data.
     */
    create: XOR<manual_photosCreateInput, manual_photosUncheckedCreateInput>
    /**
     * In case the manual_photos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<manual_photosUpdateInput, manual_photosUncheckedUpdateInput>
  }


  /**
   * manual_photos delete
   */
  export type manual_photosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_photos
     */
    select?: manual_photosSelect<ExtArgs> | null
    /**
     * Filter which manual_photos to delete.
     */
    where: manual_photosWhereUniqueInput
  }


  /**
   * manual_photos deleteMany
   */
  export type manual_photosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which manual_photos to delete
     */
    where?: manual_photosWhereInput
  }


  /**
   * manual_photos without action
   */
  export type manual_photosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manual_photos
     */
    select?: manual_photosSelect<ExtArgs> | null
  }



  /**
   * Model mis_users
   */

  export type AggregateMis_users = {
    _count: Mis_usersCountAggregateOutputType | null
    _avg: Mis_usersAvgAggregateOutputType | null
    _sum: Mis_usersSumAggregateOutputType | null
    _min: Mis_usersMinAggregateOutputType | null
    _max: Mis_usersMaxAggregateOutputType | null
  }

  export type Mis_usersAvgAggregateOutputType = {
    user_id: number | null
    user_type: number | null
    admin_id: number | null
    dept_type: number | null
    deletable: number | null
  }

  export type Mis_usersSumAggregateOutputType = {
    user_id: number | null
    user_type: number | null
    admin_id: number | null
    dept_type: number | null
    deletable: number | null
  }

  export type Mis_usersMinAggregateOutputType = {
    user_id: number | null
    user_type: number | null
    admin_id: number | null
    dept_type: number | null
    user_name: string | null
    user_name_bn: string | null
    user_slug: string | null
    user_initial: string | null
    user_initial_bn: string | null
    user_bio: string | null
    user_bio_bn: string | null
    img_path: string | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Mis_usersMaxAggregateOutputType = {
    user_id: number | null
    user_type: number | null
    admin_id: number | null
    dept_type: number | null
    user_name: string | null
    user_name_bn: string | null
    user_slug: string | null
    user_initial: string | null
    user_initial_bn: string | null
    user_bio: string | null
    user_bio_bn: string | null
    img_path: string | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Mis_usersCountAggregateOutputType = {
    user_id: number
    user_type: number
    admin_id: number
    dept_type: number
    user_name: number
    user_name_bn: number
    user_slug: number
    user_initial: number
    user_initial_bn: number
    user_bio: number
    user_bio_bn: number
    img_path: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Mis_usersAvgAggregateInputType = {
    user_id?: true
    user_type?: true
    admin_id?: true
    dept_type?: true
    deletable?: true
  }

  export type Mis_usersSumAggregateInputType = {
    user_id?: true
    user_type?: true
    admin_id?: true
    dept_type?: true
    deletable?: true
  }

  export type Mis_usersMinAggregateInputType = {
    user_id?: true
    user_type?: true
    admin_id?: true
    dept_type?: true
    user_name?: true
    user_name_bn?: true
    user_slug?: true
    user_initial?: true
    user_initial_bn?: true
    user_bio?: true
    user_bio_bn?: true
    img_path?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Mis_usersMaxAggregateInputType = {
    user_id?: true
    user_type?: true
    admin_id?: true
    dept_type?: true
    user_name?: true
    user_name_bn?: true
    user_slug?: true
    user_initial?: true
    user_initial_bn?: true
    user_bio?: true
    user_bio_bn?: true
    img_path?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Mis_usersCountAggregateInputType = {
    user_id?: true
    user_type?: true
    admin_id?: true
    dept_type?: true
    user_name?: true
    user_name_bn?: true
    user_slug?: true
    user_initial?: true
    user_initial_bn?: true
    user_bio?: true
    user_bio_bn?: true
    img_path?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Mis_usersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mis_users to aggregate.
     */
    where?: mis_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mis_users to fetch.
     */
    orderBy?: mis_usersOrderByWithRelationInput | mis_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mis_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mis_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mis_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mis_users
    **/
    _count?: true | Mis_usersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Mis_usersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Mis_usersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Mis_usersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Mis_usersMaxAggregateInputType
  }

  export type GetMis_usersAggregateType<T extends Mis_usersAggregateArgs> = {
        [P in keyof T & keyof AggregateMis_users]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMis_users[P]>
      : GetScalarType<T[P], AggregateMis_users[P]>
  }




  export type mis_usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mis_usersWhereInput
    orderBy?: mis_usersOrderByWithAggregationInput | mis_usersOrderByWithAggregationInput[]
    by: Mis_usersScalarFieldEnum[] | Mis_usersScalarFieldEnum
    having?: mis_usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Mis_usersCountAggregateInputType | true
    _avg?: Mis_usersAvgAggregateInputType
    _sum?: Mis_usersSumAggregateInputType
    _min?: Mis_usersMinAggregateInputType
    _max?: Mis_usersMaxAggregateInputType
  }

  export type Mis_usersGroupByOutputType = {
    user_id: number
    user_type: number
    admin_id: number | null
    dept_type: number
    user_name: string
    user_name_bn: string | null
    user_slug: string
    user_initial: string
    user_initial_bn: string | null
    user_bio: string | null
    user_bio_bn: string | null
    img_path: string | null
    deletable: number
    created_at: Date | null
    updated_at: Date | null
    _count: Mis_usersCountAggregateOutputType | null
    _avg: Mis_usersAvgAggregateOutputType | null
    _sum: Mis_usersSumAggregateOutputType | null
    _min: Mis_usersMinAggregateOutputType | null
    _max: Mis_usersMaxAggregateOutputType | null
  }

  type GetMis_usersGroupByPayload<T extends mis_usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Mis_usersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Mis_usersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Mis_usersGroupByOutputType[P]>
            : GetScalarType<T[P], Mis_usersGroupByOutputType[P]>
        }
      >
    >


  export type mis_usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    user_type?: boolean
    admin_id?: boolean
    dept_type?: boolean
    user_name?: boolean
    user_name_bn?: boolean
    user_slug?: boolean
    user_initial?: boolean
    user_initial_bn?: boolean
    user_bio?: boolean
    user_bio_bn?: boolean
    img_path?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["mis_users"]>

  export type mis_usersSelectScalar = {
    user_id?: boolean
    user_type?: boolean
    admin_id?: boolean
    dept_type?: boolean
    user_name?: boolean
    user_name_bn?: boolean
    user_slug?: boolean
    user_initial?: boolean
    user_initial_bn?: boolean
    user_bio?: boolean
    user_bio_bn?: boolean
    img_path?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $mis_usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mis_users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      user_type: number
      admin_id: number | null
      dept_type: number
      user_name: string
      user_name_bn: string | null
      user_slug: string
      user_initial: string
      user_initial_bn: string | null
      user_bio: string | null
      user_bio_bn: string | null
      img_path: string | null
      deletable: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["mis_users"]>
    composites: {}
  }


  type mis_usersGetPayload<S extends boolean | null | undefined | mis_usersDefaultArgs> = $Result.GetResult<Prisma.$mis_usersPayload, S>

  type mis_usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<mis_usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Mis_usersCountAggregateInputType | true
    }

  export interface mis_usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mis_users'], meta: { name: 'mis_users' } }
    /**
     * Find zero or one Mis_users that matches the filter.
     * @param {mis_usersFindUniqueArgs} args - Arguments to find a Mis_users
     * @example
     * // Get one Mis_users
     * const mis_users = await prisma.mis_users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mis_usersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, mis_usersFindUniqueArgs<ExtArgs>>
    ): Prisma__mis_usersClient<$Result.GetResult<Prisma.$mis_usersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Mis_users that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {mis_usersFindUniqueOrThrowArgs} args - Arguments to find a Mis_users
     * @example
     * // Get one Mis_users
     * const mis_users = await prisma.mis_users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mis_usersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mis_usersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__mis_usersClient<$Result.GetResult<Prisma.$mis_usersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Mis_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mis_usersFindFirstArgs} args - Arguments to find a Mis_users
     * @example
     * // Get one Mis_users
     * const mis_users = await prisma.mis_users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mis_usersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, mis_usersFindFirstArgs<ExtArgs>>
    ): Prisma__mis_usersClient<$Result.GetResult<Prisma.$mis_usersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Mis_users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mis_usersFindFirstOrThrowArgs} args - Arguments to find a Mis_users
     * @example
     * // Get one Mis_users
     * const mis_users = await prisma.mis_users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mis_usersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mis_usersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__mis_usersClient<$Result.GetResult<Prisma.$mis_usersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Mis_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mis_usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mis_users
     * const mis_users = await prisma.mis_users.findMany()
     * 
     * // Get first 10 Mis_users
     * const mis_users = await prisma.mis_users.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const mis_usersWithUser_idOnly = await prisma.mis_users.findMany({ select: { user_id: true } })
     * 
    **/
    findMany<T extends mis_usersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mis_usersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mis_usersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Mis_users.
     * @param {mis_usersCreateArgs} args - Arguments to create a Mis_users.
     * @example
     * // Create one Mis_users
     * const Mis_users = await prisma.mis_users.create({
     *   data: {
     *     // ... data to create a Mis_users
     *   }
     * })
     * 
    **/
    create<T extends mis_usersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, mis_usersCreateArgs<ExtArgs>>
    ): Prisma__mis_usersClient<$Result.GetResult<Prisma.$mis_usersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Mis_users.
     *     @param {mis_usersCreateManyArgs} args - Arguments to create many Mis_users.
     *     @example
     *     // Create many Mis_users
     *     const mis_users = await prisma.mis_users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mis_usersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mis_usersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mis_users.
     * @param {mis_usersDeleteArgs} args - Arguments to delete one Mis_users.
     * @example
     * // Delete one Mis_users
     * const Mis_users = await prisma.mis_users.delete({
     *   where: {
     *     // ... filter to delete one Mis_users
     *   }
     * })
     * 
    **/
    delete<T extends mis_usersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, mis_usersDeleteArgs<ExtArgs>>
    ): Prisma__mis_usersClient<$Result.GetResult<Prisma.$mis_usersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Mis_users.
     * @param {mis_usersUpdateArgs} args - Arguments to update one Mis_users.
     * @example
     * // Update one Mis_users
     * const mis_users = await prisma.mis_users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mis_usersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, mis_usersUpdateArgs<ExtArgs>>
    ): Prisma__mis_usersClient<$Result.GetResult<Prisma.$mis_usersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Mis_users.
     * @param {mis_usersDeleteManyArgs} args - Arguments to filter Mis_users to delete.
     * @example
     * // Delete a few Mis_users
     * const { count } = await prisma.mis_users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mis_usersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mis_usersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mis_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mis_usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mis_users
     * const mis_users = await prisma.mis_users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mis_usersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, mis_usersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mis_users.
     * @param {mis_usersUpsertArgs} args - Arguments to update or create a Mis_users.
     * @example
     * // Update or create a Mis_users
     * const mis_users = await prisma.mis_users.upsert({
     *   create: {
     *     // ... data to create a Mis_users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mis_users we want to update
     *   }
     * })
    **/
    upsert<T extends mis_usersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, mis_usersUpsertArgs<ExtArgs>>
    ): Prisma__mis_usersClient<$Result.GetResult<Prisma.$mis_usersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Mis_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mis_usersCountArgs} args - Arguments to filter Mis_users to count.
     * @example
     * // Count the number of Mis_users
     * const count = await prisma.mis_users.count({
     *   where: {
     *     // ... the filter for the Mis_users we want to count
     *   }
     * })
    **/
    count<T extends mis_usersCountArgs>(
      args?: Subset<T, mis_usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Mis_usersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mis_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mis_usersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Mis_usersAggregateArgs>(args: Subset<T, Mis_usersAggregateArgs>): Prisma.PrismaPromise<GetMis_usersAggregateType<T>>

    /**
     * Group by Mis_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mis_usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mis_usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mis_usersGroupByArgs['orderBy'] }
        : { orderBy?: mis_usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mis_usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMis_usersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mis_users model
   */
  readonly fields: mis_usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mis_users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mis_usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the mis_users model
   */ 
  interface mis_usersFieldRefs {
    readonly user_id: FieldRef<"mis_users", 'Int'>
    readonly user_type: FieldRef<"mis_users", 'Int'>
    readonly admin_id: FieldRef<"mis_users", 'Int'>
    readonly dept_type: FieldRef<"mis_users", 'Int'>
    readonly user_name: FieldRef<"mis_users", 'String'>
    readonly user_name_bn: FieldRef<"mis_users", 'String'>
    readonly user_slug: FieldRef<"mis_users", 'String'>
    readonly user_initial: FieldRef<"mis_users", 'String'>
    readonly user_initial_bn: FieldRef<"mis_users", 'String'>
    readonly user_bio: FieldRef<"mis_users", 'String'>
    readonly user_bio_bn: FieldRef<"mis_users", 'String'>
    readonly img_path: FieldRef<"mis_users", 'String'>
    readonly deletable: FieldRef<"mis_users", 'Int'>
    readonly created_at: FieldRef<"mis_users", 'DateTime'>
    readonly updated_at: FieldRef<"mis_users", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * mis_users findUnique
   */
  export type mis_usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mis_users
     */
    select?: mis_usersSelect<ExtArgs> | null
    /**
     * Filter, which mis_users to fetch.
     */
    where: mis_usersWhereUniqueInput
  }


  /**
   * mis_users findUniqueOrThrow
   */
  export type mis_usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mis_users
     */
    select?: mis_usersSelect<ExtArgs> | null
    /**
     * Filter, which mis_users to fetch.
     */
    where: mis_usersWhereUniqueInput
  }


  /**
   * mis_users findFirst
   */
  export type mis_usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mis_users
     */
    select?: mis_usersSelect<ExtArgs> | null
    /**
     * Filter, which mis_users to fetch.
     */
    where?: mis_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mis_users to fetch.
     */
    orderBy?: mis_usersOrderByWithRelationInput | mis_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mis_users.
     */
    cursor?: mis_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mis_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mis_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mis_users.
     */
    distinct?: Mis_usersScalarFieldEnum | Mis_usersScalarFieldEnum[]
  }


  /**
   * mis_users findFirstOrThrow
   */
  export type mis_usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mis_users
     */
    select?: mis_usersSelect<ExtArgs> | null
    /**
     * Filter, which mis_users to fetch.
     */
    where?: mis_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mis_users to fetch.
     */
    orderBy?: mis_usersOrderByWithRelationInput | mis_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mis_users.
     */
    cursor?: mis_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mis_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mis_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mis_users.
     */
    distinct?: Mis_usersScalarFieldEnum | Mis_usersScalarFieldEnum[]
  }


  /**
   * mis_users findMany
   */
  export type mis_usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mis_users
     */
    select?: mis_usersSelect<ExtArgs> | null
    /**
     * Filter, which mis_users to fetch.
     */
    where?: mis_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mis_users to fetch.
     */
    orderBy?: mis_usersOrderByWithRelationInput | mis_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mis_users.
     */
    cursor?: mis_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mis_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mis_users.
     */
    skip?: number
    distinct?: Mis_usersScalarFieldEnum | Mis_usersScalarFieldEnum[]
  }


  /**
   * mis_users create
   */
  export type mis_usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mis_users
     */
    select?: mis_usersSelect<ExtArgs> | null
    /**
     * The data needed to create a mis_users.
     */
    data: XOR<mis_usersCreateInput, mis_usersUncheckedCreateInput>
  }


  /**
   * mis_users createMany
   */
  export type mis_usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mis_users.
     */
    data: mis_usersCreateManyInput | mis_usersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * mis_users update
   */
  export type mis_usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mis_users
     */
    select?: mis_usersSelect<ExtArgs> | null
    /**
     * The data needed to update a mis_users.
     */
    data: XOR<mis_usersUpdateInput, mis_usersUncheckedUpdateInput>
    /**
     * Choose, which mis_users to update.
     */
    where: mis_usersWhereUniqueInput
  }


  /**
   * mis_users updateMany
   */
  export type mis_usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mis_users.
     */
    data: XOR<mis_usersUpdateManyMutationInput, mis_usersUncheckedUpdateManyInput>
    /**
     * Filter which mis_users to update
     */
    where?: mis_usersWhereInput
  }


  /**
   * mis_users upsert
   */
  export type mis_usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mis_users
     */
    select?: mis_usersSelect<ExtArgs> | null
    /**
     * The filter to search for the mis_users to update in case it exists.
     */
    where: mis_usersWhereUniqueInput
    /**
     * In case the mis_users found by the `where` argument doesn't exist, create a new mis_users with this data.
     */
    create: XOR<mis_usersCreateInput, mis_usersUncheckedCreateInput>
    /**
     * In case the mis_users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mis_usersUpdateInput, mis_usersUncheckedUpdateInput>
  }


  /**
   * mis_users delete
   */
  export type mis_usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mis_users
     */
    select?: mis_usersSelect<ExtArgs> | null
    /**
     * Filter which mis_users to delete.
     */
    where: mis_usersWhereUniqueInput
  }


  /**
   * mis_users deleteMany
   */
  export type mis_usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mis_users to delete
     */
    where?: mis_usersWhereInput
  }


  /**
   * mis_users without action
   */
  export type mis_usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mis_users
     */
    select?: mis_usersSelect<ExtArgs> | null
  }



  /**
   * Model monthly_folders
   */

  export type AggregateMonthly_folders = {
    _count: Monthly_foldersCountAggregateOutputType | null
    _avg: Monthly_foldersAvgAggregateOutputType | null
    _sum: Monthly_foldersSumAggregateOutputType | null
    _min: Monthly_foldersMinAggregateOutputType | null
    _max: Monthly_foldersMaxAggregateOutputType | null
  }

  export type Monthly_foldersAvgAggregateOutputType = {
    folder_id: number | null
    deletable: number | null
  }

  export type Monthly_foldersSumAggregateOutputType = {
    folder_id: number | null
    deletable: number | null
  }

  export type Monthly_foldersMinAggregateOutputType = {
    folder_id: number | null
    folder_name: string | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Monthly_foldersMaxAggregateOutputType = {
    folder_id: number | null
    folder_name: string | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Monthly_foldersCountAggregateOutputType = {
    folder_id: number
    folder_name: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Monthly_foldersAvgAggregateInputType = {
    folder_id?: true
    deletable?: true
  }

  export type Monthly_foldersSumAggregateInputType = {
    folder_id?: true
    deletable?: true
  }

  export type Monthly_foldersMinAggregateInputType = {
    folder_id?: true
    folder_name?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Monthly_foldersMaxAggregateInputType = {
    folder_id?: true
    folder_name?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type Monthly_foldersCountAggregateInputType = {
    folder_id?: true
    folder_name?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Monthly_foldersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monthly_folders to aggregate.
     */
    where?: monthly_foldersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monthly_folders to fetch.
     */
    orderBy?: monthly_foldersOrderByWithRelationInput | monthly_foldersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: monthly_foldersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monthly_folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monthly_folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned monthly_folders
    **/
    _count?: true | Monthly_foldersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Monthly_foldersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Monthly_foldersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Monthly_foldersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Monthly_foldersMaxAggregateInputType
  }

  export type GetMonthly_foldersAggregateType<T extends Monthly_foldersAggregateArgs> = {
        [P in keyof T & keyof AggregateMonthly_folders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonthly_folders[P]>
      : GetScalarType<T[P], AggregateMonthly_folders[P]>
  }




  export type monthly_foldersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: monthly_foldersWhereInput
    orderBy?: monthly_foldersOrderByWithAggregationInput | monthly_foldersOrderByWithAggregationInput[]
    by: Monthly_foldersScalarFieldEnum[] | Monthly_foldersScalarFieldEnum
    having?: monthly_foldersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Monthly_foldersCountAggregateInputType | true
    _avg?: Monthly_foldersAvgAggregateInputType
    _sum?: Monthly_foldersSumAggregateInputType
    _min?: Monthly_foldersMinAggregateInputType
    _max?: Monthly_foldersMaxAggregateInputType
  }

  export type Monthly_foldersGroupByOutputType = {
    folder_id: number
    folder_name: string
    deletable: number
    created_at: Date | null
    updated_at: Date | null
    _count: Monthly_foldersCountAggregateOutputType | null
    _avg: Monthly_foldersAvgAggregateOutputType | null
    _sum: Monthly_foldersSumAggregateOutputType | null
    _min: Monthly_foldersMinAggregateOutputType | null
    _max: Monthly_foldersMaxAggregateOutputType | null
  }

  type GetMonthly_foldersGroupByPayload<T extends monthly_foldersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Monthly_foldersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Monthly_foldersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Monthly_foldersGroupByOutputType[P]>
            : GetScalarType<T[P], Monthly_foldersGroupByOutputType[P]>
        }
      >
    >


  export type monthly_foldersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    folder_id?: boolean
    folder_name?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["monthly_folders"]>

  export type monthly_foldersSelectScalar = {
    folder_id?: boolean
    folder_name?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $monthly_foldersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "monthly_folders"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      folder_id: number
      folder_name: string
      deletable: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["monthly_folders"]>
    composites: {}
  }


  type monthly_foldersGetPayload<S extends boolean | null | undefined | monthly_foldersDefaultArgs> = $Result.GetResult<Prisma.$monthly_foldersPayload, S>

  type monthly_foldersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<monthly_foldersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Monthly_foldersCountAggregateInputType | true
    }

  export interface monthly_foldersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['monthly_folders'], meta: { name: 'monthly_folders' } }
    /**
     * Find zero or one Monthly_folders that matches the filter.
     * @param {monthly_foldersFindUniqueArgs} args - Arguments to find a Monthly_folders
     * @example
     * // Get one Monthly_folders
     * const monthly_folders = await prisma.monthly_folders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends monthly_foldersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, monthly_foldersFindUniqueArgs<ExtArgs>>
    ): Prisma__monthly_foldersClient<$Result.GetResult<Prisma.$monthly_foldersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Monthly_folders that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {monthly_foldersFindUniqueOrThrowArgs} args - Arguments to find a Monthly_folders
     * @example
     * // Get one Monthly_folders
     * const monthly_folders = await prisma.monthly_folders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends monthly_foldersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, monthly_foldersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__monthly_foldersClient<$Result.GetResult<Prisma.$monthly_foldersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Monthly_folders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monthly_foldersFindFirstArgs} args - Arguments to find a Monthly_folders
     * @example
     * // Get one Monthly_folders
     * const monthly_folders = await prisma.monthly_folders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends monthly_foldersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, monthly_foldersFindFirstArgs<ExtArgs>>
    ): Prisma__monthly_foldersClient<$Result.GetResult<Prisma.$monthly_foldersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Monthly_folders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monthly_foldersFindFirstOrThrowArgs} args - Arguments to find a Monthly_folders
     * @example
     * // Get one Monthly_folders
     * const monthly_folders = await prisma.monthly_folders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends monthly_foldersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, monthly_foldersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__monthly_foldersClient<$Result.GetResult<Prisma.$monthly_foldersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Monthly_folders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monthly_foldersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Monthly_folders
     * const monthly_folders = await prisma.monthly_folders.findMany()
     * 
     * // Get first 10 Monthly_folders
     * const monthly_folders = await prisma.monthly_folders.findMany({ take: 10 })
     * 
     * // Only select the `folder_id`
     * const monthly_foldersWithFolder_idOnly = await prisma.monthly_folders.findMany({ select: { folder_id: true } })
     * 
    **/
    findMany<T extends monthly_foldersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, monthly_foldersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$monthly_foldersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Monthly_folders.
     * @param {monthly_foldersCreateArgs} args - Arguments to create a Monthly_folders.
     * @example
     * // Create one Monthly_folders
     * const Monthly_folders = await prisma.monthly_folders.create({
     *   data: {
     *     // ... data to create a Monthly_folders
     *   }
     * })
     * 
    **/
    create<T extends monthly_foldersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, monthly_foldersCreateArgs<ExtArgs>>
    ): Prisma__monthly_foldersClient<$Result.GetResult<Prisma.$monthly_foldersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Monthly_folders.
     *     @param {monthly_foldersCreateManyArgs} args - Arguments to create many Monthly_folders.
     *     @example
     *     // Create many Monthly_folders
     *     const monthly_folders = await prisma.monthly_folders.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends monthly_foldersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, monthly_foldersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Monthly_folders.
     * @param {monthly_foldersDeleteArgs} args - Arguments to delete one Monthly_folders.
     * @example
     * // Delete one Monthly_folders
     * const Monthly_folders = await prisma.monthly_folders.delete({
     *   where: {
     *     // ... filter to delete one Monthly_folders
     *   }
     * })
     * 
    **/
    delete<T extends monthly_foldersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, monthly_foldersDeleteArgs<ExtArgs>>
    ): Prisma__monthly_foldersClient<$Result.GetResult<Prisma.$monthly_foldersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Monthly_folders.
     * @param {monthly_foldersUpdateArgs} args - Arguments to update one Monthly_folders.
     * @example
     * // Update one Monthly_folders
     * const monthly_folders = await prisma.monthly_folders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends monthly_foldersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, monthly_foldersUpdateArgs<ExtArgs>>
    ): Prisma__monthly_foldersClient<$Result.GetResult<Prisma.$monthly_foldersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Monthly_folders.
     * @param {monthly_foldersDeleteManyArgs} args - Arguments to filter Monthly_folders to delete.
     * @example
     * // Delete a few Monthly_folders
     * const { count } = await prisma.monthly_folders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends monthly_foldersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, monthly_foldersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Monthly_folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monthly_foldersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Monthly_folders
     * const monthly_folders = await prisma.monthly_folders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends monthly_foldersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, monthly_foldersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Monthly_folders.
     * @param {monthly_foldersUpsertArgs} args - Arguments to update or create a Monthly_folders.
     * @example
     * // Update or create a Monthly_folders
     * const monthly_folders = await prisma.monthly_folders.upsert({
     *   create: {
     *     // ... data to create a Monthly_folders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Monthly_folders we want to update
     *   }
     * })
    **/
    upsert<T extends monthly_foldersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, monthly_foldersUpsertArgs<ExtArgs>>
    ): Prisma__monthly_foldersClient<$Result.GetResult<Prisma.$monthly_foldersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Monthly_folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monthly_foldersCountArgs} args - Arguments to filter Monthly_folders to count.
     * @example
     * // Count the number of Monthly_folders
     * const count = await prisma.monthly_folders.count({
     *   where: {
     *     // ... the filter for the Monthly_folders we want to count
     *   }
     * })
    **/
    count<T extends monthly_foldersCountArgs>(
      args?: Subset<T, monthly_foldersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Monthly_foldersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Monthly_folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monthly_foldersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Monthly_foldersAggregateArgs>(args: Subset<T, Monthly_foldersAggregateArgs>): Prisma.PrismaPromise<GetMonthly_foldersAggregateType<T>>

    /**
     * Group by Monthly_folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monthly_foldersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends monthly_foldersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: monthly_foldersGroupByArgs['orderBy'] }
        : { orderBy?: monthly_foldersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, monthly_foldersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonthly_foldersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the monthly_folders model
   */
  readonly fields: monthly_foldersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for monthly_folders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__monthly_foldersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the monthly_folders model
   */ 
  interface monthly_foldersFieldRefs {
    readonly folder_id: FieldRef<"monthly_folders", 'Int'>
    readonly folder_name: FieldRef<"monthly_folders", 'String'>
    readonly deletable: FieldRef<"monthly_folders", 'Int'>
    readonly created_at: FieldRef<"monthly_folders", 'DateTime'>
    readonly updated_at: FieldRef<"monthly_folders", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * monthly_folders findUnique
   */
  export type monthly_foldersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthly_folders
     */
    select?: monthly_foldersSelect<ExtArgs> | null
    /**
     * Filter, which monthly_folders to fetch.
     */
    where: monthly_foldersWhereUniqueInput
  }


  /**
   * monthly_folders findUniqueOrThrow
   */
  export type monthly_foldersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthly_folders
     */
    select?: monthly_foldersSelect<ExtArgs> | null
    /**
     * Filter, which monthly_folders to fetch.
     */
    where: monthly_foldersWhereUniqueInput
  }


  /**
   * monthly_folders findFirst
   */
  export type monthly_foldersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthly_folders
     */
    select?: monthly_foldersSelect<ExtArgs> | null
    /**
     * Filter, which monthly_folders to fetch.
     */
    where?: monthly_foldersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monthly_folders to fetch.
     */
    orderBy?: monthly_foldersOrderByWithRelationInput | monthly_foldersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monthly_folders.
     */
    cursor?: monthly_foldersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monthly_folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monthly_folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monthly_folders.
     */
    distinct?: Monthly_foldersScalarFieldEnum | Monthly_foldersScalarFieldEnum[]
  }


  /**
   * monthly_folders findFirstOrThrow
   */
  export type monthly_foldersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthly_folders
     */
    select?: monthly_foldersSelect<ExtArgs> | null
    /**
     * Filter, which monthly_folders to fetch.
     */
    where?: monthly_foldersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monthly_folders to fetch.
     */
    orderBy?: monthly_foldersOrderByWithRelationInput | monthly_foldersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monthly_folders.
     */
    cursor?: monthly_foldersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monthly_folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monthly_folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monthly_folders.
     */
    distinct?: Monthly_foldersScalarFieldEnum | Monthly_foldersScalarFieldEnum[]
  }


  /**
   * monthly_folders findMany
   */
  export type monthly_foldersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthly_folders
     */
    select?: monthly_foldersSelect<ExtArgs> | null
    /**
     * Filter, which monthly_folders to fetch.
     */
    where?: monthly_foldersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monthly_folders to fetch.
     */
    orderBy?: monthly_foldersOrderByWithRelationInput | monthly_foldersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing monthly_folders.
     */
    cursor?: monthly_foldersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monthly_folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monthly_folders.
     */
    skip?: number
    distinct?: Monthly_foldersScalarFieldEnum | Monthly_foldersScalarFieldEnum[]
  }


  /**
   * monthly_folders create
   */
  export type monthly_foldersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthly_folders
     */
    select?: monthly_foldersSelect<ExtArgs> | null
    /**
     * The data needed to create a monthly_folders.
     */
    data: XOR<monthly_foldersCreateInput, monthly_foldersUncheckedCreateInput>
  }


  /**
   * monthly_folders createMany
   */
  export type monthly_foldersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many monthly_folders.
     */
    data: monthly_foldersCreateManyInput | monthly_foldersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * monthly_folders update
   */
  export type monthly_foldersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthly_folders
     */
    select?: monthly_foldersSelect<ExtArgs> | null
    /**
     * The data needed to update a monthly_folders.
     */
    data: XOR<monthly_foldersUpdateInput, monthly_foldersUncheckedUpdateInput>
    /**
     * Choose, which monthly_folders to update.
     */
    where: monthly_foldersWhereUniqueInput
  }


  /**
   * monthly_folders updateMany
   */
  export type monthly_foldersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update monthly_folders.
     */
    data: XOR<monthly_foldersUpdateManyMutationInput, monthly_foldersUncheckedUpdateManyInput>
    /**
     * Filter which monthly_folders to update
     */
    where?: monthly_foldersWhereInput
  }


  /**
   * monthly_folders upsert
   */
  export type monthly_foldersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthly_folders
     */
    select?: monthly_foldersSelect<ExtArgs> | null
    /**
     * The filter to search for the monthly_folders to update in case it exists.
     */
    where: monthly_foldersWhereUniqueInput
    /**
     * In case the monthly_folders found by the `where` argument doesn't exist, create a new monthly_folders with this data.
     */
    create: XOR<monthly_foldersCreateInput, monthly_foldersUncheckedCreateInput>
    /**
     * In case the monthly_folders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<monthly_foldersUpdateInput, monthly_foldersUncheckedUpdateInput>
  }


  /**
   * monthly_folders delete
   */
  export type monthly_foldersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthly_folders
     */
    select?: monthly_foldersSelect<ExtArgs> | null
    /**
     * Filter which monthly_folders to delete.
     */
    where: monthly_foldersWhereUniqueInput
  }


  /**
   * monthly_folders deleteMany
   */
  export type monthly_foldersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monthly_folders to delete
     */
    where?: monthly_foldersWhereInput
  }


  /**
   * monthly_folders without action
   */
  export type monthly_foldersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthly_folders
     */
    select?: monthly_foldersSelect<ExtArgs> | null
  }



  /**
   * Model p_album_positions
   */

  export type AggregateP_album_positions = {
    _count: P_album_positionsCountAggregateOutputType | null
    _avg: P_album_positionsAvgAggregateOutputType | null
    _sum: P_album_positionsSumAggregateOutputType | null
    _min: P_album_positionsMinAggregateOutputType | null
    _max: P_album_positionsMaxAggregateOutputType | null
  }

  export type P_album_positionsAvgAggregateOutputType = {
    position_id: number | null
    cat_id: number | null
    special_cat_id: number | null
    subcat_id: number | null
    total_content: number | null
    status: number | null
    deletable: number | null
  }

  export type P_album_positionsSumAggregateOutputType = {
    position_id: number | null
    cat_id: number | null
    special_cat_id: number | null
    subcat_id: number | null
    total_content: number | null
    status: number | null
    deletable: number | null
  }

  export type P_album_positionsMinAggregateOutputType = {
    position_id: number | null
    position_name: string | null
    position_slug: string | null
    cat_id: number | null
    special_cat_id: number | null
    subcat_id: number | null
    content_ids: string | null
    total_content: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type P_album_positionsMaxAggregateOutputType = {
    position_id: number | null
    position_name: string | null
    position_slug: string | null
    cat_id: number | null
    special_cat_id: number | null
    subcat_id: number | null
    content_ids: string | null
    total_content: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type P_album_positionsCountAggregateOutputType = {
    position_id: number
    position_name: number
    position_slug: number
    cat_id: number
    special_cat_id: number
    subcat_id: number
    content_ids: number
    total_content: number
    status: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type P_album_positionsAvgAggregateInputType = {
    position_id?: true
    cat_id?: true
    special_cat_id?: true
    subcat_id?: true
    total_content?: true
    status?: true
    deletable?: true
  }

  export type P_album_positionsSumAggregateInputType = {
    position_id?: true
    cat_id?: true
    special_cat_id?: true
    subcat_id?: true
    total_content?: true
    status?: true
    deletable?: true
  }

  export type P_album_positionsMinAggregateInputType = {
    position_id?: true
    position_name?: true
    position_slug?: true
    cat_id?: true
    special_cat_id?: true
    subcat_id?: true
    content_ids?: true
    total_content?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type P_album_positionsMaxAggregateInputType = {
    position_id?: true
    position_name?: true
    position_slug?: true
    cat_id?: true
    special_cat_id?: true
    subcat_id?: true
    content_ids?: true
    total_content?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type P_album_positionsCountAggregateInputType = {
    position_id?: true
    position_name?: true
    position_slug?: true
    cat_id?: true
    special_cat_id?: true
    subcat_id?: true
    content_ids?: true
    total_content?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type P_album_positionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p_album_positions to aggregate.
     */
    where?: p_album_positionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p_album_positions to fetch.
     */
    orderBy?: p_album_positionsOrderByWithRelationInput | p_album_positionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: p_album_positionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p_album_positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p_album_positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned p_album_positions
    **/
    _count?: true | P_album_positionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: P_album_positionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: P_album_positionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: P_album_positionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: P_album_positionsMaxAggregateInputType
  }

  export type GetP_album_positionsAggregateType<T extends P_album_positionsAggregateArgs> = {
        [P in keyof T & keyof AggregateP_album_positions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateP_album_positions[P]>
      : GetScalarType<T[P], AggregateP_album_positions[P]>
  }




  export type p_album_positionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p_album_positionsWhereInput
    orderBy?: p_album_positionsOrderByWithAggregationInput | p_album_positionsOrderByWithAggregationInput[]
    by: P_album_positionsScalarFieldEnum[] | P_album_positionsScalarFieldEnum
    having?: p_album_positionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: P_album_positionsCountAggregateInputType | true
    _avg?: P_album_positionsAvgAggregateInputType
    _sum?: P_album_positionsSumAggregateInputType
    _min?: P_album_positionsMinAggregateInputType
    _max?: P_album_positionsMaxAggregateInputType
  }

  export type P_album_positionsGroupByOutputType = {
    position_id: number
    position_name: string
    position_slug: string
    cat_id: number | null
    special_cat_id: number | null
    subcat_id: number | null
    content_ids: string | null
    total_content: number | null
    status: number
    deletable: number
    created_at: Date | null
    updated_at: Date | null
    _count: P_album_positionsCountAggregateOutputType | null
    _avg: P_album_positionsAvgAggregateOutputType | null
    _sum: P_album_positionsSumAggregateOutputType | null
    _min: P_album_positionsMinAggregateOutputType | null
    _max: P_album_positionsMaxAggregateOutputType | null
  }

  type GetP_album_positionsGroupByPayload<T extends p_album_positionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<P_album_positionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof P_album_positionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], P_album_positionsGroupByOutputType[P]>
            : GetScalarType<T[P], P_album_positionsGroupByOutputType[P]>
        }
      >
    >


  export type p_album_positionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    position_id?: boolean
    position_name?: boolean
    position_slug?: boolean
    cat_id?: boolean
    special_cat_id?: boolean
    subcat_id?: boolean
    content_ids?: boolean
    total_content?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["p_album_positions"]>

  export type p_album_positionsSelectScalar = {
    position_id?: boolean
    position_name?: boolean
    position_slug?: boolean
    cat_id?: boolean
    special_cat_id?: boolean
    subcat_id?: boolean
    content_ids?: boolean
    total_content?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $p_album_positionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "p_album_positions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      position_id: number
      position_name: string
      position_slug: string
      cat_id: number | null
      special_cat_id: number | null
      subcat_id: number | null
      content_ids: string | null
      total_content: number | null
      status: number
      deletable: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["p_album_positions"]>
    composites: {}
  }


  type p_album_positionsGetPayload<S extends boolean | null | undefined | p_album_positionsDefaultArgs> = $Result.GetResult<Prisma.$p_album_positionsPayload, S>

  type p_album_positionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<p_album_positionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: P_album_positionsCountAggregateInputType | true
    }

  export interface p_album_positionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['p_album_positions'], meta: { name: 'p_album_positions' } }
    /**
     * Find zero or one P_album_positions that matches the filter.
     * @param {p_album_positionsFindUniqueArgs} args - Arguments to find a P_album_positions
     * @example
     * // Get one P_album_positions
     * const p_album_positions = await prisma.p_album_positions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends p_album_positionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, p_album_positionsFindUniqueArgs<ExtArgs>>
    ): Prisma__p_album_positionsClient<$Result.GetResult<Prisma.$p_album_positionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one P_album_positions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {p_album_positionsFindUniqueOrThrowArgs} args - Arguments to find a P_album_positions
     * @example
     * // Get one P_album_positions
     * const p_album_positions = await prisma.p_album_positions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends p_album_positionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, p_album_positionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__p_album_positionsClient<$Result.GetResult<Prisma.$p_album_positionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first P_album_positions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_album_positionsFindFirstArgs} args - Arguments to find a P_album_positions
     * @example
     * // Get one P_album_positions
     * const p_album_positions = await prisma.p_album_positions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends p_album_positionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, p_album_positionsFindFirstArgs<ExtArgs>>
    ): Prisma__p_album_positionsClient<$Result.GetResult<Prisma.$p_album_positionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first P_album_positions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_album_positionsFindFirstOrThrowArgs} args - Arguments to find a P_album_positions
     * @example
     * // Get one P_album_positions
     * const p_album_positions = await prisma.p_album_positions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends p_album_positionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, p_album_positionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__p_album_positionsClient<$Result.GetResult<Prisma.$p_album_positionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more P_album_positions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_album_positionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all P_album_positions
     * const p_album_positions = await prisma.p_album_positions.findMany()
     * 
     * // Get first 10 P_album_positions
     * const p_album_positions = await prisma.p_album_positions.findMany({ take: 10 })
     * 
     * // Only select the `position_id`
     * const p_album_positionsWithPosition_idOnly = await prisma.p_album_positions.findMany({ select: { position_id: true } })
     * 
    **/
    findMany<T extends p_album_positionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, p_album_positionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p_album_positionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a P_album_positions.
     * @param {p_album_positionsCreateArgs} args - Arguments to create a P_album_positions.
     * @example
     * // Create one P_album_positions
     * const P_album_positions = await prisma.p_album_positions.create({
     *   data: {
     *     // ... data to create a P_album_positions
     *   }
     * })
     * 
    **/
    create<T extends p_album_positionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, p_album_positionsCreateArgs<ExtArgs>>
    ): Prisma__p_album_positionsClient<$Result.GetResult<Prisma.$p_album_positionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many P_album_positions.
     *     @param {p_album_positionsCreateManyArgs} args - Arguments to create many P_album_positions.
     *     @example
     *     // Create many P_album_positions
     *     const p_album_positions = await prisma.p_album_positions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends p_album_positionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, p_album_positionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a P_album_positions.
     * @param {p_album_positionsDeleteArgs} args - Arguments to delete one P_album_positions.
     * @example
     * // Delete one P_album_positions
     * const P_album_positions = await prisma.p_album_positions.delete({
     *   where: {
     *     // ... filter to delete one P_album_positions
     *   }
     * })
     * 
    **/
    delete<T extends p_album_positionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, p_album_positionsDeleteArgs<ExtArgs>>
    ): Prisma__p_album_positionsClient<$Result.GetResult<Prisma.$p_album_positionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one P_album_positions.
     * @param {p_album_positionsUpdateArgs} args - Arguments to update one P_album_positions.
     * @example
     * // Update one P_album_positions
     * const p_album_positions = await prisma.p_album_positions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends p_album_positionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, p_album_positionsUpdateArgs<ExtArgs>>
    ): Prisma__p_album_positionsClient<$Result.GetResult<Prisma.$p_album_positionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more P_album_positions.
     * @param {p_album_positionsDeleteManyArgs} args - Arguments to filter P_album_positions to delete.
     * @example
     * // Delete a few P_album_positions
     * const { count } = await prisma.p_album_positions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends p_album_positionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, p_album_positionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more P_album_positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_album_positionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many P_album_positions
     * const p_album_positions = await prisma.p_album_positions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends p_album_positionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, p_album_positionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one P_album_positions.
     * @param {p_album_positionsUpsertArgs} args - Arguments to update or create a P_album_positions.
     * @example
     * // Update or create a P_album_positions
     * const p_album_positions = await prisma.p_album_positions.upsert({
     *   create: {
     *     // ... data to create a P_album_positions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the P_album_positions we want to update
     *   }
     * })
    **/
    upsert<T extends p_album_positionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, p_album_positionsUpsertArgs<ExtArgs>>
    ): Prisma__p_album_positionsClient<$Result.GetResult<Prisma.$p_album_positionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of P_album_positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_album_positionsCountArgs} args - Arguments to filter P_album_positions to count.
     * @example
     * // Count the number of P_album_positions
     * const count = await prisma.p_album_positions.count({
     *   where: {
     *     // ... the filter for the P_album_positions we want to count
     *   }
     * })
    **/
    count<T extends p_album_positionsCountArgs>(
      args?: Subset<T, p_album_positionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], P_album_positionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a P_album_positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {P_album_positionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends P_album_positionsAggregateArgs>(args: Subset<T, P_album_positionsAggregateArgs>): Prisma.PrismaPromise<GetP_album_positionsAggregateType<T>>

    /**
     * Group by P_album_positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_album_positionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends p_album_positionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: p_album_positionsGroupByArgs['orderBy'] }
        : { orderBy?: p_album_positionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, p_album_positionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetP_album_positionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the p_album_positions model
   */
  readonly fields: p_album_positionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for p_album_positions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__p_album_positionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the p_album_positions model
   */ 
  interface p_album_positionsFieldRefs {
    readonly position_id: FieldRef<"p_album_positions", 'Int'>
    readonly position_name: FieldRef<"p_album_positions", 'String'>
    readonly position_slug: FieldRef<"p_album_positions", 'String'>
    readonly cat_id: FieldRef<"p_album_positions", 'Int'>
    readonly special_cat_id: FieldRef<"p_album_positions", 'Int'>
    readonly subcat_id: FieldRef<"p_album_positions", 'Int'>
    readonly content_ids: FieldRef<"p_album_positions", 'String'>
    readonly total_content: FieldRef<"p_album_positions", 'Int'>
    readonly status: FieldRef<"p_album_positions", 'Int'>
    readonly deletable: FieldRef<"p_album_positions", 'Int'>
    readonly created_at: FieldRef<"p_album_positions", 'DateTime'>
    readonly updated_at: FieldRef<"p_album_positions", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * p_album_positions findUnique
   */
  export type p_album_positionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_album_positions
     */
    select?: p_album_positionsSelect<ExtArgs> | null
    /**
     * Filter, which p_album_positions to fetch.
     */
    where: p_album_positionsWhereUniqueInput
  }


  /**
   * p_album_positions findUniqueOrThrow
   */
  export type p_album_positionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_album_positions
     */
    select?: p_album_positionsSelect<ExtArgs> | null
    /**
     * Filter, which p_album_positions to fetch.
     */
    where: p_album_positionsWhereUniqueInput
  }


  /**
   * p_album_positions findFirst
   */
  export type p_album_positionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_album_positions
     */
    select?: p_album_positionsSelect<ExtArgs> | null
    /**
     * Filter, which p_album_positions to fetch.
     */
    where?: p_album_positionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p_album_positions to fetch.
     */
    orderBy?: p_album_positionsOrderByWithRelationInput | p_album_positionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p_album_positions.
     */
    cursor?: p_album_positionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p_album_positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p_album_positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p_album_positions.
     */
    distinct?: P_album_positionsScalarFieldEnum | P_album_positionsScalarFieldEnum[]
  }


  /**
   * p_album_positions findFirstOrThrow
   */
  export type p_album_positionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_album_positions
     */
    select?: p_album_positionsSelect<ExtArgs> | null
    /**
     * Filter, which p_album_positions to fetch.
     */
    where?: p_album_positionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p_album_positions to fetch.
     */
    orderBy?: p_album_positionsOrderByWithRelationInput | p_album_positionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p_album_positions.
     */
    cursor?: p_album_positionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p_album_positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p_album_positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p_album_positions.
     */
    distinct?: P_album_positionsScalarFieldEnum | P_album_positionsScalarFieldEnum[]
  }


  /**
   * p_album_positions findMany
   */
  export type p_album_positionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_album_positions
     */
    select?: p_album_positionsSelect<ExtArgs> | null
    /**
     * Filter, which p_album_positions to fetch.
     */
    where?: p_album_positionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p_album_positions to fetch.
     */
    orderBy?: p_album_positionsOrderByWithRelationInput | p_album_positionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing p_album_positions.
     */
    cursor?: p_album_positionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p_album_positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p_album_positions.
     */
    skip?: number
    distinct?: P_album_positionsScalarFieldEnum | P_album_positionsScalarFieldEnum[]
  }


  /**
   * p_album_positions create
   */
  export type p_album_positionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_album_positions
     */
    select?: p_album_positionsSelect<ExtArgs> | null
    /**
     * The data needed to create a p_album_positions.
     */
    data: XOR<p_album_positionsCreateInput, p_album_positionsUncheckedCreateInput>
  }


  /**
   * p_album_positions createMany
   */
  export type p_album_positionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many p_album_positions.
     */
    data: p_album_positionsCreateManyInput | p_album_positionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * p_album_positions update
   */
  export type p_album_positionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_album_positions
     */
    select?: p_album_positionsSelect<ExtArgs> | null
    /**
     * The data needed to update a p_album_positions.
     */
    data: XOR<p_album_positionsUpdateInput, p_album_positionsUncheckedUpdateInput>
    /**
     * Choose, which p_album_positions to update.
     */
    where: p_album_positionsWhereUniqueInput
  }


  /**
   * p_album_positions updateMany
   */
  export type p_album_positionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update p_album_positions.
     */
    data: XOR<p_album_positionsUpdateManyMutationInput, p_album_positionsUncheckedUpdateManyInput>
    /**
     * Filter which p_album_positions to update
     */
    where?: p_album_positionsWhereInput
  }


  /**
   * p_album_positions upsert
   */
  export type p_album_positionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_album_positions
     */
    select?: p_album_positionsSelect<ExtArgs> | null
    /**
     * The filter to search for the p_album_positions to update in case it exists.
     */
    where: p_album_positionsWhereUniqueInput
    /**
     * In case the p_album_positions found by the `where` argument doesn't exist, create a new p_album_positions with this data.
     */
    create: XOR<p_album_positionsCreateInput, p_album_positionsUncheckedCreateInput>
    /**
     * In case the p_album_positions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<p_album_positionsUpdateInput, p_album_positionsUncheckedUpdateInput>
  }


  /**
   * p_album_positions delete
   */
  export type p_album_positionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_album_positions
     */
    select?: p_album_positionsSelect<ExtArgs> | null
    /**
     * Filter which p_album_positions to delete.
     */
    where: p_album_positionsWhereUniqueInput
  }


  /**
   * p_album_positions deleteMany
   */
  export type p_album_positionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p_album_positions to delete
     */
    where?: p_album_positionsWhereInput
  }


  /**
   * p_album_positions without action
   */
  export type p_album_positionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_album_positions
     */
    select?: p_album_positionsSelect<ExtArgs> | null
  }



  /**
   * Model p_albums
   */

  export type AggregateP_albums = {
    _count: P_albumsCountAggregateOutputType | null
    _avg: P_albumsAvgAggregateOutputType | null
    _sum: P_albumsSumAggregateOutputType | null
    _min: P_albumsMinAggregateOutputType | null
    _max: P_albumsMaxAggregateOutputType | null
  }

  export type P_albumsAvgAggregateOutputType = {
    album_id: number | null
    cat_id: number | null
    subcat_id: number | null
    status: number | null
    total_hit: number | null
    deletable: number | null
    user_id: number | null
  }

  export type P_albumsSumAggregateOutputType = {
    album_id: number | null
    cat_id: number | null
    subcat_id: number | null
    status: number | null
    total_hit: number | null
    deletable: number | null
    user_id: number | null
  }

  export type P_albumsMinAggregateOutputType = {
    album_id: number | null
    cat_id: number | null
    subcat_id: number | null
    album_name: string | null
    short_description: string | null
    album_details: string | null
    photographer_name: string | null
    tag: string | null
    status: number | null
    total_hit: number | null
    deletable: number | null
    user_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type P_albumsMaxAggregateOutputType = {
    album_id: number | null
    cat_id: number | null
    subcat_id: number | null
    album_name: string | null
    short_description: string | null
    album_details: string | null
    photographer_name: string | null
    tag: string | null
    status: number | null
    total_hit: number | null
    deletable: number | null
    user_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type P_albumsCountAggregateOutputType = {
    album_id: number
    cat_id: number
    subcat_id: number
    album_name: number
    short_description: number
    album_details: number
    photographer_name: number
    tag: number
    status: number
    total_hit: number
    deletable: number
    user_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type P_albumsAvgAggregateInputType = {
    album_id?: true
    cat_id?: true
    subcat_id?: true
    status?: true
    total_hit?: true
    deletable?: true
    user_id?: true
  }

  export type P_albumsSumAggregateInputType = {
    album_id?: true
    cat_id?: true
    subcat_id?: true
    status?: true
    total_hit?: true
    deletable?: true
    user_id?: true
  }

  export type P_albumsMinAggregateInputType = {
    album_id?: true
    cat_id?: true
    subcat_id?: true
    album_name?: true
    short_description?: true
    album_details?: true
    photographer_name?: true
    tag?: true
    status?: true
    total_hit?: true
    deletable?: true
    user_id?: true
    created_at?: true
    updated_at?: true
  }

  export type P_albumsMaxAggregateInputType = {
    album_id?: true
    cat_id?: true
    subcat_id?: true
    album_name?: true
    short_description?: true
    album_details?: true
    photographer_name?: true
    tag?: true
    status?: true
    total_hit?: true
    deletable?: true
    user_id?: true
    created_at?: true
    updated_at?: true
  }

  export type P_albumsCountAggregateInputType = {
    album_id?: true
    cat_id?: true
    subcat_id?: true
    album_name?: true
    short_description?: true
    album_details?: true
    photographer_name?: true
    tag?: true
    status?: true
    total_hit?: true
    deletable?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type P_albumsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p_albums to aggregate.
     */
    where?: p_albumsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p_albums to fetch.
     */
    orderBy?: p_albumsOrderByWithRelationInput | p_albumsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: p_albumsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p_albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p_albums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned p_albums
    **/
    _count?: true | P_albumsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: P_albumsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: P_albumsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: P_albumsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: P_albumsMaxAggregateInputType
  }

  export type GetP_albumsAggregateType<T extends P_albumsAggregateArgs> = {
        [P in keyof T & keyof AggregateP_albums]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateP_albums[P]>
      : GetScalarType<T[P], AggregateP_albums[P]>
  }




  export type p_albumsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p_albumsWhereInput
    orderBy?: p_albumsOrderByWithAggregationInput | p_albumsOrderByWithAggregationInput[]
    by: P_albumsScalarFieldEnum[] | P_albumsScalarFieldEnum
    having?: p_albumsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: P_albumsCountAggregateInputType | true
    _avg?: P_albumsAvgAggregateInputType
    _sum?: P_albumsSumAggregateInputType
    _min?: P_albumsMinAggregateInputType
    _max?: P_albumsMaxAggregateInputType
  }

  export type P_albumsGroupByOutputType = {
    album_id: number
    cat_id: number
    subcat_id: number | null
    album_name: string
    short_description: string | null
    album_details: string | null
    photographer_name: string | null
    tag: string | null
    status: number
    total_hit: number
    deletable: number
    user_id: number
    created_at: Date | null
    updated_at: Date | null
    _count: P_albumsCountAggregateOutputType | null
    _avg: P_albumsAvgAggregateOutputType | null
    _sum: P_albumsSumAggregateOutputType | null
    _min: P_albumsMinAggregateOutputType | null
    _max: P_albumsMaxAggregateOutputType | null
  }

  type GetP_albumsGroupByPayload<T extends p_albumsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<P_albumsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof P_albumsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], P_albumsGroupByOutputType[P]>
            : GetScalarType<T[P], P_albumsGroupByOutputType[P]>
        }
      >
    >


  export type p_albumsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    album_id?: boolean
    cat_id?: boolean
    subcat_id?: boolean
    album_name?: boolean
    short_description?: boolean
    album_details?: boolean
    photographer_name?: boolean
    tag?: boolean
    status?: boolean
    total_hit?: boolean
    deletable?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["p_albums"]>

  export type p_albumsSelectScalar = {
    album_id?: boolean
    cat_id?: boolean
    subcat_id?: boolean
    album_name?: boolean
    short_description?: boolean
    album_details?: boolean
    photographer_name?: boolean
    tag?: boolean
    status?: boolean
    total_hit?: boolean
    deletable?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $p_albumsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "p_albums"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      album_id: number
      cat_id: number
      subcat_id: number | null
      album_name: string
      short_description: string | null
      album_details: string | null
      photographer_name: string | null
      tag: string | null
      status: number
      total_hit: number
      deletable: number
      user_id: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["p_albums"]>
    composites: {}
  }


  type p_albumsGetPayload<S extends boolean | null | undefined | p_albumsDefaultArgs> = $Result.GetResult<Prisma.$p_albumsPayload, S>

  type p_albumsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<p_albumsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: P_albumsCountAggregateInputType | true
    }

  export interface p_albumsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['p_albums'], meta: { name: 'p_albums' } }
    /**
     * Find zero or one P_albums that matches the filter.
     * @param {p_albumsFindUniqueArgs} args - Arguments to find a P_albums
     * @example
     * // Get one P_albums
     * const p_albums = await prisma.p_albums.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends p_albumsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, p_albumsFindUniqueArgs<ExtArgs>>
    ): Prisma__p_albumsClient<$Result.GetResult<Prisma.$p_albumsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one P_albums that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {p_albumsFindUniqueOrThrowArgs} args - Arguments to find a P_albums
     * @example
     * // Get one P_albums
     * const p_albums = await prisma.p_albums.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends p_albumsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, p_albumsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__p_albumsClient<$Result.GetResult<Prisma.$p_albumsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first P_albums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_albumsFindFirstArgs} args - Arguments to find a P_albums
     * @example
     * // Get one P_albums
     * const p_albums = await prisma.p_albums.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends p_albumsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, p_albumsFindFirstArgs<ExtArgs>>
    ): Prisma__p_albumsClient<$Result.GetResult<Prisma.$p_albumsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first P_albums that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_albumsFindFirstOrThrowArgs} args - Arguments to find a P_albums
     * @example
     * // Get one P_albums
     * const p_albums = await prisma.p_albums.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends p_albumsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, p_albumsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__p_albumsClient<$Result.GetResult<Prisma.$p_albumsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more P_albums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_albumsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all P_albums
     * const p_albums = await prisma.p_albums.findMany()
     * 
     * // Get first 10 P_albums
     * const p_albums = await prisma.p_albums.findMany({ take: 10 })
     * 
     * // Only select the `album_id`
     * const p_albumsWithAlbum_idOnly = await prisma.p_albums.findMany({ select: { album_id: true } })
     * 
    **/
    findMany<T extends p_albumsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, p_albumsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p_albumsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a P_albums.
     * @param {p_albumsCreateArgs} args - Arguments to create a P_albums.
     * @example
     * // Create one P_albums
     * const P_albums = await prisma.p_albums.create({
     *   data: {
     *     // ... data to create a P_albums
     *   }
     * })
     * 
    **/
    create<T extends p_albumsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, p_albumsCreateArgs<ExtArgs>>
    ): Prisma__p_albumsClient<$Result.GetResult<Prisma.$p_albumsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many P_albums.
     *     @param {p_albumsCreateManyArgs} args - Arguments to create many P_albums.
     *     @example
     *     // Create many P_albums
     *     const p_albums = await prisma.p_albums.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends p_albumsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, p_albumsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a P_albums.
     * @param {p_albumsDeleteArgs} args - Arguments to delete one P_albums.
     * @example
     * // Delete one P_albums
     * const P_albums = await prisma.p_albums.delete({
     *   where: {
     *     // ... filter to delete one P_albums
     *   }
     * })
     * 
    **/
    delete<T extends p_albumsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, p_albumsDeleteArgs<ExtArgs>>
    ): Prisma__p_albumsClient<$Result.GetResult<Prisma.$p_albumsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one P_albums.
     * @param {p_albumsUpdateArgs} args - Arguments to update one P_albums.
     * @example
     * // Update one P_albums
     * const p_albums = await prisma.p_albums.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends p_albumsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, p_albumsUpdateArgs<ExtArgs>>
    ): Prisma__p_albumsClient<$Result.GetResult<Prisma.$p_albumsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more P_albums.
     * @param {p_albumsDeleteManyArgs} args - Arguments to filter P_albums to delete.
     * @example
     * // Delete a few P_albums
     * const { count } = await prisma.p_albums.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends p_albumsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, p_albumsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more P_albums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_albumsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many P_albums
     * const p_albums = await prisma.p_albums.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends p_albumsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, p_albumsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one P_albums.
     * @param {p_albumsUpsertArgs} args - Arguments to update or create a P_albums.
     * @example
     * // Update or create a P_albums
     * const p_albums = await prisma.p_albums.upsert({
     *   create: {
     *     // ... data to create a P_albums
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the P_albums we want to update
     *   }
     * })
    **/
    upsert<T extends p_albumsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, p_albumsUpsertArgs<ExtArgs>>
    ): Prisma__p_albumsClient<$Result.GetResult<Prisma.$p_albumsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of P_albums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_albumsCountArgs} args - Arguments to filter P_albums to count.
     * @example
     * // Count the number of P_albums
     * const count = await prisma.p_albums.count({
     *   where: {
     *     // ... the filter for the P_albums we want to count
     *   }
     * })
    **/
    count<T extends p_albumsCountArgs>(
      args?: Subset<T, p_albumsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], P_albumsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a P_albums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {P_albumsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends P_albumsAggregateArgs>(args: Subset<T, P_albumsAggregateArgs>): Prisma.PrismaPromise<GetP_albumsAggregateType<T>>

    /**
     * Group by P_albums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_albumsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends p_albumsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: p_albumsGroupByArgs['orderBy'] }
        : { orderBy?: p_albumsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, p_albumsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetP_albumsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the p_albums model
   */
  readonly fields: p_albumsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for p_albums.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__p_albumsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the p_albums model
   */ 
  interface p_albumsFieldRefs {
    readonly album_id: FieldRef<"p_albums", 'Int'>
    readonly cat_id: FieldRef<"p_albums", 'Int'>
    readonly subcat_id: FieldRef<"p_albums", 'Int'>
    readonly album_name: FieldRef<"p_albums", 'String'>
    readonly short_description: FieldRef<"p_albums", 'String'>
    readonly album_details: FieldRef<"p_albums", 'String'>
    readonly photographer_name: FieldRef<"p_albums", 'String'>
    readonly tag: FieldRef<"p_albums", 'String'>
    readonly status: FieldRef<"p_albums", 'Int'>
    readonly total_hit: FieldRef<"p_albums", 'Int'>
    readonly deletable: FieldRef<"p_albums", 'Int'>
    readonly user_id: FieldRef<"p_albums", 'Int'>
    readonly created_at: FieldRef<"p_albums", 'DateTime'>
    readonly updated_at: FieldRef<"p_albums", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * p_albums findUnique
   */
  export type p_albumsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_albums
     */
    select?: p_albumsSelect<ExtArgs> | null
    /**
     * Filter, which p_albums to fetch.
     */
    where: p_albumsWhereUniqueInput
  }


  /**
   * p_albums findUniqueOrThrow
   */
  export type p_albumsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_albums
     */
    select?: p_albumsSelect<ExtArgs> | null
    /**
     * Filter, which p_albums to fetch.
     */
    where: p_albumsWhereUniqueInput
  }


  /**
   * p_albums findFirst
   */
  export type p_albumsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_albums
     */
    select?: p_albumsSelect<ExtArgs> | null
    /**
     * Filter, which p_albums to fetch.
     */
    where?: p_albumsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p_albums to fetch.
     */
    orderBy?: p_albumsOrderByWithRelationInput | p_albumsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p_albums.
     */
    cursor?: p_albumsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p_albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p_albums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p_albums.
     */
    distinct?: P_albumsScalarFieldEnum | P_albumsScalarFieldEnum[]
  }


  /**
   * p_albums findFirstOrThrow
   */
  export type p_albumsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_albums
     */
    select?: p_albumsSelect<ExtArgs> | null
    /**
     * Filter, which p_albums to fetch.
     */
    where?: p_albumsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p_albums to fetch.
     */
    orderBy?: p_albumsOrderByWithRelationInput | p_albumsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p_albums.
     */
    cursor?: p_albumsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p_albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p_albums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p_albums.
     */
    distinct?: P_albumsScalarFieldEnum | P_albumsScalarFieldEnum[]
  }


  /**
   * p_albums findMany
   */
  export type p_albumsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_albums
     */
    select?: p_albumsSelect<ExtArgs> | null
    /**
     * Filter, which p_albums to fetch.
     */
    where?: p_albumsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p_albums to fetch.
     */
    orderBy?: p_albumsOrderByWithRelationInput | p_albumsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing p_albums.
     */
    cursor?: p_albumsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p_albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p_albums.
     */
    skip?: number
    distinct?: P_albumsScalarFieldEnum | P_albumsScalarFieldEnum[]
  }


  /**
   * p_albums create
   */
  export type p_albumsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_albums
     */
    select?: p_albumsSelect<ExtArgs> | null
    /**
     * The data needed to create a p_albums.
     */
    data: XOR<p_albumsCreateInput, p_albumsUncheckedCreateInput>
  }


  /**
   * p_albums createMany
   */
  export type p_albumsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many p_albums.
     */
    data: p_albumsCreateManyInput | p_albumsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * p_albums update
   */
  export type p_albumsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_albums
     */
    select?: p_albumsSelect<ExtArgs> | null
    /**
     * The data needed to update a p_albums.
     */
    data: XOR<p_albumsUpdateInput, p_albumsUncheckedUpdateInput>
    /**
     * Choose, which p_albums to update.
     */
    where: p_albumsWhereUniqueInput
  }


  /**
   * p_albums updateMany
   */
  export type p_albumsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update p_albums.
     */
    data: XOR<p_albumsUpdateManyMutationInput, p_albumsUncheckedUpdateManyInput>
    /**
     * Filter which p_albums to update
     */
    where?: p_albumsWhereInput
  }


  /**
   * p_albums upsert
   */
  export type p_albumsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_albums
     */
    select?: p_albumsSelect<ExtArgs> | null
    /**
     * The filter to search for the p_albums to update in case it exists.
     */
    where: p_albumsWhereUniqueInput
    /**
     * In case the p_albums found by the `where` argument doesn't exist, create a new p_albums with this data.
     */
    create: XOR<p_albumsCreateInput, p_albumsUncheckedCreateInput>
    /**
     * In case the p_albums was found with the provided `where` argument, update it with this data.
     */
    update: XOR<p_albumsUpdateInput, p_albumsUncheckedUpdateInput>
  }


  /**
   * p_albums delete
   */
  export type p_albumsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_albums
     */
    select?: p_albumsSelect<ExtArgs> | null
    /**
     * Filter which p_albums to delete.
     */
    where: p_albumsWhereUniqueInput
  }


  /**
   * p_albums deleteMany
   */
  export type p_albumsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p_albums to delete
     */
    where?: p_albumsWhereInput
  }


  /**
   * p_albums without action
   */
  export type p_albumsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_albums
     */
    select?: p_albumsSelect<ExtArgs> | null
  }



  /**
   * Model p_categories
   */

  export type AggregateP_categories = {
    _count: P_categoriesCountAggregateOutputType | null
    _avg: P_categoriesAvgAggregateOutputType | null
    _sum: P_categoriesSumAggregateOutputType | null
    _min: P_categoriesMinAggregateOutputType | null
    _max: P_categoriesMaxAggregateOutputType | null
  }

  export type P_categoriesAvgAggregateOutputType = {
    cat_id: number | null
    cat_position: number | null
    top_menu: number | null
    footer_menu: number | null
    status: number | null
    deletable: number | null
  }

  export type P_categoriesSumAggregateOutputType = {
    cat_id: number | null
    cat_position: number | null
    top_menu: number | null
    footer_menu: number | null
    status: number | null
    deletable: number | null
  }

  export type P_categoriesMinAggregateOutputType = {
    cat_id: number | null
    cat_name: string | null
    cat_name_bn: string | null
    cat_slug: string | null
    cat_meta_keyword: string | null
    cat_meta_description: string | null
    cat_position: number | null
    top_menu: number | null
    footer_menu: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type P_categoriesMaxAggregateOutputType = {
    cat_id: number | null
    cat_name: string | null
    cat_name_bn: string | null
    cat_slug: string | null
    cat_meta_keyword: string | null
    cat_meta_description: string | null
    cat_position: number | null
    top_menu: number | null
    footer_menu: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type P_categoriesCountAggregateOutputType = {
    cat_id: number
    cat_name: number
    cat_name_bn: number
    cat_slug: number
    cat_meta_keyword: number
    cat_meta_description: number
    cat_position: number
    top_menu: number
    footer_menu: number
    status: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type P_categoriesAvgAggregateInputType = {
    cat_id?: true
    cat_position?: true
    top_menu?: true
    footer_menu?: true
    status?: true
    deletable?: true
  }

  export type P_categoriesSumAggregateInputType = {
    cat_id?: true
    cat_position?: true
    top_menu?: true
    footer_menu?: true
    status?: true
    deletable?: true
  }

  export type P_categoriesMinAggregateInputType = {
    cat_id?: true
    cat_name?: true
    cat_name_bn?: true
    cat_slug?: true
    cat_meta_keyword?: true
    cat_meta_description?: true
    cat_position?: true
    top_menu?: true
    footer_menu?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type P_categoriesMaxAggregateInputType = {
    cat_id?: true
    cat_name?: true
    cat_name_bn?: true
    cat_slug?: true
    cat_meta_keyword?: true
    cat_meta_description?: true
    cat_position?: true
    top_menu?: true
    footer_menu?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type P_categoriesCountAggregateInputType = {
    cat_id?: true
    cat_name?: true
    cat_name_bn?: true
    cat_slug?: true
    cat_meta_keyword?: true
    cat_meta_description?: true
    cat_position?: true
    top_menu?: true
    footer_menu?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type P_categoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p_categories to aggregate.
     */
    where?: p_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p_categories to fetch.
     */
    orderBy?: p_categoriesOrderByWithRelationInput | p_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: p_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned p_categories
    **/
    _count?: true | P_categoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: P_categoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: P_categoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: P_categoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: P_categoriesMaxAggregateInputType
  }

  export type GetP_categoriesAggregateType<T extends P_categoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateP_categories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateP_categories[P]>
      : GetScalarType<T[P], AggregateP_categories[P]>
  }




  export type p_categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p_categoriesWhereInput
    orderBy?: p_categoriesOrderByWithAggregationInput | p_categoriesOrderByWithAggregationInput[]
    by: P_categoriesScalarFieldEnum[] | P_categoriesScalarFieldEnum
    having?: p_categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: P_categoriesCountAggregateInputType | true
    _avg?: P_categoriesAvgAggregateInputType
    _sum?: P_categoriesSumAggregateInputType
    _min?: P_categoriesMinAggregateInputType
    _max?: P_categoriesMaxAggregateInputType
  }

  export type P_categoriesGroupByOutputType = {
    cat_id: number
    cat_name: string
    cat_name_bn: string
    cat_slug: string
    cat_meta_keyword: string | null
    cat_meta_description: string | null
    cat_position: number
    top_menu: number
    footer_menu: number
    status: number
    deletable: number
    created_at: Date | null
    updated_at: Date | null
    _count: P_categoriesCountAggregateOutputType | null
    _avg: P_categoriesAvgAggregateOutputType | null
    _sum: P_categoriesSumAggregateOutputType | null
    _min: P_categoriesMinAggregateOutputType | null
    _max: P_categoriesMaxAggregateOutputType | null
  }

  type GetP_categoriesGroupByPayload<T extends p_categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<P_categoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof P_categoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], P_categoriesGroupByOutputType[P]>
            : GetScalarType<T[P], P_categoriesGroupByOutputType[P]>
        }
      >
    >


  export type p_categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cat_id?: boolean
    cat_name?: boolean
    cat_name_bn?: boolean
    cat_slug?: boolean
    cat_meta_keyword?: boolean
    cat_meta_description?: boolean
    cat_position?: boolean
    top_menu?: boolean
    footer_menu?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["p_categories"]>

  export type p_categoriesSelectScalar = {
    cat_id?: boolean
    cat_name?: boolean
    cat_name_bn?: boolean
    cat_slug?: boolean
    cat_meta_keyword?: boolean
    cat_meta_description?: boolean
    cat_position?: boolean
    top_menu?: boolean
    footer_menu?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $p_categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "p_categories"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      cat_id: number
      cat_name: string
      cat_name_bn: string
      cat_slug: string
      cat_meta_keyword: string | null
      cat_meta_description: string | null
      cat_position: number
      top_menu: number
      footer_menu: number
      status: number
      deletable: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["p_categories"]>
    composites: {}
  }


  type p_categoriesGetPayload<S extends boolean | null | undefined | p_categoriesDefaultArgs> = $Result.GetResult<Prisma.$p_categoriesPayload, S>

  type p_categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<p_categoriesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: P_categoriesCountAggregateInputType | true
    }

  export interface p_categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['p_categories'], meta: { name: 'p_categories' } }
    /**
     * Find zero or one P_categories that matches the filter.
     * @param {p_categoriesFindUniqueArgs} args - Arguments to find a P_categories
     * @example
     * // Get one P_categories
     * const p_categories = await prisma.p_categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends p_categoriesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, p_categoriesFindUniqueArgs<ExtArgs>>
    ): Prisma__p_categoriesClient<$Result.GetResult<Prisma.$p_categoriesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one P_categories that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {p_categoriesFindUniqueOrThrowArgs} args - Arguments to find a P_categories
     * @example
     * // Get one P_categories
     * const p_categories = await prisma.p_categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends p_categoriesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, p_categoriesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__p_categoriesClient<$Result.GetResult<Prisma.$p_categoriesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first P_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_categoriesFindFirstArgs} args - Arguments to find a P_categories
     * @example
     * // Get one P_categories
     * const p_categories = await prisma.p_categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends p_categoriesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, p_categoriesFindFirstArgs<ExtArgs>>
    ): Prisma__p_categoriesClient<$Result.GetResult<Prisma.$p_categoriesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first P_categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_categoriesFindFirstOrThrowArgs} args - Arguments to find a P_categories
     * @example
     * // Get one P_categories
     * const p_categories = await prisma.p_categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends p_categoriesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, p_categoriesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__p_categoriesClient<$Result.GetResult<Prisma.$p_categoriesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more P_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_categoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all P_categories
     * const p_categories = await prisma.p_categories.findMany()
     * 
     * // Get first 10 P_categories
     * const p_categories = await prisma.p_categories.findMany({ take: 10 })
     * 
     * // Only select the `cat_id`
     * const p_categoriesWithCat_idOnly = await prisma.p_categories.findMany({ select: { cat_id: true } })
     * 
    **/
    findMany<T extends p_categoriesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, p_categoriesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p_categoriesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a P_categories.
     * @param {p_categoriesCreateArgs} args - Arguments to create a P_categories.
     * @example
     * // Create one P_categories
     * const P_categories = await prisma.p_categories.create({
     *   data: {
     *     // ... data to create a P_categories
     *   }
     * })
     * 
    **/
    create<T extends p_categoriesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, p_categoriesCreateArgs<ExtArgs>>
    ): Prisma__p_categoriesClient<$Result.GetResult<Prisma.$p_categoriesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many P_categories.
     *     @param {p_categoriesCreateManyArgs} args - Arguments to create many P_categories.
     *     @example
     *     // Create many P_categories
     *     const p_categories = await prisma.p_categories.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends p_categoriesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, p_categoriesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a P_categories.
     * @param {p_categoriesDeleteArgs} args - Arguments to delete one P_categories.
     * @example
     * // Delete one P_categories
     * const P_categories = await prisma.p_categories.delete({
     *   where: {
     *     // ... filter to delete one P_categories
     *   }
     * })
     * 
    **/
    delete<T extends p_categoriesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, p_categoriesDeleteArgs<ExtArgs>>
    ): Prisma__p_categoriesClient<$Result.GetResult<Prisma.$p_categoriesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one P_categories.
     * @param {p_categoriesUpdateArgs} args - Arguments to update one P_categories.
     * @example
     * // Update one P_categories
     * const p_categories = await prisma.p_categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends p_categoriesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, p_categoriesUpdateArgs<ExtArgs>>
    ): Prisma__p_categoriesClient<$Result.GetResult<Prisma.$p_categoriesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more P_categories.
     * @param {p_categoriesDeleteManyArgs} args - Arguments to filter P_categories to delete.
     * @example
     * // Delete a few P_categories
     * const { count } = await prisma.p_categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends p_categoriesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, p_categoriesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more P_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many P_categories
     * const p_categories = await prisma.p_categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends p_categoriesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, p_categoriesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one P_categories.
     * @param {p_categoriesUpsertArgs} args - Arguments to update or create a P_categories.
     * @example
     * // Update or create a P_categories
     * const p_categories = await prisma.p_categories.upsert({
     *   create: {
     *     // ... data to create a P_categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the P_categories we want to update
     *   }
     * })
    **/
    upsert<T extends p_categoriesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, p_categoriesUpsertArgs<ExtArgs>>
    ): Prisma__p_categoriesClient<$Result.GetResult<Prisma.$p_categoriesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of P_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_categoriesCountArgs} args - Arguments to filter P_categories to count.
     * @example
     * // Count the number of P_categories
     * const count = await prisma.p_categories.count({
     *   where: {
     *     // ... the filter for the P_categories we want to count
     *   }
     * })
    **/
    count<T extends p_categoriesCountArgs>(
      args?: Subset<T, p_categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], P_categoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a P_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {P_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends P_categoriesAggregateArgs>(args: Subset<T, P_categoriesAggregateArgs>): Prisma.PrismaPromise<GetP_categoriesAggregateType<T>>

    /**
     * Group by P_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends p_categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: p_categoriesGroupByArgs['orderBy'] }
        : { orderBy?: p_categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, p_categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetP_categoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the p_categories model
   */
  readonly fields: p_categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for p_categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__p_categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the p_categories model
   */ 
  interface p_categoriesFieldRefs {
    readonly cat_id: FieldRef<"p_categories", 'Int'>
    readonly cat_name: FieldRef<"p_categories", 'String'>
    readonly cat_name_bn: FieldRef<"p_categories", 'String'>
    readonly cat_slug: FieldRef<"p_categories", 'String'>
    readonly cat_meta_keyword: FieldRef<"p_categories", 'String'>
    readonly cat_meta_description: FieldRef<"p_categories", 'String'>
    readonly cat_position: FieldRef<"p_categories", 'Int'>
    readonly top_menu: FieldRef<"p_categories", 'Int'>
    readonly footer_menu: FieldRef<"p_categories", 'Int'>
    readonly status: FieldRef<"p_categories", 'Int'>
    readonly deletable: FieldRef<"p_categories", 'Int'>
    readonly created_at: FieldRef<"p_categories", 'DateTime'>
    readonly updated_at: FieldRef<"p_categories", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * p_categories findUnique
   */
  export type p_categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_categories
     */
    select?: p_categoriesSelect<ExtArgs> | null
    /**
     * Filter, which p_categories to fetch.
     */
    where: p_categoriesWhereUniqueInput
  }


  /**
   * p_categories findUniqueOrThrow
   */
  export type p_categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_categories
     */
    select?: p_categoriesSelect<ExtArgs> | null
    /**
     * Filter, which p_categories to fetch.
     */
    where: p_categoriesWhereUniqueInput
  }


  /**
   * p_categories findFirst
   */
  export type p_categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_categories
     */
    select?: p_categoriesSelect<ExtArgs> | null
    /**
     * Filter, which p_categories to fetch.
     */
    where?: p_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p_categories to fetch.
     */
    orderBy?: p_categoriesOrderByWithRelationInput | p_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p_categories.
     */
    cursor?: p_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p_categories.
     */
    distinct?: P_categoriesScalarFieldEnum | P_categoriesScalarFieldEnum[]
  }


  /**
   * p_categories findFirstOrThrow
   */
  export type p_categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_categories
     */
    select?: p_categoriesSelect<ExtArgs> | null
    /**
     * Filter, which p_categories to fetch.
     */
    where?: p_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p_categories to fetch.
     */
    orderBy?: p_categoriesOrderByWithRelationInput | p_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p_categories.
     */
    cursor?: p_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p_categories.
     */
    distinct?: P_categoriesScalarFieldEnum | P_categoriesScalarFieldEnum[]
  }


  /**
   * p_categories findMany
   */
  export type p_categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_categories
     */
    select?: p_categoriesSelect<ExtArgs> | null
    /**
     * Filter, which p_categories to fetch.
     */
    where?: p_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p_categories to fetch.
     */
    orderBy?: p_categoriesOrderByWithRelationInput | p_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing p_categories.
     */
    cursor?: p_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p_categories.
     */
    skip?: number
    distinct?: P_categoriesScalarFieldEnum | P_categoriesScalarFieldEnum[]
  }


  /**
   * p_categories create
   */
  export type p_categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_categories
     */
    select?: p_categoriesSelect<ExtArgs> | null
    /**
     * The data needed to create a p_categories.
     */
    data: XOR<p_categoriesCreateInput, p_categoriesUncheckedCreateInput>
  }


  /**
   * p_categories createMany
   */
  export type p_categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many p_categories.
     */
    data: p_categoriesCreateManyInput | p_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * p_categories update
   */
  export type p_categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_categories
     */
    select?: p_categoriesSelect<ExtArgs> | null
    /**
     * The data needed to update a p_categories.
     */
    data: XOR<p_categoriesUpdateInput, p_categoriesUncheckedUpdateInput>
    /**
     * Choose, which p_categories to update.
     */
    where: p_categoriesWhereUniqueInput
  }


  /**
   * p_categories updateMany
   */
  export type p_categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update p_categories.
     */
    data: XOR<p_categoriesUpdateManyMutationInput, p_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which p_categories to update
     */
    where?: p_categoriesWhereInput
  }


  /**
   * p_categories upsert
   */
  export type p_categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_categories
     */
    select?: p_categoriesSelect<ExtArgs> | null
    /**
     * The filter to search for the p_categories to update in case it exists.
     */
    where: p_categoriesWhereUniqueInput
    /**
     * In case the p_categories found by the `where` argument doesn't exist, create a new p_categories with this data.
     */
    create: XOR<p_categoriesCreateInput, p_categoriesUncheckedCreateInput>
    /**
     * In case the p_categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<p_categoriesUpdateInput, p_categoriesUncheckedUpdateInput>
  }


  /**
   * p_categories delete
   */
  export type p_categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_categories
     */
    select?: p_categoriesSelect<ExtArgs> | null
    /**
     * Filter which p_categories to delete.
     */
    where: p_categoriesWhereUniqueInput
  }


  /**
   * p_categories deleteMany
   */
  export type p_categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p_categories to delete
     */
    where?: p_categoriesWhereInput
  }


  /**
   * p_categories without action
   */
  export type p_categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_categories
     */
    select?: p_categoriesSelect<ExtArgs> | null
  }



  /**
   * Model p_galleries
   */

  export type AggregateP_galleries = {
    _count: P_galleriesCountAggregateOutputType | null
    _avg: P_galleriesAvgAggregateOutputType | null
    _sum: P_galleriesSumAggregateOutputType | null
    _min: P_galleriesMinAggregateOutputType | null
    _max: P_galleriesMaxAggregateOutputType | null
  }

  export type P_galleriesAvgAggregateOutputType = {
    id: number | null
    album_id: number | null
  }

  export type P_galleriesSumAggregateOutputType = {
    id: number | null
    album_id: number | null
  }

  export type P_galleriesMinAggregateOutputType = {
    id: number | null
    album_id: number | null
    photo: string | null
    photo_capture: string | null
    feature_image: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type P_galleriesMaxAggregateOutputType = {
    id: number | null
    album_id: number | null
    photo: string | null
    photo_capture: string | null
    feature_image: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type P_galleriesCountAggregateOutputType = {
    id: number
    album_id: number
    photo: number
    photo_capture: number
    feature_image: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type P_galleriesAvgAggregateInputType = {
    id?: true
    album_id?: true
  }

  export type P_galleriesSumAggregateInputType = {
    id?: true
    album_id?: true
  }

  export type P_galleriesMinAggregateInputType = {
    id?: true
    album_id?: true
    photo?: true
    photo_capture?: true
    feature_image?: true
    created_at?: true
    updated_at?: true
  }

  export type P_galleriesMaxAggregateInputType = {
    id?: true
    album_id?: true
    photo?: true
    photo_capture?: true
    feature_image?: true
    created_at?: true
    updated_at?: true
  }

  export type P_galleriesCountAggregateInputType = {
    id?: true
    album_id?: true
    photo?: true
    photo_capture?: true
    feature_image?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type P_galleriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p_galleries to aggregate.
     */
    where?: p_galleriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p_galleries to fetch.
     */
    orderBy?: p_galleriesOrderByWithRelationInput | p_galleriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: p_galleriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p_galleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p_galleries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned p_galleries
    **/
    _count?: true | P_galleriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: P_galleriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: P_galleriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: P_galleriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: P_galleriesMaxAggregateInputType
  }

  export type GetP_galleriesAggregateType<T extends P_galleriesAggregateArgs> = {
        [P in keyof T & keyof AggregateP_galleries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateP_galleries[P]>
      : GetScalarType<T[P], AggregateP_galleries[P]>
  }




  export type p_galleriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p_galleriesWhereInput
    orderBy?: p_galleriesOrderByWithAggregationInput | p_galleriesOrderByWithAggregationInput[]
    by: P_galleriesScalarFieldEnum[] | P_galleriesScalarFieldEnum
    having?: p_galleriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: P_galleriesCountAggregateInputType | true
    _avg?: P_galleriesAvgAggregateInputType
    _sum?: P_galleriesSumAggregateInputType
    _min?: P_galleriesMinAggregateInputType
    _max?: P_galleriesMaxAggregateInputType
  }

  export type P_galleriesGroupByOutputType = {
    id: number
    album_id: number
    photo: string
    photo_capture: string | null
    feature_image: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: P_galleriesCountAggregateOutputType | null
    _avg: P_galleriesAvgAggregateOutputType | null
    _sum: P_galleriesSumAggregateOutputType | null
    _min: P_galleriesMinAggregateOutputType | null
    _max: P_galleriesMaxAggregateOutputType | null
  }

  type GetP_galleriesGroupByPayload<T extends p_galleriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<P_galleriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof P_galleriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], P_galleriesGroupByOutputType[P]>
            : GetScalarType<T[P], P_galleriesGroupByOutputType[P]>
        }
      >
    >


  export type p_galleriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    album_id?: boolean
    photo?: boolean
    photo_capture?: boolean
    feature_image?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["p_galleries"]>

  export type p_galleriesSelectScalar = {
    id?: boolean
    album_id?: boolean
    photo?: boolean
    photo_capture?: boolean
    feature_image?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $p_galleriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "p_galleries"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      album_id: number
      photo: string
      photo_capture: string | null
      feature_image: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["p_galleries"]>
    composites: {}
  }


  type p_galleriesGetPayload<S extends boolean | null | undefined | p_galleriesDefaultArgs> = $Result.GetResult<Prisma.$p_galleriesPayload, S>

  type p_galleriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<p_galleriesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: P_galleriesCountAggregateInputType | true
    }

  export interface p_galleriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['p_galleries'], meta: { name: 'p_galleries' } }
    /**
     * Find zero or one P_galleries that matches the filter.
     * @param {p_galleriesFindUniqueArgs} args - Arguments to find a P_galleries
     * @example
     * // Get one P_galleries
     * const p_galleries = await prisma.p_galleries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends p_galleriesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, p_galleriesFindUniqueArgs<ExtArgs>>
    ): Prisma__p_galleriesClient<$Result.GetResult<Prisma.$p_galleriesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one P_galleries that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {p_galleriesFindUniqueOrThrowArgs} args - Arguments to find a P_galleries
     * @example
     * // Get one P_galleries
     * const p_galleries = await prisma.p_galleries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends p_galleriesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, p_galleriesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__p_galleriesClient<$Result.GetResult<Prisma.$p_galleriesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first P_galleries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_galleriesFindFirstArgs} args - Arguments to find a P_galleries
     * @example
     * // Get one P_galleries
     * const p_galleries = await prisma.p_galleries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends p_galleriesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, p_galleriesFindFirstArgs<ExtArgs>>
    ): Prisma__p_galleriesClient<$Result.GetResult<Prisma.$p_galleriesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first P_galleries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_galleriesFindFirstOrThrowArgs} args - Arguments to find a P_galleries
     * @example
     * // Get one P_galleries
     * const p_galleries = await prisma.p_galleries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends p_galleriesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, p_galleriesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__p_galleriesClient<$Result.GetResult<Prisma.$p_galleriesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more P_galleries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_galleriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all P_galleries
     * const p_galleries = await prisma.p_galleries.findMany()
     * 
     * // Get first 10 P_galleries
     * const p_galleries = await prisma.p_galleries.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const p_galleriesWithIdOnly = await prisma.p_galleries.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends p_galleriesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, p_galleriesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p_galleriesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a P_galleries.
     * @param {p_galleriesCreateArgs} args - Arguments to create a P_galleries.
     * @example
     * // Create one P_galleries
     * const P_galleries = await prisma.p_galleries.create({
     *   data: {
     *     // ... data to create a P_galleries
     *   }
     * })
     * 
    **/
    create<T extends p_galleriesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, p_galleriesCreateArgs<ExtArgs>>
    ): Prisma__p_galleriesClient<$Result.GetResult<Prisma.$p_galleriesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many P_galleries.
     *     @param {p_galleriesCreateManyArgs} args - Arguments to create many P_galleries.
     *     @example
     *     // Create many P_galleries
     *     const p_galleries = await prisma.p_galleries.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends p_galleriesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, p_galleriesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a P_galleries.
     * @param {p_galleriesDeleteArgs} args - Arguments to delete one P_galleries.
     * @example
     * // Delete one P_galleries
     * const P_galleries = await prisma.p_galleries.delete({
     *   where: {
     *     // ... filter to delete one P_galleries
     *   }
     * })
     * 
    **/
    delete<T extends p_galleriesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, p_galleriesDeleteArgs<ExtArgs>>
    ): Prisma__p_galleriesClient<$Result.GetResult<Prisma.$p_galleriesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one P_galleries.
     * @param {p_galleriesUpdateArgs} args - Arguments to update one P_galleries.
     * @example
     * // Update one P_galleries
     * const p_galleries = await prisma.p_galleries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends p_galleriesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, p_galleriesUpdateArgs<ExtArgs>>
    ): Prisma__p_galleriesClient<$Result.GetResult<Prisma.$p_galleriesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more P_galleries.
     * @param {p_galleriesDeleteManyArgs} args - Arguments to filter P_galleries to delete.
     * @example
     * // Delete a few P_galleries
     * const { count } = await prisma.p_galleries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends p_galleriesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, p_galleriesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more P_galleries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_galleriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many P_galleries
     * const p_galleries = await prisma.p_galleries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends p_galleriesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, p_galleriesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one P_galleries.
     * @param {p_galleriesUpsertArgs} args - Arguments to update or create a P_galleries.
     * @example
     * // Update or create a P_galleries
     * const p_galleries = await prisma.p_galleries.upsert({
     *   create: {
     *     // ... data to create a P_galleries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the P_galleries we want to update
     *   }
     * })
    **/
    upsert<T extends p_galleriesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, p_galleriesUpsertArgs<ExtArgs>>
    ): Prisma__p_galleriesClient<$Result.GetResult<Prisma.$p_galleriesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of P_galleries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_galleriesCountArgs} args - Arguments to filter P_galleries to count.
     * @example
     * // Count the number of P_galleries
     * const count = await prisma.p_galleries.count({
     *   where: {
     *     // ... the filter for the P_galleries we want to count
     *   }
     * })
    **/
    count<T extends p_galleriesCountArgs>(
      args?: Subset<T, p_galleriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], P_galleriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a P_galleries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {P_galleriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends P_galleriesAggregateArgs>(args: Subset<T, P_galleriesAggregateArgs>): Prisma.PrismaPromise<GetP_galleriesAggregateType<T>>

    /**
     * Group by P_galleries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_galleriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends p_galleriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: p_galleriesGroupByArgs['orderBy'] }
        : { orderBy?: p_galleriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, p_galleriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetP_galleriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the p_galleries model
   */
  readonly fields: p_galleriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for p_galleries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__p_galleriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the p_galleries model
   */ 
  interface p_galleriesFieldRefs {
    readonly id: FieldRef<"p_galleries", 'Int'>
    readonly album_id: FieldRef<"p_galleries", 'Int'>
    readonly photo: FieldRef<"p_galleries", 'String'>
    readonly photo_capture: FieldRef<"p_galleries", 'String'>
    readonly feature_image: FieldRef<"p_galleries", 'String'>
    readonly created_at: FieldRef<"p_galleries", 'DateTime'>
    readonly updated_at: FieldRef<"p_galleries", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * p_galleries findUnique
   */
  export type p_galleriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_galleries
     */
    select?: p_galleriesSelect<ExtArgs> | null
    /**
     * Filter, which p_galleries to fetch.
     */
    where: p_galleriesWhereUniqueInput
  }


  /**
   * p_galleries findUniqueOrThrow
   */
  export type p_galleriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_galleries
     */
    select?: p_galleriesSelect<ExtArgs> | null
    /**
     * Filter, which p_galleries to fetch.
     */
    where: p_galleriesWhereUniqueInput
  }


  /**
   * p_galleries findFirst
   */
  export type p_galleriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_galleries
     */
    select?: p_galleriesSelect<ExtArgs> | null
    /**
     * Filter, which p_galleries to fetch.
     */
    where?: p_galleriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p_galleries to fetch.
     */
    orderBy?: p_galleriesOrderByWithRelationInput | p_galleriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p_galleries.
     */
    cursor?: p_galleriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p_galleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p_galleries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p_galleries.
     */
    distinct?: P_galleriesScalarFieldEnum | P_galleriesScalarFieldEnum[]
  }


  /**
   * p_galleries findFirstOrThrow
   */
  export type p_galleriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_galleries
     */
    select?: p_galleriesSelect<ExtArgs> | null
    /**
     * Filter, which p_galleries to fetch.
     */
    where?: p_galleriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p_galleries to fetch.
     */
    orderBy?: p_galleriesOrderByWithRelationInput | p_galleriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p_galleries.
     */
    cursor?: p_galleriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p_galleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p_galleries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p_galleries.
     */
    distinct?: P_galleriesScalarFieldEnum | P_galleriesScalarFieldEnum[]
  }


  /**
   * p_galleries findMany
   */
  export type p_galleriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_galleries
     */
    select?: p_galleriesSelect<ExtArgs> | null
    /**
     * Filter, which p_galleries to fetch.
     */
    where?: p_galleriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p_galleries to fetch.
     */
    orderBy?: p_galleriesOrderByWithRelationInput | p_galleriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing p_galleries.
     */
    cursor?: p_galleriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p_galleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p_galleries.
     */
    skip?: number
    distinct?: P_galleriesScalarFieldEnum | P_galleriesScalarFieldEnum[]
  }


  /**
   * p_galleries create
   */
  export type p_galleriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_galleries
     */
    select?: p_galleriesSelect<ExtArgs> | null
    /**
     * The data needed to create a p_galleries.
     */
    data: XOR<p_galleriesCreateInput, p_galleriesUncheckedCreateInput>
  }


  /**
   * p_galleries createMany
   */
  export type p_galleriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many p_galleries.
     */
    data: p_galleriesCreateManyInput | p_galleriesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * p_galleries update
   */
  export type p_galleriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_galleries
     */
    select?: p_galleriesSelect<ExtArgs> | null
    /**
     * The data needed to update a p_galleries.
     */
    data: XOR<p_galleriesUpdateInput, p_galleriesUncheckedUpdateInput>
    /**
     * Choose, which p_galleries to update.
     */
    where: p_galleriesWhereUniqueInput
  }


  /**
   * p_galleries updateMany
   */
  export type p_galleriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update p_galleries.
     */
    data: XOR<p_galleriesUpdateManyMutationInput, p_galleriesUncheckedUpdateManyInput>
    /**
     * Filter which p_galleries to update
     */
    where?: p_galleriesWhereInput
  }


  /**
   * p_galleries upsert
   */
  export type p_galleriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_galleries
     */
    select?: p_galleriesSelect<ExtArgs> | null
    /**
     * The filter to search for the p_galleries to update in case it exists.
     */
    where: p_galleriesWhereUniqueInput
    /**
     * In case the p_galleries found by the `where` argument doesn't exist, create a new p_galleries with this data.
     */
    create: XOR<p_galleriesCreateInput, p_galleriesUncheckedCreateInput>
    /**
     * In case the p_galleries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<p_galleriesUpdateInput, p_galleriesUncheckedUpdateInput>
  }


  /**
   * p_galleries delete
   */
  export type p_galleriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_galleries
     */
    select?: p_galleriesSelect<ExtArgs> | null
    /**
     * Filter which p_galleries to delete.
     */
    where: p_galleriesWhereUniqueInput
  }


  /**
   * p_galleries deleteMany
   */
  export type p_galleriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p_galleries to delete
     */
    where?: p_galleriesWhereInput
  }


  /**
   * p_galleries without action
   */
  export type p_galleriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_galleries
     */
    select?: p_galleriesSelect<ExtArgs> | null
  }



  /**
   * Model p_subcategories
   */

  export type AggregateP_subcategories = {
    _count: P_subcategoriesCountAggregateOutputType | null
    _avg: P_subcategoriesAvgAggregateOutputType | null
    _sum: P_subcategoriesSumAggregateOutputType | null
    _min: P_subcategoriesMinAggregateOutputType | null
    _max: P_subcategoriesMaxAggregateOutputType | null
  }

  export type P_subcategoriesAvgAggregateOutputType = {
    subcat_id: number | null
    cat_id: number | null
    subcat_position: number | null
    status: number | null
    deletable: number | null
  }

  export type P_subcategoriesSumAggregateOutputType = {
    subcat_id: number | null
    cat_id: number | null
    subcat_position: number | null
    status: number | null
    deletable: number | null
  }

  export type P_subcategoriesMinAggregateOutputType = {
    subcat_id: number | null
    cat_id: number | null
    subcat_name: string | null
    subcat_name_bn: string | null
    subcat_slug: string | null
    subcat_meta_keyword: string | null
    subcat_meta_description: string | null
    subcat_position: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type P_subcategoriesMaxAggregateOutputType = {
    subcat_id: number | null
    cat_id: number | null
    subcat_name: string | null
    subcat_name_bn: string | null
    subcat_slug: string | null
    subcat_meta_keyword: string | null
    subcat_meta_description: string | null
    subcat_position: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type P_subcategoriesCountAggregateOutputType = {
    subcat_id: number
    cat_id: number
    subcat_name: number
    subcat_name_bn: number
    subcat_slug: number
    subcat_meta_keyword: number
    subcat_meta_description: number
    subcat_position: number
    status: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type P_subcategoriesAvgAggregateInputType = {
    subcat_id?: true
    cat_id?: true
    subcat_position?: true
    status?: true
    deletable?: true
  }

  export type P_subcategoriesSumAggregateInputType = {
    subcat_id?: true
    cat_id?: true
    subcat_position?: true
    status?: true
    deletable?: true
  }

  export type P_subcategoriesMinAggregateInputType = {
    subcat_id?: true
    cat_id?: true
    subcat_name?: true
    subcat_name_bn?: true
    subcat_slug?: true
    subcat_meta_keyword?: true
    subcat_meta_description?: true
    subcat_position?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type P_subcategoriesMaxAggregateInputType = {
    subcat_id?: true
    cat_id?: true
    subcat_name?: true
    subcat_name_bn?: true
    subcat_slug?: true
    subcat_meta_keyword?: true
    subcat_meta_description?: true
    subcat_position?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type P_subcategoriesCountAggregateInputType = {
    subcat_id?: true
    cat_id?: true
    subcat_name?: true
    subcat_name_bn?: true
    subcat_slug?: true
    subcat_meta_keyword?: true
    subcat_meta_description?: true
    subcat_position?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type P_subcategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p_subcategories to aggregate.
     */
    where?: p_subcategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p_subcategories to fetch.
     */
    orderBy?: p_subcategoriesOrderByWithRelationInput | p_subcategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: p_subcategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p_subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p_subcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned p_subcategories
    **/
    _count?: true | P_subcategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: P_subcategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: P_subcategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: P_subcategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: P_subcategoriesMaxAggregateInputType
  }

  export type GetP_subcategoriesAggregateType<T extends P_subcategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateP_subcategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateP_subcategories[P]>
      : GetScalarType<T[P], AggregateP_subcategories[P]>
  }




  export type p_subcategoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: p_subcategoriesWhereInput
    orderBy?: p_subcategoriesOrderByWithAggregationInput | p_subcategoriesOrderByWithAggregationInput[]
    by: P_subcategoriesScalarFieldEnum[] | P_subcategoriesScalarFieldEnum
    having?: p_subcategoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: P_subcategoriesCountAggregateInputType | true
    _avg?: P_subcategoriesAvgAggregateInputType
    _sum?: P_subcategoriesSumAggregateInputType
    _min?: P_subcategoriesMinAggregateInputType
    _max?: P_subcategoriesMaxAggregateInputType
  }

  export type P_subcategoriesGroupByOutputType = {
    subcat_id: number
    cat_id: number
    subcat_name: string
    subcat_name_bn: string
    subcat_slug: string
    subcat_meta_keyword: string | null
    subcat_meta_description: string | null
    subcat_position: number
    status: number
    deletable: number
    created_at: Date | null
    updated_at: Date | null
    _count: P_subcategoriesCountAggregateOutputType | null
    _avg: P_subcategoriesAvgAggregateOutputType | null
    _sum: P_subcategoriesSumAggregateOutputType | null
    _min: P_subcategoriesMinAggregateOutputType | null
    _max: P_subcategoriesMaxAggregateOutputType | null
  }

  type GetP_subcategoriesGroupByPayload<T extends p_subcategoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<P_subcategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof P_subcategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], P_subcategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], P_subcategoriesGroupByOutputType[P]>
        }
      >
    >


  export type p_subcategoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subcat_id?: boolean
    cat_id?: boolean
    subcat_name?: boolean
    subcat_name_bn?: boolean
    subcat_slug?: boolean
    subcat_meta_keyword?: boolean
    subcat_meta_description?: boolean
    subcat_position?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["p_subcategories"]>

  export type p_subcategoriesSelectScalar = {
    subcat_id?: boolean
    cat_id?: boolean
    subcat_name?: boolean
    subcat_name_bn?: boolean
    subcat_slug?: boolean
    subcat_meta_keyword?: boolean
    subcat_meta_description?: boolean
    subcat_position?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $p_subcategoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "p_subcategories"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      subcat_id: number
      cat_id: number
      subcat_name: string
      subcat_name_bn: string
      subcat_slug: string
      subcat_meta_keyword: string | null
      subcat_meta_description: string | null
      subcat_position: number
      status: number
      deletable: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["p_subcategories"]>
    composites: {}
  }


  type p_subcategoriesGetPayload<S extends boolean | null | undefined | p_subcategoriesDefaultArgs> = $Result.GetResult<Prisma.$p_subcategoriesPayload, S>

  type p_subcategoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<p_subcategoriesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: P_subcategoriesCountAggregateInputType | true
    }

  export interface p_subcategoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['p_subcategories'], meta: { name: 'p_subcategories' } }
    /**
     * Find zero or one P_subcategories that matches the filter.
     * @param {p_subcategoriesFindUniqueArgs} args - Arguments to find a P_subcategories
     * @example
     * // Get one P_subcategories
     * const p_subcategories = await prisma.p_subcategories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends p_subcategoriesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, p_subcategoriesFindUniqueArgs<ExtArgs>>
    ): Prisma__p_subcategoriesClient<$Result.GetResult<Prisma.$p_subcategoriesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one P_subcategories that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {p_subcategoriesFindUniqueOrThrowArgs} args - Arguments to find a P_subcategories
     * @example
     * // Get one P_subcategories
     * const p_subcategories = await prisma.p_subcategories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends p_subcategoriesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, p_subcategoriesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__p_subcategoriesClient<$Result.GetResult<Prisma.$p_subcategoriesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first P_subcategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_subcategoriesFindFirstArgs} args - Arguments to find a P_subcategories
     * @example
     * // Get one P_subcategories
     * const p_subcategories = await prisma.p_subcategories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends p_subcategoriesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, p_subcategoriesFindFirstArgs<ExtArgs>>
    ): Prisma__p_subcategoriesClient<$Result.GetResult<Prisma.$p_subcategoriesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first P_subcategories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_subcategoriesFindFirstOrThrowArgs} args - Arguments to find a P_subcategories
     * @example
     * // Get one P_subcategories
     * const p_subcategories = await prisma.p_subcategories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends p_subcategoriesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, p_subcategoriesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__p_subcategoriesClient<$Result.GetResult<Prisma.$p_subcategoriesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more P_subcategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_subcategoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all P_subcategories
     * const p_subcategories = await prisma.p_subcategories.findMany()
     * 
     * // Get first 10 P_subcategories
     * const p_subcategories = await prisma.p_subcategories.findMany({ take: 10 })
     * 
     * // Only select the `subcat_id`
     * const p_subcategoriesWithSubcat_idOnly = await prisma.p_subcategories.findMany({ select: { subcat_id: true } })
     * 
    **/
    findMany<T extends p_subcategoriesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, p_subcategoriesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$p_subcategoriesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a P_subcategories.
     * @param {p_subcategoriesCreateArgs} args - Arguments to create a P_subcategories.
     * @example
     * // Create one P_subcategories
     * const P_subcategories = await prisma.p_subcategories.create({
     *   data: {
     *     // ... data to create a P_subcategories
     *   }
     * })
     * 
    **/
    create<T extends p_subcategoriesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, p_subcategoriesCreateArgs<ExtArgs>>
    ): Prisma__p_subcategoriesClient<$Result.GetResult<Prisma.$p_subcategoriesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many P_subcategories.
     *     @param {p_subcategoriesCreateManyArgs} args - Arguments to create many P_subcategories.
     *     @example
     *     // Create many P_subcategories
     *     const p_subcategories = await prisma.p_subcategories.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends p_subcategoriesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, p_subcategoriesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a P_subcategories.
     * @param {p_subcategoriesDeleteArgs} args - Arguments to delete one P_subcategories.
     * @example
     * // Delete one P_subcategories
     * const P_subcategories = await prisma.p_subcategories.delete({
     *   where: {
     *     // ... filter to delete one P_subcategories
     *   }
     * })
     * 
    **/
    delete<T extends p_subcategoriesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, p_subcategoriesDeleteArgs<ExtArgs>>
    ): Prisma__p_subcategoriesClient<$Result.GetResult<Prisma.$p_subcategoriesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one P_subcategories.
     * @param {p_subcategoriesUpdateArgs} args - Arguments to update one P_subcategories.
     * @example
     * // Update one P_subcategories
     * const p_subcategories = await prisma.p_subcategories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends p_subcategoriesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, p_subcategoriesUpdateArgs<ExtArgs>>
    ): Prisma__p_subcategoriesClient<$Result.GetResult<Prisma.$p_subcategoriesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more P_subcategories.
     * @param {p_subcategoriesDeleteManyArgs} args - Arguments to filter P_subcategories to delete.
     * @example
     * // Delete a few P_subcategories
     * const { count } = await prisma.p_subcategories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends p_subcategoriesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, p_subcategoriesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more P_subcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_subcategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many P_subcategories
     * const p_subcategories = await prisma.p_subcategories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends p_subcategoriesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, p_subcategoriesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one P_subcategories.
     * @param {p_subcategoriesUpsertArgs} args - Arguments to update or create a P_subcategories.
     * @example
     * // Update or create a P_subcategories
     * const p_subcategories = await prisma.p_subcategories.upsert({
     *   create: {
     *     // ... data to create a P_subcategories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the P_subcategories we want to update
     *   }
     * })
    **/
    upsert<T extends p_subcategoriesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, p_subcategoriesUpsertArgs<ExtArgs>>
    ): Prisma__p_subcategoriesClient<$Result.GetResult<Prisma.$p_subcategoriesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of P_subcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_subcategoriesCountArgs} args - Arguments to filter P_subcategories to count.
     * @example
     * // Count the number of P_subcategories
     * const count = await prisma.p_subcategories.count({
     *   where: {
     *     // ... the filter for the P_subcategories we want to count
     *   }
     * })
    **/
    count<T extends p_subcategoriesCountArgs>(
      args?: Subset<T, p_subcategoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], P_subcategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a P_subcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {P_subcategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends P_subcategoriesAggregateArgs>(args: Subset<T, P_subcategoriesAggregateArgs>): Prisma.PrismaPromise<GetP_subcategoriesAggregateType<T>>

    /**
     * Group by P_subcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {p_subcategoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends p_subcategoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: p_subcategoriesGroupByArgs['orderBy'] }
        : { orderBy?: p_subcategoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, p_subcategoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetP_subcategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the p_subcategories model
   */
  readonly fields: p_subcategoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for p_subcategories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__p_subcategoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the p_subcategories model
   */ 
  interface p_subcategoriesFieldRefs {
    readonly subcat_id: FieldRef<"p_subcategories", 'Int'>
    readonly cat_id: FieldRef<"p_subcategories", 'Int'>
    readonly subcat_name: FieldRef<"p_subcategories", 'String'>
    readonly subcat_name_bn: FieldRef<"p_subcategories", 'String'>
    readonly subcat_slug: FieldRef<"p_subcategories", 'String'>
    readonly subcat_meta_keyword: FieldRef<"p_subcategories", 'String'>
    readonly subcat_meta_description: FieldRef<"p_subcategories", 'String'>
    readonly subcat_position: FieldRef<"p_subcategories", 'Int'>
    readonly status: FieldRef<"p_subcategories", 'Int'>
    readonly deletable: FieldRef<"p_subcategories", 'Int'>
    readonly created_at: FieldRef<"p_subcategories", 'DateTime'>
    readonly updated_at: FieldRef<"p_subcategories", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * p_subcategories findUnique
   */
  export type p_subcategoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_subcategories
     */
    select?: p_subcategoriesSelect<ExtArgs> | null
    /**
     * Filter, which p_subcategories to fetch.
     */
    where: p_subcategoriesWhereUniqueInput
  }


  /**
   * p_subcategories findUniqueOrThrow
   */
  export type p_subcategoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_subcategories
     */
    select?: p_subcategoriesSelect<ExtArgs> | null
    /**
     * Filter, which p_subcategories to fetch.
     */
    where: p_subcategoriesWhereUniqueInput
  }


  /**
   * p_subcategories findFirst
   */
  export type p_subcategoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_subcategories
     */
    select?: p_subcategoriesSelect<ExtArgs> | null
    /**
     * Filter, which p_subcategories to fetch.
     */
    where?: p_subcategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p_subcategories to fetch.
     */
    orderBy?: p_subcategoriesOrderByWithRelationInput | p_subcategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p_subcategories.
     */
    cursor?: p_subcategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p_subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p_subcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p_subcategories.
     */
    distinct?: P_subcategoriesScalarFieldEnum | P_subcategoriesScalarFieldEnum[]
  }


  /**
   * p_subcategories findFirstOrThrow
   */
  export type p_subcategoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_subcategories
     */
    select?: p_subcategoriesSelect<ExtArgs> | null
    /**
     * Filter, which p_subcategories to fetch.
     */
    where?: p_subcategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p_subcategories to fetch.
     */
    orderBy?: p_subcategoriesOrderByWithRelationInput | p_subcategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for p_subcategories.
     */
    cursor?: p_subcategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p_subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p_subcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of p_subcategories.
     */
    distinct?: P_subcategoriesScalarFieldEnum | P_subcategoriesScalarFieldEnum[]
  }


  /**
   * p_subcategories findMany
   */
  export type p_subcategoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_subcategories
     */
    select?: p_subcategoriesSelect<ExtArgs> | null
    /**
     * Filter, which p_subcategories to fetch.
     */
    where?: p_subcategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of p_subcategories to fetch.
     */
    orderBy?: p_subcategoriesOrderByWithRelationInput | p_subcategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing p_subcategories.
     */
    cursor?: p_subcategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` p_subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` p_subcategories.
     */
    skip?: number
    distinct?: P_subcategoriesScalarFieldEnum | P_subcategoriesScalarFieldEnum[]
  }


  /**
   * p_subcategories create
   */
  export type p_subcategoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_subcategories
     */
    select?: p_subcategoriesSelect<ExtArgs> | null
    /**
     * The data needed to create a p_subcategories.
     */
    data: XOR<p_subcategoriesCreateInput, p_subcategoriesUncheckedCreateInput>
  }


  /**
   * p_subcategories createMany
   */
  export type p_subcategoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many p_subcategories.
     */
    data: p_subcategoriesCreateManyInput | p_subcategoriesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * p_subcategories update
   */
  export type p_subcategoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_subcategories
     */
    select?: p_subcategoriesSelect<ExtArgs> | null
    /**
     * The data needed to update a p_subcategories.
     */
    data: XOR<p_subcategoriesUpdateInput, p_subcategoriesUncheckedUpdateInput>
    /**
     * Choose, which p_subcategories to update.
     */
    where: p_subcategoriesWhereUniqueInput
  }


  /**
   * p_subcategories updateMany
   */
  export type p_subcategoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update p_subcategories.
     */
    data: XOR<p_subcategoriesUpdateManyMutationInput, p_subcategoriesUncheckedUpdateManyInput>
    /**
     * Filter which p_subcategories to update
     */
    where?: p_subcategoriesWhereInput
  }


  /**
   * p_subcategories upsert
   */
  export type p_subcategoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_subcategories
     */
    select?: p_subcategoriesSelect<ExtArgs> | null
    /**
     * The filter to search for the p_subcategories to update in case it exists.
     */
    where: p_subcategoriesWhereUniqueInput
    /**
     * In case the p_subcategories found by the `where` argument doesn't exist, create a new p_subcategories with this data.
     */
    create: XOR<p_subcategoriesCreateInput, p_subcategoriesUncheckedCreateInput>
    /**
     * In case the p_subcategories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<p_subcategoriesUpdateInput, p_subcategoriesUncheckedUpdateInput>
  }


  /**
   * p_subcategories delete
   */
  export type p_subcategoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_subcategories
     */
    select?: p_subcategoriesSelect<ExtArgs> | null
    /**
     * Filter which p_subcategories to delete.
     */
    where: p_subcategoriesWhereUniqueInput
  }


  /**
   * p_subcategories deleteMany
   */
  export type p_subcategoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which p_subcategories to delete
     */
    where?: p_subcategoriesWhereInput
  }


  /**
   * p_subcategories without action
   */
  export type p_subcategoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the p_subcategories
     */
    select?: p_subcategoriesSelect<ExtArgs> | null
  }



  /**
   * Model site_settings
   */

  export type AggregateSite_settings = {
    _count: Site_settingsCountAggregateOutputType | null
    _avg: Site_settingsAvgAggregateOutputType | null
    _sum: Site_settingsSumAggregateOutputType | null
    _min: Site_settingsMinAggregateOutputType | null
    _max: Site_settingsMaxAggregateOutputType | null
  }

  export type Site_settingsAvgAggregateOutputType = {
    id: number | null
    logo_header: number | null
    logo_footer: number | null
    show_special: number | null
    show_live_tv: number | null
    show_video_live_tv: number | null
  }

  export type Site_settingsSumAggregateOutputType = {
    id: number | null
    logo_header: number | null
    logo_footer: number | null
    show_special: number | null
    show_live_tv: number | null
    show_video_live_tv: number | null
  }

  export type Site_settingsMinAggregateOutputType = {
    id: number | null
    site_name: string | null
    favicon: string | null
    logo: string | null
    logo_header: number | null
    logo_footer: number | null
    title: string | null
    meta_keywords: string | null
    meta_description: string | null
    og_image: string | null
    post_ogimage: string | null
    social_links: string | null
    facebook: string | null
    twitter: string | null
    google_plus: string | null
    youtube: string | null
    instagram: string | null
    linkedin: string | null
    editor_meta: string | null
    address: string | null
    copyright: string | null
    show_special: number | null
    special_title: string | null
    special_link: string | null
    show_live_tv: number | null
    show_video_live_tv: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Site_settingsMaxAggregateOutputType = {
    id: number | null
    site_name: string | null
    favicon: string | null
    logo: string | null
    logo_header: number | null
    logo_footer: number | null
    title: string | null
    meta_keywords: string | null
    meta_description: string | null
    og_image: string | null
    post_ogimage: string | null
    social_links: string | null
    facebook: string | null
    twitter: string | null
    google_plus: string | null
    youtube: string | null
    instagram: string | null
    linkedin: string | null
    editor_meta: string | null
    address: string | null
    copyright: string | null
    show_special: number | null
    special_title: string | null
    special_link: string | null
    show_live_tv: number | null
    show_video_live_tv: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Site_settingsCountAggregateOutputType = {
    id: number
    site_name: number
    favicon: number
    logo: number
    logo_header: number
    logo_footer: number
    title: number
    meta_keywords: number
    meta_description: number
    og_image: number
    post_ogimage: number
    social_links: number
    facebook: number
    twitter: number
    google_plus: number
    youtube: number
    instagram: number
    linkedin: number
    editor_meta: number
    address: number
    copyright: number
    show_special: number
    special_title: number
    special_link: number
    show_live_tv: number
    show_video_live_tv: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Site_settingsAvgAggregateInputType = {
    id?: true
    logo_header?: true
    logo_footer?: true
    show_special?: true
    show_live_tv?: true
    show_video_live_tv?: true
  }

  export type Site_settingsSumAggregateInputType = {
    id?: true
    logo_header?: true
    logo_footer?: true
    show_special?: true
    show_live_tv?: true
    show_video_live_tv?: true
  }

  export type Site_settingsMinAggregateInputType = {
    id?: true
    site_name?: true
    favicon?: true
    logo?: true
    logo_header?: true
    logo_footer?: true
    title?: true
    meta_keywords?: true
    meta_description?: true
    og_image?: true
    post_ogimage?: true
    social_links?: true
    facebook?: true
    twitter?: true
    google_plus?: true
    youtube?: true
    instagram?: true
    linkedin?: true
    editor_meta?: true
    address?: true
    copyright?: true
    show_special?: true
    special_title?: true
    special_link?: true
    show_live_tv?: true
    show_video_live_tv?: true
    created_at?: true
    updated_at?: true
  }

  export type Site_settingsMaxAggregateInputType = {
    id?: true
    site_name?: true
    favicon?: true
    logo?: true
    logo_header?: true
    logo_footer?: true
    title?: true
    meta_keywords?: true
    meta_description?: true
    og_image?: true
    post_ogimage?: true
    social_links?: true
    facebook?: true
    twitter?: true
    google_plus?: true
    youtube?: true
    instagram?: true
    linkedin?: true
    editor_meta?: true
    address?: true
    copyright?: true
    show_special?: true
    special_title?: true
    special_link?: true
    show_live_tv?: true
    show_video_live_tv?: true
    created_at?: true
    updated_at?: true
  }

  export type Site_settingsCountAggregateInputType = {
    id?: true
    site_name?: true
    favicon?: true
    logo?: true
    logo_header?: true
    logo_footer?: true
    title?: true
    meta_keywords?: true
    meta_description?: true
    og_image?: true
    post_ogimage?: true
    social_links?: true
    facebook?: true
    twitter?: true
    google_plus?: true
    youtube?: true
    instagram?: true
    linkedin?: true
    editor_meta?: true
    address?: true
    copyright?: true
    show_special?: true
    special_title?: true
    special_link?: true
    show_live_tv?: true
    show_video_live_tv?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Site_settingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which site_settings to aggregate.
     */
    where?: site_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of site_settings to fetch.
     */
    orderBy?: site_settingsOrderByWithRelationInput | site_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: site_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` site_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` site_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned site_settings
    **/
    _count?: true | Site_settingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Site_settingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Site_settingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Site_settingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Site_settingsMaxAggregateInputType
  }

  export type GetSite_settingsAggregateType<T extends Site_settingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSite_settings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSite_settings[P]>
      : GetScalarType<T[P], AggregateSite_settings[P]>
  }




  export type site_settingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: site_settingsWhereInput
    orderBy?: site_settingsOrderByWithAggregationInput | site_settingsOrderByWithAggregationInput[]
    by: Site_settingsScalarFieldEnum[] | Site_settingsScalarFieldEnum
    having?: site_settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Site_settingsCountAggregateInputType | true
    _avg?: Site_settingsAvgAggregateInputType
    _sum?: Site_settingsSumAggregateInputType
    _min?: Site_settingsMinAggregateInputType
    _max?: Site_settingsMaxAggregateInputType
  }

  export type Site_settingsGroupByOutputType = {
    id: number
    site_name: string | null
    favicon: string | null
    logo: string | null
    logo_header: number
    logo_footer: number
    title: string | null
    meta_keywords: string | null
    meta_description: string | null
    og_image: string | null
    post_ogimage: string | null
    social_links: string | null
    facebook: string | null
    twitter: string | null
    google_plus: string | null
    youtube: string | null
    instagram: string | null
    linkedin: string | null
    editor_meta: string | null
    address: string | null
    copyright: string | null
    show_special: number
    special_title: string | null
    special_link: string | null
    show_live_tv: number
    show_video_live_tv: number
    created_at: Date | null
    updated_at: Date | null
    _count: Site_settingsCountAggregateOutputType | null
    _avg: Site_settingsAvgAggregateOutputType | null
    _sum: Site_settingsSumAggregateOutputType | null
    _min: Site_settingsMinAggregateOutputType | null
    _max: Site_settingsMaxAggregateOutputType | null
  }

  type GetSite_settingsGroupByPayload<T extends site_settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Site_settingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Site_settingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Site_settingsGroupByOutputType[P]>
            : GetScalarType<T[P], Site_settingsGroupByOutputType[P]>
        }
      >
    >


  export type site_settingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    site_name?: boolean
    favicon?: boolean
    logo?: boolean
    logo_header?: boolean
    logo_footer?: boolean
    title?: boolean
    meta_keywords?: boolean
    meta_description?: boolean
    og_image?: boolean
    post_ogimage?: boolean
    social_links?: boolean
    facebook?: boolean
    twitter?: boolean
    google_plus?: boolean
    youtube?: boolean
    instagram?: boolean
    linkedin?: boolean
    editor_meta?: boolean
    address?: boolean
    copyright?: boolean
    show_special?: boolean
    special_title?: boolean
    special_link?: boolean
    show_live_tv?: boolean
    show_video_live_tv?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["site_settings"]>

  export type site_settingsSelectScalar = {
    id?: boolean
    site_name?: boolean
    favicon?: boolean
    logo?: boolean
    logo_header?: boolean
    logo_footer?: boolean
    title?: boolean
    meta_keywords?: boolean
    meta_description?: boolean
    og_image?: boolean
    post_ogimage?: boolean
    social_links?: boolean
    facebook?: boolean
    twitter?: boolean
    google_plus?: boolean
    youtube?: boolean
    instagram?: boolean
    linkedin?: boolean
    editor_meta?: boolean
    address?: boolean
    copyright?: boolean
    show_special?: boolean
    special_title?: boolean
    special_link?: boolean
    show_live_tv?: boolean
    show_video_live_tv?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $site_settingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "site_settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      site_name: string | null
      favicon: string | null
      logo: string | null
      logo_header: number
      logo_footer: number
      title: string | null
      meta_keywords: string | null
      meta_description: string | null
      og_image: string | null
      post_ogimage: string | null
      social_links: string | null
      facebook: string | null
      twitter: string | null
      google_plus: string | null
      youtube: string | null
      instagram: string | null
      linkedin: string | null
      editor_meta: string | null
      address: string | null
      copyright: string | null
      show_special: number
      special_title: string | null
      special_link: string | null
      show_live_tv: number
      show_video_live_tv: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["site_settings"]>
    composites: {}
  }


  type site_settingsGetPayload<S extends boolean | null | undefined | site_settingsDefaultArgs> = $Result.GetResult<Prisma.$site_settingsPayload, S>

  type site_settingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<site_settingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Site_settingsCountAggregateInputType | true
    }

  export interface site_settingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['site_settings'], meta: { name: 'site_settings' } }
    /**
     * Find zero or one Site_settings that matches the filter.
     * @param {site_settingsFindUniqueArgs} args - Arguments to find a Site_settings
     * @example
     * // Get one Site_settings
     * const site_settings = await prisma.site_settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends site_settingsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, site_settingsFindUniqueArgs<ExtArgs>>
    ): Prisma__site_settingsClient<$Result.GetResult<Prisma.$site_settingsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Site_settings that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {site_settingsFindUniqueOrThrowArgs} args - Arguments to find a Site_settings
     * @example
     * // Get one Site_settings
     * const site_settings = await prisma.site_settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends site_settingsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, site_settingsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__site_settingsClient<$Result.GetResult<Prisma.$site_settingsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Site_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {site_settingsFindFirstArgs} args - Arguments to find a Site_settings
     * @example
     * // Get one Site_settings
     * const site_settings = await prisma.site_settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends site_settingsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, site_settingsFindFirstArgs<ExtArgs>>
    ): Prisma__site_settingsClient<$Result.GetResult<Prisma.$site_settingsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Site_settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {site_settingsFindFirstOrThrowArgs} args - Arguments to find a Site_settings
     * @example
     * // Get one Site_settings
     * const site_settings = await prisma.site_settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends site_settingsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, site_settingsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__site_settingsClient<$Result.GetResult<Prisma.$site_settingsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Site_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {site_settingsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Site_settings
     * const site_settings = await prisma.site_settings.findMany()
     * 
     * // Get first 10 Site_settings
     * const site_settings = await prisma.site_settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const site_settingsWithIdOnly = await prisma.site_settings.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends site_settingsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, site_settingsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$site_settingsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Site_settings.
     * @param {site_settingsCreateArgs} args - Arguments to create a Site_settings.
     * @example
     * // Create one Site_settings
     * const Site_settings = await prisma.site_settings.create({
     *   data: {
     *     // ... data to create a Site_settings
     *   }
     * })
     * 
    **/
    create<T extends site_settingsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, site_settingsCreateArgs<ExtArgs>>
    ): Prisma__site_settingsClient<$Result.GetResult<Prisma.$site_settingsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Site_settings.
     *     @param {site_settingsCreateManyArgs} args - Arguments to create many Site_settings.
     *     @example
     *     // Create many Site_settings
     *     const site_settings = await prisma.site_settings.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends site_settingsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, site_settingsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Site_settings.
     * @param {site_settingsDeleteArgs} args - Arguments to delete one Site_settings.
     * @example
     * // Delete one Site_settings
     * const Site_settings = await prisma.site_settings.delete({
     *   where: {
     *     // ... filter to delete one Site_settings
     *   }
     * })
     * 
    **/
    delete<T extends site_settingsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, site_settingsDeleteArgs<ExtArgs>>
    ): Prisma__site_settingsClient<$Result.GetResult<Prisma.$site_settingsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Site_settings.
     * @param {site_settingsUpdateArgs} args - Arguments to update one Site_settings.
     * @example
     * // Update one Site_settings
     * const site_settings = await prisma.site_settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends site_settingsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, site_settingsUpdateArgs<ExtArgs>>
    ): Prisma__site_settingsClient<$Result.GetResult<Prisma.$site_settingsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Site_settings.
     * @param {site_settingsDeleteManyArgs} args - Arguments to filter Site_settings to delete.
     * @example
     * // Delete a few Site_settings
     * const { count } = await prisma.site_settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends site_settingsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, site_settingsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Site_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {site_settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Site_settings
     * const site_settings = await prisma.site_settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends site_settingsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, site_settingsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Site_settings.
     * @param {site_settingsUpsertArgs} args - Arguments to update or create a Site_settings.
     * @example
     * // Update or create a Site_settings
     * const site_settings = await prisma.site_settings.upsert({
     *   create: {
     *     // ... data to create a Site_settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Site_settings we want to update
     *   }
     * })
    **/
    upsert<T extends site_settingsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, site_settingsUpsertArgs<ExtArgs>>
    ): Prisma__site_settingsClient<$Result.GetResult<Prisma.$site_settingsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Site_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {site_settingsCountArgs} args - Arguments to filter Site_settings to count.
     * @example
     * // Count the number of Site_settings
     * const count = await prisma.site_settings.count({
     *   where: {
     *     // ... the filter for the Site_settings we want to count
     *   }
     * })
    **/
    count<T extends site_settingsCountArgs>(
      args?: Subset<T, site_settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Site_settingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Site_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Site_settingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Site_settingsAggregateArgs>(args: Subset<T, Site_settingsAggregateArgs>): Prisma.PrismaPromise<GetSite_settingsAggregateType<T>>

    /**
     * Group by Site_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {site_settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends site_settingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: site_settingsGroupByArgs['orderBy'] }
        : { orderBy?: site_settingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, site_settingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSite_settingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the site_settings model
   */
  readonly fields: site_settingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for site_settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__site_settingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the site_settings model
   */ 
  interface site_settingsFieldRefs {
    readonly id: FieldRef<"site_settings", 'Int'>
    readonly site_name: FieldRef<"site_settings", 'String'>
    readonly favicon: FieldRef<"site_settings", 'String'>
    readonly logo: FieldRef<"site_settings", 'String'>
    readonly logo_header: FieldRef<"site_settings", 'Int'>
    readonly logo_footer: FieldRef<"site_settings", 'Int'>
    readonly title: FieldRef<"site_settings", 'String'>
    readonly meta_keywords: FieldRef<"site_settings", 'String'>
    readonly meta_description: FieldRef<"site_settings", 'String'>
    readonly og_image: FieldRef<"site_settings", 'String'>
    readonly post_ogimage: FieldRef<"site_settings", 'String'>
    readonly social_links: FieldRef<"site_settings", 'String'>
    readonly facebook: FieldRef<"site_settings", 'String'>
    readonly twitter: FieldRef<"site_settings", 'String'>
    readonly google_plus: FieldRef<"site_settings", 'String'>
    readonly youtube: FieldRef<"site_settings", 'String'>
    readonly instagram: FieldRef<"site_settings", 'String'>
    readonly linkedin: FieldRef<"site_settings", 'String'>
    readonly editor_meta: FieldRef<"site_settings", 'String'>
    readonly address: FieldRef<"site_settings", 'String'>
    readonly copyright: FieldRef<"site_settings", 'String'>
    readonly show_special: FieldRef<"site_settings", 'Int'>
    readonly special_title: FieldRef<"site_settings", 'String'>
    readonly special_link: FieldRef<"site_settings", 'String'>
    readonly show_live_tv: FieldRef<"site_settings", 'Int'>
    readonly show_video_live_tv: FieldRef<"site_settings", 'Int'>
    readonly created_at: FieldRef<"site_settings", 'DateTime'>
    readonly updated_at: FieldRef<"site_settings", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * site_settings findUnique
   */
  export type site_settingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the site_settings
     */
    select?: site_settingsSelect<ExtArgs> | null
    /**
     * Filter, which site_settings to fetch.
     */
    where: site_settingsWhereUniqueInput
  }


  /**
   * site_settings findUniqueOrThrow
   */
  export type site_settingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the site_settings
     */
    select?: site_settingsSelect<ExtArgs> | null
    /**
     * Filter, which site_settings to fetch.
     */
    where: site_settingsWhereUniqueInput
  }


  /**
   * site_settings findFirst
   */
  export type site_settingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the site_settings
     */
    select?: site_settingsSelect<ExtArgs> | null
    /**
     * Filter, which site_settings to fetch.
     */
    where?: site_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of site_settings to fetch.
     */
    orderBy?: site_settingsOrderByWithRelationInput | site_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for site_settings.
     */
    cursor?: site_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` site_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` site_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of site_settings.
     */
    distinct?: Site_settingsScalarFieldEnum | Site_settingsScalarFieldEnum[]
  }


  /**
   * site_settings findFirstOrThrow
   */
  export type site_settingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the site_settings
     */
    select?: site_settingsSelect<ExtArgs> | null
    /**
     * Filter, which site_settings to fetch.
     */
    where?: site_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of site_settings to fetch.
     */
    orderBy?: site_settingsOrderByWithRelationInput | site_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for site_settings.
     */
    cursor?: site_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` site_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` site_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of site_settings.
     */
    distinct?: Site_settingsScalarFieldEnum | Site_settingsScalarFieldEnum[]
  }


  /**
   * site_settings findMany
   */
  export type site_settingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the site_settings
     */
    select?: site_settingsSelect<ExtArgs> | null
    /**
     * Filter, which site_settings to fetch.
     */
    where?: site_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of site_settings to fetch.
     */
    orderBy?: site_settingsOrderByWithRelationInput | site_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing site_settings.
     */
    cursor?: site_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` site_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` site_settings.
     */
    skip?: number
    distinct?: Site_settingsScalarFieldEnum | Site_settingsScalarFieldEnum[]
  }


  /**
   * site_settings create
   */
  export type site_settingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the site_settings
     */
    select?: site_settingsSelect<ExtArgs> | null
    /**
     * The data needed to create a site_settings.
     */
    data?: XOR<site_settingsCreateInput, site_settingsUncheckedCreateInput>
  }


  /**
   * site_settings createMany
   */
  export type site_settingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many site_settings.
     */
    data: site_settingsCreateManyInput | site_settingsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * site_settings update
   */
  export type site_settingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the site_settings
     */
    select?: site_settingsSelect<ExtArgs> | null
    /**
     * The data needed to update a site_settings.
     */
    data: XOR<site_settingsUpdateInput, site_settingsUncheckedUpdateInput>
    /**
     * Choose, which site_settings to update.
     */
    where: site_settingsWhereUniqueInput
  }


  /**
   * site_settings updateMany
   */
  export type site_settingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update site_settings.
     */
    data: XOR<site_settingsUpdateManyMutationInput, site_settingsUncheckedUpdateManyInput>
    /**
     * Filter which site_settings to update
     */
    where?: site_settingsWhereInput
  }


  /**
   * site_settings upsert
   */
  export type site_settingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the site_settings
     */
    select?: site_settingsSelect<ExtArgs> | null
    /**
     * The filter to search for the site_settings to update in case it exists.
     */
    where: site_settingsWhereUniqueInput
    /**
     * In case the site_settings found by the `where` argument doesn't exist, create a new site_settings with this data.
     */
    create: XOR<site_settingsCreateInput, site_settingsUncheckedCreateInput>
    /**
     * In case the site_settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<site_settingsUpdateInput, site_settingsUncheckedUpdateInput>
  }


  /**
   * site_settings delete
   */
  export type site_settingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the site_settings
     */
    select?: site_settingsSelect<ExtArgs> | null
    /**
     * Filter which site_settings to delete.
     */
    where: site_settingsWhereUniqueInput
  }


  /**
   * site_settings deleteMany
   */
  export type site_settingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which site_settings to delete
     */
    where?: site_settingsWhereInput
  }


  /**
   * site_settings without action
   */
  export type site_settingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the site_settings
     */
    select?: site_settingsSelect<ExtArgs> | null
  }



  /**
   * Model surveys
   */

  export type AggregateSurveys = {
    _count: SurveysCountAggregateOutputType | null
    _avg: SurveysAvgAggregateOutputType | null
    _sum: SurveysSumAggregateOutputType | null
    _min: SurveysMinAggregateOutputType | null
    _max: SurveysMaxAggregateOutputType | null
  }

  export type SurveysAvgAggregateOutputType = {
    survey_id: number | null
    ha: number | null
    na: number | null
    no_comment: number | null
    status: number | null
    deletable: number | null
  }

  export type SurveysSumAggregateOutputType = {
    survey_id: number | null
    ha: number | null
    na: number | null
    no_comment: number | null
    status: number | null
    deletable: number | null
  }

  export type SurveysMinAggregateOutputType = {
    survey_id: number | null
    title: string | null
    from_date: Date | null
    to_date: Date | null
    ha: number | null
    na: number | null
    no_comment: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SurveysMaxAggregateOutputType = {
    survey_id: number | null
    title: string | null
    from_date: Date | null
    to_date: Date | null
    ha: number | null
    na: number | null
    no_comment: number | null
    status: number | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SurveysCountAggregateOutputType = {
    survey_id: number
    title: number
    from_date: number
    to_date: number
    ha: number
    na: number
    no_comment: number
    status: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SurveysAvgAggregateInputType = {
    survey_id?: true
    ha?: true
    na?: true
    no_comment?: true
    status?: true
    deletable?: true
  }

  export type SurveysSumAggregateInputType = {
    survey_id?: true
    ha?: true
    na?: true
    no_comment?: true
    status?: true
    deletable?: true
  }

  export type SurveysMinAggregateInputType = {
    survey_id?: true
    title?: true
    from_date?: true
    to_date?: true
    ha?: true
    na?: true
    no_comment?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type SurveysMaxAggregateInputType = {
    survey_id?: true
    title?: true
    from_date?: true
    to_date?: true
    ha?: true
    na?: true
    no_comment?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type SurveysCountAggregateInputType = {
    survey_id?: true
    title?: true
    from_date?: true
    to_date?: true
    ha?: true
    na?: true
    no_comment?: true
    status?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SurveysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which surveys to aggregate.
     */
    where?: surveysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveys to fetch.
     */
    orderBy?: surveysOrderByWithRelationInput | surveysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: surveysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned surveys
    **/
    _count?: true | SurveysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SurveysAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SurveysSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveysMaxAggregateInputType
  }

  export type GetSurveysAggregateType<T extends SurveysAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveys[P]>
      : GetScalarType<T[P], AggregateSurveys[P]>
  }




  export type surveysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: surveysWhereInput
    orderBy?: surveysOrderByWithAggregationInput | surveysOrderByWithAggregationInput[]
    by: SurveysScalarFieldEnum[] | SurveysScalarFieldEnum
    having?: surveysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveysCountAggregateInputType | true
    _avg?: SurveysAvgAggregateInputType
    _sum?: SurveysSumAggregateInputType
    _min?: SurveysMinAggregateInputType
    _max?: SurveysMaxAggregateInputType
  }

  export type SurveysGroupByOutputType = {
    survey_id: number
    title: string
    from_date: Date | null
    to_date: Date
    ha: number
    na: number
    no_comment: number
    status: number
    deletable: number
    created_at: Date | null
    updated_at: Date | null
    _count: SurveysCountAggregateOutputType | null
    _avg: SurveysAvgAggregateOutputType | null
    _sum: SurveysSumAggregateOutputType | null
    _min: SurveysMinAggregateOutputType | null
    _max: SurveysMaxAggregateOutputType | null
  }

  type GetSurveysGroupByPayload<T extends surveysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveysGroupByOutputType[P]>
            : GetScalarType<T[P], SurveysGroupByOutputType[P]>
        }
      >
    >


  export type surveysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    survey_id?: boolean
    title?: boolean
    from_date?: boolean
    to_date?: boolean
    ha?: boolean
    na?: boolean
    no_comment?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["surveys"]>

  export type surveysSelectScalar = {
    survey_id?: boolean
    title?: boolean
    from_date?: boolean
    to_date?: boolean
    ha?: boolean
    na?: boolean
    no_comment?: boolean
    status?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $surveysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "surveys"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      survey_id: number
      title: string
      from_date: Date | null
      to_date: Date
      ha: number
      na: number
      no_comment: number
      status: number
      deletable: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["surveys"]>
    composites: {}
  }


  type surveysGetPayload<S extends boolean | null | undefined | surveysDefaultArgs> = $Result.GetResult<Prisma.$surveysPayload, S>

  type surveysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<surveysFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SurveysCountAggregateInputType | true
    }

  export interface surveysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['surveys'], meta: { name: 'surveys' } }
    /**
     * Find zero or one Surveys that matches the filter.
     * @param {surveysFindUniqueArgs} args - Arguments to find a Surveys
     * @example
     * // Get one Surveys
     * const surveys = await prisma.surveys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends surveysFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, surveysFindUniqueArgs<ExtArgs>>
    ): Prisma__surveysClient<$Result.GetResult<Prisma.$surveysPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Surveys that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {surveysFindUniqueOrThrowArgs} args - Arguments to find a Surveys
     * @example
     * // Get one Surveys
     * const surveys = await prisma.surveys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends surveysFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, surveysFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__surveysClient<$Result.GetResult<Prisma.$surveysPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Surveys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveysFindFirstArgs} args - Arguments to find a Surveys
     * @example
     * // Get one Surveys
     * const surveys = await prisma.surveys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends surveysFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, surveysFindFirstArgs<ExtArgs>>
    ): Prisma__surveysClient<$Result.GetResult<Prisma.$surveysPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Surveys that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveysFindFirstOrThrowArgs} args - Arguments to find a Surveys
     * @example
     * // Get one Surveys
     * const surveys = await prisma.surveys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends surveysFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, surveysFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__surveysClient<$Result.GetResult<Prisma.$surveysPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Surveys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveysFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Surveys
     * const surveys = await prisma.surveys.findMany()
     * 
     * // Get first 10 Surveys
     * const surveys = await prisma.surveys.findMany({ take: 10 })
     * 
     * // Only select the `survey_id`
     * const surveysWithSurvey_idOnly = await prisma.surveys.findMany({ select: { survey_id: true } })
     * 
    **/
    findMany<T extends surveysFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, surveysFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$surveysPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Surveys.
     * @param {surveysCreateArgs} args - Arguments to create a Surveys.
     * @example
     * // Create one Surveys
     * const Surveys = await prisma.surveys.create({
     *   data: {
     *     // ... data to create a Surveys
     *   }
     * })
     * 
    **/
    create<T extends surveysCreateArgs<ExtArgs>>(
      args: SelectSubset<T, surveysCreateArgs<ExtArgs>>
    ): Prisma__surveysClient<$Result.GetResult<Prisma.$surveysPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Surveys.
     *     @param {surveysCreateManyArgs} args - Arguments to create many Surveys.
     *     @example
     *     // Create many Surveys
     *     const surveys = await prisma.surveys.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends surveysCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, surveysCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Surveys.
     * @param {surveysDeleteArgs} args - Arguments to delete one Surveys.
     * @example
     * // Delete one Surveys
     * const Surveys = await prisma.surveys.delete({
     *   where: {
     *     // ... filter to delete one Surveys
     *   }
     * })
     * 
    **/
    delete<T extends surveysDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, surveysDeleteArgs<ExtArgs>>
    ): Prisma__surveysClient<$Result.GetResult<Prisma.$surveysPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Surveys.
     * @param {surveysUpdateArgs} args - Arguments to update one Surveys.
     * @example
     * // Update one Surveys
     * const surveys = await prisma.surveys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends surveysUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, surveysUpdateArgs<ExtArgs>>
    ): Prisma__surveysClient<$Result.GetResult<Prisma.$surveysPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Surveys.
     * @param {surveysDeleteManyArgs} args - Arguments to filter Surveys to delete.
     * @example
     * // Delete a few Surveys
     * const { count } = await prisma.surveys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends surveysDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, surveysDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Surveys
     * const surveys = await prisma.surveys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends surveysUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, surveysUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Surveys.
     * @param {surveysUpsertArgs} args - Arguments to update or create a Surveys.
     * @example
     * // Update or create a Surveys
     * const surveys = await prisma.surveys.upsert({
     *   create: {
     *     // ... data to create a Surveys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Surveys we want to update
     *   }
     * })
    **/
    upsert<T extends surveysUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, surveysUpsertArgs<ExtArgs>>
    ): Prisma__surveysClient<$Result.GetResult<Prisma.$surveysPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveysCountArgs} args - Arguments to filter Surveys to count.
     * @example
     * // Count the number of Surveys
     * const count = await prisma.surveys.count({
     *   where: {
     *     // ... the filter for the Surveys we want to count
     *   }
     * })
    **/
    count<T extends surveysCountArgs>(
      args?: Subset<T, surveysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveysAggregateArgs>(args: Subset<T, SurveysAggregateArgs>): Prisma.PrismaPromise<GetSurveysAggregateType<T>>

    /**
     * Group by Surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends surveysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: surveysGroupByArgs['orderBy'] }
        : { orderBy?: surveysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, surveysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the surveys model
   */
  readonly fields: surveysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for surveys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__surveysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the surveys model
   */ 
  interface surveysFieldRefs {
    readonly survey_id: FieldRef<"surveys", 'Int'>
    readonly title: FieldRef<"surveys", 'String'>
    readonly from_date: FieldRef<"surveys", 'DateTime'>
    readonly to_date: FieldRef<"surveys", 'DateTime'>
    readonly ha: FieldRef<"surveys", 'Int'>
    readonly na: FieldRef<"surveys", 'Int'>
    readonly no_comment: FieldRef<"surveys", 'Int'>
    readonly status: FieldRef<"surveys", 'Int'>
    readonly deletable: FieldRef<"surveys", 'Int'>
    readonly created_at: FieldRef<"surveys", 'DateTime'>
    readonly updated_at: FieldRef<"surveys", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * surveys findUnique
   */
  export type surveysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveys
     */
    select?: surveysSelect<ExtArgs> | null
    /**
     * Filter, which surveys to fetch.
     */
    where: surveysWhereUniqueInput
  }


  /**
   * surveys findUniqueOrThrow
   */
  export type surveysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveys
     */
    select?: surveysSelect<ExtArgs> | null
    /**
     * Filter, which surveys to fetch.
     */
    where: surveysWhereUniqueInput
  }


  /**
   * surveys findFirst
   */
  export type surveysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveys
     */
    select?: surveysSelect<ExtArgs> | null
    /**
     * Filter, which surveys to fetch.
     */
    where?: surveysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveys to fetch.
     */
    orderBy?: surveysOrderByWithRelationInput | surveysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for surveys.
     */
    cursor?: surveysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of surveys.
     */
    distinct?: SurveysScalarFieldEnum | SurveysScalarFieldEnum[]
  }


  /**
   * surveys findFirstOrThrow
   */
  export type surveysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveys
     */
    select?: surveysSelect<ExtArgs> | null
    /**
     * Filter, which surveys to fetch.
     */
    where?: surveysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveys to fetch.
     */
    orderBy?: surveysOrderByWithRelationInput | surveysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for surveys.
     */
    cursor?: surveysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of surveys.
     */
    distinct?: SurveysScalarFieldEnum | SurveysScalarFieldEnum[]
  }


  /**
   * surveys findMany
   */
  export type surveysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveys
     */
    select?: surveysSelect<ExtArgs> | null
    /**
     * Filter, which surveys to fetch.
     */
    where?: surveysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveys to fetch.
     */
    orderBy?: surveysOrderByWithRelationInput | surveysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing surveys.
     */
    cursor?: surveysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveys.
     */
    skip?: number
    distinct?: SurveysScalarFieldEnum | SurveysScalarFieldEnum[]
  }


  /**
   * surveys create
   */
  export type surveysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveys
     */
    select?: surveysSelect<ExtArgs> | null
    /**
     * The data needed to create a surveys.
     */
    data: XOR<surveysCreateInput, surveysUncheckedCreateInput>
  }


  /**
   * surveys createMany
   */
  export type surveysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many surveys.
     */
    data: surveysCreateManyInput | surveysCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * surveys update
   */
  export type surveysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveys
     */
    select?: surveysSelect<ExtArgs> | null
    /**
     * The data needed to update a surveys.
     */
    data: XOR<surveysUpdateInput, surveysUncheckedUpdateInput>
    /**
     * Choose, which surveys to update.
     */
    where: surveysWhereUniqueInput
  }


  /**
   * surveys updateMany
   */
  export type surveysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update surveys.
     */
    data: XOR<surveysUpdateManyMutationInput, surveysUncheckedUpdateManyInput>
    /**
     * Filter which surveys to update
     */
    where?: surveysWhereInput
  }


  /**
   * surveys upsert
   */
  export type surveysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveys
     */
    select?: surveysSelect<ExtArgs> | null
    /**
     * The filter to search for the surveys to update in case it exists.
     */
    where: surveysWhereUniqueInput
    /**
     * In case the surveys found by the `where` argument doesn't exist, create a new surveys with this data.
     */
    create: XOR<surveysCreateInput, surveysUncheckedCreateInput>
    /**
     * In case the surveys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<surveysUpdateInput, surveysUncheckedUpdateInput>
  }


  /**
   * surveys delete
   */
  export type surveysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveys
     */
    select?: surveysSelect<ExtArgs> | null
    /**
     * Filter which surveys to delete.
     */
    where: surveysWhereUniqueInput
  }


  /**
   * surveys deleteMany
   */
  export type surveysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which surveys to delete
     */
    where?: surveysWhereInput
  }


  /**
   * surveys without action
   */
  export type surveysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveys
     */
    select?: surveysSelect<ExtArgs> | null
  }



  /**
   * Model upozillas
   */

  export type AggregateUpozillas = {
    _count: UpozillasCountAggregateOutputType | null
    _avg: UpozillasAvgAggregateOutputType | null
    _sum: UpozillasSumAggregateOutputType | null
    _min: UpozillasMinAggregateOutputType | null
    _max: UpozillasMaxAggregateOutputType | null
  }

  export type UpozillasAvgAggregateOutputType = {
    upozilla_id: number | null
    district_id: number | null
    division_id: number | null
    deletable: number | null
  }

  export type UpozillasSumAggregateOutputType = {
    upozilla_id: number | null
    district_id: number | null
    division_id: number | null
    deletable: number | null
  }

  export type UpozillasMinAggregateOutputType = {
    upozilla_id: number | null
    district_id: number | null
    division_id: number | null
    upozilla_name: string | null
    upozilla_name_bn: string | null
    upozilla_title: string | null
    upozilla_slug: string | null
    meta_description: string | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UpozillasMaxAggregateOutputType = {
    upozilla_id: number | null
    district_id: number | null
    division_id: number | null
    upozilla_name: string | null
    upozilla_name_bn: string | null
    upozilla_title: string | null
    upozilla_slug: string | null
    meta_description: string | null
    deletable: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UpozillasCountAggregateOutputType = {
    upozilla_id: number
    district_id: number
    division_id: number
    upozilla_name: number
    upozilla_name_bn: number
    upozilla_title: number
    upozilla_slug: number
    meta_description: number
    deletable: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UpozillasAvgAggregateInputType = {
    upozilla_id?: true
    district_id?: true
    division_id?: true
    deletable?: true
  }

  export type UpozillasSumAggregateInputType = {
    upozilla_id?: true
    district_id?: true
    division_id?: true
    deletable?: true
  }

  export type UpozillasMinAggregateInputType = {
    upozilla_id?: true
    district_id?: true
    division_id?: true
    upozilla_name?: true
    upozilla_name_bn?: true
    upozilla_title?: true
    upozilla_slug?: true
    meta_description?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type UpozillasMaxAggregateInputType = {
    upozilla_id?: true
    district_id?: true
    division_id?: true
    upozilla_name?: true
    upozilla_name_bn?: true
    upozilla_title?: true
    upozilla_slug?: true
    meta_description?: true
    deletable?: true
    created_at?: true
    updated_at?: true
  }

  export type UpozillasCountAggregateInputType = {
    upozilla_id?: true
    district_id?: true
    division_id?: true
    upozilla_name?: true
    upozilla_name_bn?: true
    upozilla_title?: true
    upozilla_slug?: true
    meta_description?: true
    deletable?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UpozillasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which upozillas to aggregate.
     */
    where?: upozillasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of upozillas to fetch.
     */
    orderBy?: upozillasOrderByWithRelationInput | upozillasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: upozillasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` upozillas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` upozillas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned upozillas
    **/
    _count?: true | UpozillasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UpozillasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UpozillasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UpozillasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UpozillasMaxAggregateInputType
  }

  export type GetUpozillasAggregateType<T extends UpozillasAggregateArgs> = {
        [P in keyof T & keyof AggregateUpozillas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUpozillas[P]>
      : GetScalarType<T[P], AggregateUpozillas[P]>
  }




  export type upozillasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: upozillasWhereInput
    orderBy?: upozillasOrderByWithAggregationInput | upozillasOrderByWithAggregationInput[]
    by: UpozillasScalarFieldEnum[] | UpozillasScalarFieldEnum
    having?: upozillasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UpozillasCountAggregateInputType | true
    _avg?: UpozillasAvgAggregateInputType
    _sum?: UpozillasSumAggregateInputType
    _min?: UpozillasMinAggregateInputType
    _max?: UpozillasMaxAggregateInputType
  }

  export type UpozillasGroupByOutputType = {
    upozilla_id: number
    district_id: number
    division_id: number
    upozilla_name: string
    upozilla_name_bn: string
    upozilla_title: string | null
    upozilla_slug: string
    meta_description: string | null
    deletable: number
    created_at: Date | null
    updated_at: Date | null
    _count: UpozillasCountAggregateOutputType | null
    _avg: UpozillasAvgAggregateOutputType | null
    _sum: UpozillasSumAggregateOutputType | null
    _min: UpozillasMinAggregateOutputType | null
    _max: UpozillasMaxAggregateOutputType | null
  }

  type GetUpozillasGroupByPayload<T extends upozillasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UpozillasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UpozillasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UpozillasGroupByOutputType[P]>
            : GetScalarType<T[P], UpozillasGroupByOutputType[P]>
        }
      >
    >


  export type upozillasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    upozilla_id?: boolean
    district_id?: boolean
    division_id?: boolean
    upozilla_name?: boolean
    upozilla_name_bn?: boolean
    upozilla_title?: boolean
    upozilla_slug?: boolean
    meta_description?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["upozillas"]>

  export type upozillasSelectScalar = {
    upozilla_id?: boolean
    district_id?: boolean
    division_id?: boolean
    upozilla_name?: boolean
    upozilla_name_bn?: boolean
    upozilla_title?: boolean
    upozilla_slug?: boolean
    meta_description?: boolean
    deletable?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $upozillasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "upozillas"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      upozilla_id: number
      district_id: number
      division_id: number
      upozilla_name: string
      upozilla_name_bn: string
      upozilla_title: string | null
      upozilla_slug: string
      meta_description: string | null
      deletable: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["upozillas"]>
    composites: {}
  }


  type upozillasGetPayload<S extends boolean | null | undefined | upozillasDefaultArgs> = $Result.GetResult<Prisma.$upozillasPayload, S>

  type upozillasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<upozillasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UpozillasCountAggregateInputType | true
    }

  export interface upozillasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['upozillas'], meta: { name: 'upozillas' } }
    /**
     * Find zero or one Upozillas that matches the filter.
     * @param {upozillasFindUniqueArgs} args - Arguments to find a Upozillas
     * @example
     * // Get one Upozillas
     * const upozillas = await prisma.upozillas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends upozillasFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, upozillasFindUniqueArgs<ExtArgs>>
    ): Prisma__upozillasClient<$Result.GetResult<Prisma.$upozillasPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Upozillas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {upozillasFindUniqueOrThrowArgs} args - Arguments to find a Upozillas
     * @example
     * // Get one Upozillas
     * const upozillas = await prisma.upozillas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends upozillasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, upozillasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__upozillasClient<$Result.GetResult<Prisma.$upozillasPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Upozillas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {upozillasFindFirstArgs} args - Arguments to find a Upozillas
     * @example
     * // Get one Upozillas
     * const upozillas = await prisma.upozillas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends upozillasFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, upozillasFindFirstArgs<ExtArgs>>
    ): Prisma__upozillasClient<$Result.GetResult<Prisma.$upozillasPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Upozillas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {upozillasFindFirstOrThrowArgs} args - Arguments to find a Upozillas
     * @example
     * // Get one Upozillas
     * const upozillas = await prisma.upozillas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends upozillasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, upozillasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__upozillasClient<$Result.GetResult<Prisma.$upozillasPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Upozillas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {upozillasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Upozillas
     * const upozillas = await prisma.upozillas.findMany()
     * 
     * // Get first 10 Upozillas
     * const upozillas = await prisma.upozillas.findMany({ take: 10 })
     * 
     * // Only select the `upozilla_id`
     * const upozillasWithUpozilla_idOnly = await prisma.upozillas.findMany({ select: { upozilla_id: true } })
     * 
    **/
    findMany<T extends upozillasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, upozillasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$upozillasPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Upozillas.
     * @param {upozillasCreateArgs} args - Arguments to create a Upozillas.
     * @example
     * // Create one Upozillas
     * const Upozillas = await prisma.upozillas.create({
     *   data: {
     *     // ... data to create a Upozillas
     *   }
     * })
     * 
    **/
    create<T extends upozillasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, upozillasCreateArgs<ExtArgs>>
    ): Prisma__upozillasClient<$Result.GetResult<Prisma.$upozillasPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Upozillas.
     *     @param {upozillasCreateManyArgs} args - Arguments to create many Upozillas.
     *     @example
     *     // Create many Upozillas
     *     const upozillas = await prisma.upozillas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends upozillasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, upozillasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Upozillas.
     * @param {upozillasDeleteArgs} args - Arguments to delete one Upozillas.
     * @example
     * // Delete one Upozillas
     * const Upozillas = await prisma.upozillas.delete({
     *   where: {
     *     // ... filter to delete one Upozillas
     *   }
     * })
     * 
    **/
    delete<T extends upozillasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, upozillasDeleteArgs<ExtArgs>>
    ): Prisma__upozillasClient<$Result.GetResult<Prisma.$upozillasPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Upozillas.
     * @param {upozillasUpdateArgs} args - Arguments to update one Upozillas.
     * @example
     * // Update one Upozillas
     * const upozillas = await prisma.upozillas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends upozillasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, upozillasUpdateArgs<ExtArgs>>
    ): Prisma__upozillasClient<$Result.GetResult<Prisma.$upozillasPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Upozillas.
     * @param {upozillasDeleteManyArgs} args - Arguments to filter Upozillas to delete.
     * @example
     * // Delete a few Upozillas
     * const { count } = await prisma.upozillas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends upozillasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, upozillasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Upozillas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {upozillasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Upozillas
     * const upozillas = await prisma.upozillas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends upozillasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, upozillasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Upozillas.
     * @param {upozillasUpsertArgs} args - Arguments to update or create a Upozillas.
     * @example
     * // Update or create a Upozillas
     * const upozillas = await prisma.upozillas.upsert({
     *   create: {
     *     // ... data to create a Upozillas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Upozillas we want to update
     *   }
     * })
    **/
    upsert<T extends upozillasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, upozillasUpsertArgs<ExtArgs>>
    ): Prisma__upozillasClient<$Result.GetResult<Prisma.$upozillasPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Upozillas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {upozillasCountArgs} args - Arguments to filter Upozillas to count.
     * @example
     * // Count the number of Upozillas
     * const count = await prisma.upozillas.count({
     *   where: {
     *     // ... the filter for the Upozillas we want to count
     *   }
     * })
    **/
    count<T extends upozillasCountArgs>(
      args?: Subset<T, upozillasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UpozillasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Upozillas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpozillasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UpozillasAggregateArgs>(args: Subset<T, UpozillasAggregateArgs>): Prisma.PrismaPromise<GetUpozillasAggregateType<T>>

    /**
     * Group by Upozillas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {upozillasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends upozillasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: upozillasGroupByArgs['orderBy'] }
        : { orderBy?: upozillasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, upozillasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUpozillasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the upozillas model
   */
  readonly fields: upozillasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for upozillas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__upozillasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the upozillas model
   */ 
  interface upozillasFieldRefs {
    readonly upozilla_id: FieldRef<"upozillas", 'Int'>
    readonly district_id: FieldRef<"upozillas", 'Int'>
    readonly division_id: FieldRef<"upozillas", 'Int'>
    readonly upozilla_name: FieldRef<"upozillas", 'String'>
    readonly upozilla_name_bn: FieldRef<"upozillas", 'String'>
    readonly upozilla_title: FieldRef<"upozillas", 'String'>
    readonly upozilla_slug: FieldRef<"upozillas", 'String'>
    readonly meta_description: FieldRef<"upozillas", 'String'>
    readonly deletable: FieldRef<"upozillas", 'Int'>
    readonly created_at: FieldRef<"upozillas", 'DateTime'>
    readonly updated_at: FieldRef<"upozillas", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * upozillas findUnique
   */
  export type upozillasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upozillas
     */
    select?: upozillasSelect<ExtArgs> | null
    /**
     * Filter, which upozillas to fetch.
     */
    where: upozillasWhereUniqueInput
  }


  /**
   * upozillas findUniqueOrThrow
   */
  export type upozillasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upozillas
     */
    select?: upozillasSelect<ExtArgs> | null
    /**
     * Filter, which upozillas to fetch.
     */
    where: upozillasWhereUniqueInput
  }


  /**
   * upozillas findFirst
   */
  export type upozillasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upozillas
     */
    select?: upozillasSelect<ExtArgs> | null
    /**
     * Filter, which upozillas to fetch.
     */
    where?: upozillasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of upozillas to fetch.
     */
    orderBy?: upozillasOrderByWithRelationInput | upozillasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for upozillas.
     */
    cursor?: upozillasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` upozillas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` upozillas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of upozillas.
     */
    distinct?: UpozillasScalarFieldEnum | UpozillasScalarFieldEnum[]
  }


  /**
   * upozillas findFirstOrThrow
   */
  export type upozillasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upozillas
     */
    select?: upozillasSelect<ExtArgs> | null
    /**
     * Filter, which upozillas to fetch.
     */
    where?: upozillasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of upozillas to fetch.
     */
    orderBy?: upozillasOrderByWithRelationInput | upozillasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for upozillas.
     */
    cursor?: upozillasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` upozillas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` upozillas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of upozillas.
     */
    distinct?: UpozillasScalarFieldEnum | UpozillasScalarFieldEnum[]
  }


  /**
   * upozillas findMany
   */
  export type upozillasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upozillas
     */
    select?: upozillasSelect<ExtArgs> | null
    /**
     * Filter, which upozillas to fetch.
     */
    where?: upozillasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of upozillas to fetch.
     */
    orderBy?: upozillasOrderByWithRelationInput | upozillasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing upozillas.
     */
    cursor?: upozillasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` upozillas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` upozillas.
     */
    skip?: number
    distinct?: UpozillasScalarFieldEnum | UpozillasScalarFieldEnum[]
  }


  /**
   * upozillas create
   */
  export type upozillasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upozillas
     */
    select?: upozillasSelect<ExtArgs> | null
    /**
     * The data needed to create a upozillas.
     */
    data: XOR<upozillasCreateInput, upozillasUncheckedCreateInput>
  }


  /**
   * upozillas createMany
   */
  export type upozillasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many upozillas.
     */
    data: upozillasCreateManyInput | upozillasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * upozillas update
   */
  export type upozillasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upozillas
     */
    select?: upozillasSelect<ExtArgs> | null
    /**
     * The data needed to update a upozillas.
     */
    data: XOR<upozillasUpdateInput, upozillasUncheckedUpdateInput>
    /**
     * Choose, which upozillas to update.
     */
    where: upozillasWhereUniqueInput
  }


  /**
   * upozillas updateMany
   */
  export type upozillasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update upozillas.
     */
    data: XOR<upozillasUpdateManyMutationInput, upozillasUncheckedUpdateManyInput>
    /**
     * Filter which upozillas to update
     */
    where?: upozillasWhereInput
  }


  /**
   * upozillas upsert
   */
  export type upozillasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upozillas
     */
    select?: upozillasSelect<ExtArgs> | null
    /**
     * The filter to search for the upozillas to update in case it exists.
     */
    where: upozillasWhereUniqueInput
    /**
     * In case the upozillas found by the `where` argument doesn't exist, create a new upozillas with this data.
     */
    create: XOR<upozillasCreateInput, upozillasUncheckedCreateInput>
    /**
     * In case the upozillas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<upozillasUpdateInput, upozillasUncheckedUpdateInput>
  }


  /**
   * upozillas delete
   */
  export type upozillasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upozillas
     */
    select?: upozillasSelect<ExtArgs> | null
    /**
     * Filter which upozillas to delete.
     */
    where: upozillasWhereUniqueInput
  }


  /**
   * upozillas deleteMany
   */
  export type upozillasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which upozillas to delete
     */
    where?: upozillasWhereInput
  }


  /**
   * upozillas without action
   */
  export type upozillasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upozillas
     */
    select?: upozillasSelect<ExtArgs> | null
  }



  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
    role: number | null
    status: number | null
    visibility: number | null
    deletable: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
    role: number | null
    status: number | null
    visibility: number | null
    deletable: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    name: string | null
    designation: string | null
    username: string | null
    email: string | null
    email_verified_at: Date | null
    password: string | null
    two_factor_secret: string | null
    two_factor_recovery_codes: string | null
    role: number | null
    bn_cat_ids: string | null
    status: number | null
    visibility: number | null
    deletable: number | null
    remember_token: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    designation: string | null
    username: string | null
    email: string | null
    email_verified_at: Date | null
    password: string | null
    two_factor_secret: string | null
    two_factor_recovery_codes: string | null
    role: number | null
    bn_cat_ids: string | null
    status: number | null
    visibility: number | null
    deletable: number | null
    remember_token: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    name: number
    designation: number
    username: number
    email: number
    email_verified_at: number
    password: number
    two_factor_secret: number
    two_factor_recovery_codes: number
    role: number
    bn_cat_ids: number
    status: number
    visibility: number
    deletable: number
    remember_token: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
    role?: true
    status?: true
    visibility?: true
    deletable?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
    role?: true
    status?: true
    visibility?: true
    deletable?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    name?: true
    designation?: true
    username?: true
    email?: true
    email_verified_at?: true
    password?: true
    two_factor_secret?: true
    two_factor_recovery_codes?: true
    role?: true
    bn_cat_ids?: true
    status?: true
    visibility?: true
    deletable?: true
    remember_token?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    name?: true
    designation?: true
    username?: true
    email?: true
    email_verified_at?: true
    password?: true
    two_factor_secret?: true
    two_factor_recovery_codes?: true
    role?: true
    bn_cat_ids?: true
    status?: true
    visibility?: true
    deletable?: true
    remember_token?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    name?: true
    designation?: true
    username?: true
    email?: true
    email_verified_at?: true
    password?: true
    two_factor_secret?: true
    two_factor_recovery_codes?: true
    role?: true
    bn_cat_ids?: true
    status?: true
    visibility?: true
    deletable?: true
    remember_token?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    name: string
    designation: string | null
    username: string
    email: string
    email_verified_at: Date | null
    password: string
    two_factor_secret: string | null
    two_factor_recovery_codes: string | null
    role: number
    bn_cat_ids: string | null
    status: number
    visibility: number
    deletable: number
    remember_token: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    designation?: boolean
    username?: boolean
    email?: boolean
    email_verified_at?: boolean
    password?: boolean
    two_factor_secret?: boolean
    two_factor_recovery_codes?: boolean
    role?: boolean
    bn_cat_ids?: boolean
    status?: boolean
    visibility?: boolean
    deletable?: boolean
    remember_token?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    name?: boolean
    designation?: boolean
    username?: boolean
    email?: boolean
    email_verified_at?: boolean
    password?: boolean
    two_factor_secret?: boolean
    two_factor_recovery_codes?: boolean
    role?: boolean
    bn_cat_ids?: boolean
    status?: boolean
    visibility?: boolean
    deletable?: boolean
    remember_token?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      designation: string | null
      username: string
      email: string
      email_verified_at: Date | null
      password: string
      two_factor_secret: string | null
      two_factor_recovery_codes: string | null
      role: number
      bn_cat_ids: string | null
      status: number
      visibility: number
      deletable: number
      remember_token: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }


  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends usersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, usersCreateArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {usersCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const users = await prisma.users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends usersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, usersDeleteArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpdateArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends usersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpsertArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'Int'>
    readonly name: FieldRef<"users", 'String'>
    readonly designation: FieldRef<"users", 'String'>
    readonly username: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly email_verified_at: FieldRef<"users", 'DateTime'>
    readonly password: FieldRef<"users", 'String'>
    readonly two_factor_secret: FieldRef<"users", 'String'>
    readonly two_factor_recovery_codes: FieldRef<"users", 'String'>
    readonly role: FieldRef<"users", 'Int'>
    readonly bn_cat_ids: FieldRef<"users", 'String'>
    readonly status: FieldRef<"users", 'Int'>
    readonly visibility: FieldRef<"users", 'Int'>
    readonly deletable: FieldRef<"users", 'Int'>
    readonly remember_token: FieldRef<"users", 'String'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }


  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }


  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }


  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }


  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }


  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }


  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }


  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
  }



  /**
   * Model counter
   */

  export type AggregateCounter = {
    _count: CounterCountAggregateOutputType | null
    _avg: CounterAvgAggregateOutputType | null
    _sum: CounterSumAggregateOutputType | null
    _min: CounterMinAggregateOutputType | null
    _max: CounterMaxAggregateOutputType | null
  }

  export type CounterAvgAggregateOutputType = {
    id: number | null
    status: number | null
  }

  export type CounterSumAggregateOutputType = {
    id: number | null
    status: number | null
  }

  export type CounterMinAggregateOutputType = {
    id: number | null
    counter_name: string | null
    counter_time: string | null
    time: string | null
    date: string | null
    status: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CounterMaxAggregateOutputType = {
    id: number | null
    counter_name: string | null
    counter_time: string | null
    time: string | null
    date: string | null
    status: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CounterCountAggregateOutputType = {
    id: number
    counter_name: number
    counter_time: number
    time: number
    date: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CounterAvgAggregateInputType = {
    id?: true
    status?: true
  }

  export type CounterSumAggregateInputType = {
    id?: true
    status?: true
  }

  export type CounterMinAggregateInputType = {
    id?: true
    counter_name?: true
    counter_time?: true
    time?: true
    date?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type CounterMaxAggregateInputType = {
    id?: true
    counter_name?: true
    counter_time?: true
    time?: true
    date?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type CounterCountAggregateInputType = {
    id?: true
    counter_name?: true
    counter_time?: true
    time?: true
    date?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CounterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which counter to aggregate.
     */
    where?: counterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counters to fetch.
     */
    orderBy?: counterOrderByWithRelationInput | counterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: counterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned counters
    **/
    _count?: true | CounterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CounterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CounterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CounterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CounterMaxAggregateInputType
  }

  export type GetCounterAggregateType<T extends CounterAggregateArgs> = {
        [P in keyof T & keyof AggregateCounter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCounter[P]>
      : GetScalarType<T[P], AggregateCounter[P]>
  }




  export type counterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: counterWhereInput
    orderBy?: counterOrderByWithAggregationInput | counterOrderByWithAggregationInput[]
    by: CounterScalarFieldEnum[] | CounterScalarFieldEnum
    having?: counterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CounterCountAggregateInputType | true
    _avg?: CounterAvgAggregateInputType
    _sum?: CounterSumAggregateInputType
    _min?: CounterMinAggregateInputType
    _max?: CounterMaxAggregateInputType
  }

  export type CounterGroupByOutputType = {
    id: number
    counter_name: string
    counter_time: string
    time: string | null
    date: string | null
    status: number | null
    created_at: Date | null
    updated_at: Date | null
    _count: CounterCountAggregateOutputType | null
    _avg: CounterAvgAggregateOutputType | null
    _sum: CounterSumAggregateOutputType | null
    _min: CounterMinAggregateOutputType | null
    _max: CounterMaxAggregateOutputType | null
  }

  type GetCounterGroupByPayload<T extends counterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CounterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CounterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CounterGroupByOutputType[P]>
            : GetScalarType<T[P], CounterGroupByOutputType[P]>
        }
      >
    >


  export type counterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    counter_name?: boolean
    counter_time?: boolean
    time?: boolean
    date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["counter"]>

  export type counterSelectScalar = {
    id?: boolean
    counter_name?: boolean
    counter_time?: boolean
    time?: boolean
    date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $counterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "counter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      counter_name: string
      counter_time: string
      time: string | null
      date: string | null
      status: number | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["counter"]>
    composites: {}
  }


  type counterGetPayload<S extends boolean | null | undefined | counterDefaultArgs> = $Result.GetResult<Prisma.$counterPayload, S>

  type counterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<counterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CounterCountAggregateInputType | true
    }

  export interface counterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['counter'], meta: { name: 'counter' } }
    /**
     * Find zero or one Counter that matches the filter.
     * @param {counterFindUniqueArgs} args - Arguments to find a Counter
     * @example
     * // Get one Counter
     * const counter = await prisma.counter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends counterFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, counterFindUniqueArgs<ExtArgs>>
    ): Prisma__counterClient<$Result.GetResult<Prisma.$counterPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Counter that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {counterFindUniqueOrThrowArgs} args - Arguments to find a Counter
     * @example
     * // Get one Counter
     * const counter = await prisma.counter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends counterFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, counterFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__counterClient<$Result.GetResult<Prisma.$counterPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Counter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterFindFirstArgs} args - Arguments to find a Counter
     * @example
     * // Get one Counter
     * const counter = await prisma.counter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends counterFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, counterFindFirstArgs<ExtArgs>>
    ): Prisma__counterClient<$Result.GetResult<Prisma.$counterPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Counter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterFindFirstOrThrowArgs} args - Arguments to find a Counter
     * @example
     * // Get one Counter
     * const counter = await prisma.counter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends counterFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, counterFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__counterClient<$Result.GetResult<Prisma.$counterPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Counters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Counters
     * const counters = await prisma.counter.findMany()
     * 
     * // Get first 10 Counters
     * const counters = await prisma.counter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const counterWithIdOnly = await prisma.counter.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends counterFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, counterFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$counterPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Counter.
     * @param {counterCreateArgs} args - Arguments to create a Counter.
     * @example
     * // Create one Counter
     * const Counter = await prisma.counter.create({
     *   data: {
     *     // ... data to create a Counter
     *   }
     * })
     * 
    **/
    create<T extends counterCreateArgs<ExtArgs>>(
      args: SelectSubset<T, counterCreateArgs<ExtArgs>>
    ): Prisma__counterClient<$Result.GetResult<Prisma.$counterPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Counters.
     *     @param {counterCreateManyArgs} args - Arguments to create many Counters.
     *     @example
     *     // Create many Counters
     *     const counter = await prisma.counter.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends counterCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, counterCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Counter.
     * @param {counterDeleteArgs} args - Arguments to delete one Counter.
     * @example
     * // Delete one Counter
     * const Counter = await prisma.counter.delete({
     *   where: {
     *     // ... filter to delete one Counter
     *   }
     * })
     * 
    **/
    delete<T extends counterDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, counterDeleteArgs<ExtArgs>>
    ): Prisma__counterClient<$Result.GetResult<Prisma.$counterPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Counter.
     * @param {counterUpdateArgs} args - Arguments to update one Counter.
     * @example
     * // Update one Counter
     * const counter = await prisma.counter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends counterUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, counterUpdateArgs<ExtArgs>>
    ): Prisma__counterClient<$Result.GetResult<Prisma.$counterPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Counters.
     * @param {counterDeleteManyArgs} args - Arguments to filter Counters to delete.
     * @example
     * // Delete a few Counters
     * const { count } = await prisma.counter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends counterDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, counterDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Counters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Counters
     * const counter = await prisma.counter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends counterUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, counterUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Counter.
     * @param {counterUpsertArgs} args - Arguments to update or create a Counter.
     * @example
     * // Update or create a Counter
     * const counter = await prisma.counter.upsert({
     *   create: {
     *     // ... data to create a Counter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Counter we want to update
     *   }
     * })
    **/
    upsert<T extends counterUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, counterUpsertArgs<ExtArgs>>
    ): Prisma__counterClient<$Result.GetResult<Prisma.$counterPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Counters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterCountArgs} args - Arguments to filter Counters to count.
     * @example
     * // Count the number of Counters
     * const count = await prisma.counter.count({
     *   where: {
     *     // ... the filter for the Counters we want to count
     *   }
     * })
    **/
    count<T extends counterCountArgs>(
      args?: Subset<T, counterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CounterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Counter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CounterAggregateArgs>(args: Subset<T, CounterAggregateArgs>): Prisma.PrismaPromise<GetCounterAggregateType<T>>

    /**
     * Group by Counter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends counterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: counterGroupByArgs['orderBy'] }
        : { orderBy?: counterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, counterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCounterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the counter model
   */
  readonly fields: counterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for counter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__counterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the counter model
   */ 
  interface counterFieldRefs {
    readonly id: FieldRef<"counter", 'Int'>
    readonly counter_name: FieldRef<"counter", 'String'>
    readonly counter_time: FieldRef<"counter", 'String'>
    readonly time: FieldRef<"counter", 'String'>
    readonly date: FieldRef<"counter", 'String'>
    readonly status: FieldRef<"counter", 'Int'>
    readonly created_at: FieldRef<"counter", 'DateTime'>
    readonly updated_at: FieldRef<"counter", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * counter findUnique
   */
  export type counterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter
     */
    select?: counterSelect<ExtArgs> | null
    /**
     * Filter, which counter to fetch.
     */
    where: counterWhereUniqueInput
  }


  /**
   * counter findUniqueOrThrow
   */
  export type counterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter
     */
    select?: counterSelect<ExtArgs> | null
    /**
     * Filter, which counter to fetch.
     */
    where: counterWhereUniqueInput
  }


  /**
   * counter findFirst
   */
  export type counterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter
     */
    select?: counterSelect<ExtArgs> | null
    /**
     * Filter, which counter to fetch.
     */
    where?: counterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counters to fetch.
     */
    orderBy?: counterOrderByWithRelationInput | counterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for counters.
     */
    cursor?: counterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of counters.
     */
    distinct?: CounterScalarFieldEnum | CounterScalarFieldEnum[]
  }


  /**
   * counter findFirstOrThrow
   */
  export type counterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter
     */
    select?: counterSelect<ExtArgs> | null
    /**
     * Filter, which counter to fetch.
     */
    where?: counterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counters to fetch.
     */
    orderBy?: counterOrderByWithRelationInput | counterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for counters.
     */
    cursor?: counterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of counters.
     */
    distinct?: CounterScalarFieldEnum | CounterScalarFieldEnum[]
  }


  /**
   * counter findMany
   */
  export type counterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter
     */
    select?: counterSelect<ExtArgs> | null
    /**
     * Filter, which counters to fetch.
     */
    where?: counterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counters to fetch.
     */
    orderBy?: counterOrderByWithRelationInput | counterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing counters.
     */
    cursor?: counterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counters.
     */
    skip?: number
    distinct?: CounterScalarFieldEnum | CounterScalarFieldEnum[]
  }


  /**
   * counter create
   */
  export type counterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter
     */
    select?: counterSelect<ExtArgs> | null
    /**
     * The data needed to create a counter.
     */
    data: XOR<counterCreateInput, counterUncheckedCreateInput>
  }


  /**
   * counter createMany
   */
  export type counterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many counters.
     */
    data: counterCreateManyInput | counterCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * counter update
   */
  export type counterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter
     */
    select?: counterSelect<ExtArgs> | null
    /**
     * The data needed to update a counter.
     */
    data: XOR<counterUpdateInput, counterUncheckedUpdateInput>
    /**
     * Choose, which counter to update.
     */
    where: counterWhereUniqueInput
  }


  /**
   * counter updateMany
   */
  export type counterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update counters.
     */
    data: XOR<counterUpdateManyMutationInput, counterUncheckedUpdateManyInput>
    /**
     * Filter which counters to update
     */
    where?: counterWhereInput
  }


  /**
   * counter upsert
   */
  export type counterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter
     */
    select?: counterSelect<ExtArgs> | null
    /**
     * The filter to search for the counter to update in case it exists.
     */
    where: counterWhereUniqueInput
    /**
     * In case the counter found by the `where` argument doesn't exist, create a new counter with this data.
     */
    create: XOR<counterCreateInput, counterUncheckedCreateInput>
    /**
     * In case the counter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<counterUpdateInput, counterUncheckedUpdateInput>
  }


  /**
   * counter delete
   */
  export type counterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter
     */
    select?: counterSelect<ExtArgs> | null
    /**
     * Filter which counter to delete.
     */
    where: counterWhereUniqueInput
  }


  /**
   * counter deleteMany
   */
  export type counterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which counters to delete
     */
    where?: counterWhereInput
  }


  /**
   * counter without action
   */
  export type counterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter
     */
    select?: counterSelect<ExtArgs> | null
  }



  /**
   * Model migrations
   */

  export type AggregateMigrations = {
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  export type MigrationsAvgAggregateOutputType = {
    id: number | null
    batch: number | null
  }

  export type MigrationsSumAggregateOutputType = {
    id: number | null
    batch: number | null
  }

  export type MigrationsMinAggregateOutputType = {
    id: number | null
    migration: string | null
    batch: number | null
  }

  export type MigrationsMaxAggregateOutputType = {
    id: number | null
    migration: string | null
    batch: number | null
  }

  export type MigrationsCountAggregateOutputType = {
    id: number
    migration: number
    batch: number
    _all: number
  }


  export type MigrationsAvgAggregateInputType = {
    id?: true
    batch?: true
  }

  export type MigrationsSumAggregateInputType = {
    id?: true
    batch?: true
  }

  export type MigrationsMinAggregateInputType = {
    id?: true
    migration?: true
    batch?: true
  }

  export type MigrationsMaxAggregateInputType = {
    id?: true
    migration?: true
    batch?: true
  }

  export type MigrationsCountAggregateInputType = {
    id?: true
    migration?: true
    batch?: true
    _all?: true
  }

  export type MigrationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migrations to aggregate.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned migrations
    **/
    _count?: true | MigrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MigrationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MigrationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MigrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MigrationsMaxAggregateInputType
  }

  export type GetMigrationsAggregateType<T extends MigrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateMigrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMigrations[P]>
      : GetScalarType<T[P], AggregateMigrations[P]>
  }




  export type migrationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: migrationsWhereInput
    orderBy?: migrationsOrderByWithAggregationInput | migrationsOrderByWithAggregationInput[]
    by: MigrationsScalarFieldEnum[] | MigrationsScalarFieldEnum
    having?: migrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MigrationsCountAggregateInputType | true
    _avg?: MigrationsAvgAggregateInputType
    _sum?: MigrationsSumAggregateInputType
    _min?: MigrationsMinAggregateInputType
    _max?: MigrationsMaxAggregateInputType
  }

  export type MigrationsGroupByOutputType = {
    id: number
    migration: string
    batch: number
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  type GetMigrationsGroupByPayload<T extends migrationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MigrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MigrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
            : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
        }
      >
    >


  export type migrationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    migration?: boolean
    batch?: boolean
  }, ExtArgs["result"]["migrations"]>

  export type migrationsSelectScalar = {
    id?: boolean
    migration?: boolean
    batch?: boolean
  }


  export type $migrationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "migrations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      migration: string
      batch: number
    }, ExtArgs["result"]["migrations"]>
    composites: {}
  }


  type migrationsGetPayload<S extends boolean | null | undefined | migrationsDefaultArgs> = $Result.GetResult<Prisma.$migrationsPayload, S>

  type migrationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<migrationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MigrationsCountAggregateInputType | true
    }

  export interface migrationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['migrations'], meta: { name: 'migrations' } }
    /**
     * Find zero or one Migrations that matches the filter.
     * @param {migrationsFindUniqueArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends migrationsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, migrationsFindUniqueArgs<ExtArgs>>
    ): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Migrations that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {migrationsFindUniqueOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends migrationsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, migrationsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindFirstArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends migrationsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, migrationsFindFirstArgs<ExtArgs>>
    ): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Migrations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindFirstOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends migrationsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, migrationsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Migrations
     * const migrations = await prisma.migrations.findMany()
     * 
     * // Get first 10 Migrations
     * const migrations = await prisma.migrations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const migrationsWithIdOnly = await prisma.migrations.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends migrationsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, migrationsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Migrations.
     * @param {migrationsCreateArgs} args - Arguments to create a Migrations.
     * @example
     * // Create one Migrations
     * const Migrations = await prisma.migrations.create({
     *   data: {
     *     // ... data to create a Migrations
     *   }
     * })
     * 
    **/
    create<T extends migrationsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, migrationsCreateArgs<ExtArgs>>
    ): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Migrations.
     *     @param {migrationsCreateManyArgs} args - Arguments to create many Migrations.
     *     @example
     *     // Create many Migrations
     *     const migrations = await prisma.migrations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends migrationsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, migrationsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Migrations.
     * @param {migrationsDeleteArgs} args - Arguments to delete one Migrations.
     * @example
     * // Delete one Migrations
     * const Migrations = await prisma.migrations.delete({
     *   where: {
     *     // ... filter to delete one Migrations
     *   }
     * })
     * 
    **/
    delete<T extends migrationsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, migrationsDeleteArgs<ExtArgs>>
    ): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Migrations.
     * @param {migrationsUpdateArgs} args - Arguments to update one Migrations.
     * @example
     * // Update one Migrations
     * const migrations = await prisma.migrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends migrationsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, migrationsUpdateArgs<ExtArgs>>
    ): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Migrations.
     * @param {migrationsDeleteManyArgs} args - Arguments to filter Migrations to delete.
     * @example
     * // Delete a few Migrations
     * const { count } = await prisma.migrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends migrationsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, migrationsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Migrations
     * const migrations = await prisma.migrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends migrationsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, migrationsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Migrations.
     * @param {migrationsUpsertArgs} args - Arguments to update or create a Migrations.
     * @example
     * // Update or create a Migrations
     * const migrations = await prisma.migrations.upsert({
     *   create: {
     *     // ... data to create a Migrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Migrations we want to update
     *   }
     * })
    **/
    upsert<T extends migrationsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, migrationsUpsertArgs<ExtArgs>>
    ): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsCountArgs} args - Arguments to filter Migrations to count.
     * @example
     * // Count the number of Migrations
     * const count = await prisma.migrations.count({
     *   where: {
     *     // ... the filter for the Migrations we want to count
     *   }
     * })
    **/
    count<T extends migrationsCountArgs>(
      args?: Subset<T, migrationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MigrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MigrationsAggregateArgs>(args: Subset<T, MigrationsAggregateArgs>): Prisma.PrismaPromise<GetMigrationsAggregateType<T>>

    /**
     * Group by Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends migrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: migrationsGroupByArgs['orderBy'] }
        : { orderBy?: migrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, migrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMigrationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the migrations model
   */
  readonly fields: migrationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for migrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__migrationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the migrations model
   */ 
  interface migrationsFieldRefs {
    readonly id: FieldRef<"migrations", 'Int'>
    readonly migration: FieldRef<"migrations", 'String'>
    readonly batch: FieldRef<"migrations", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * migrations findUnique
   */
  export type migrationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where: migrationsWhereUniqueInput
  }


  /**
   * migrations findUniqueOrThrow
   */
  export type migrationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where: migrationsWhereUniqueInput
  }


  /**
   * migrations findFirst
   */
  export type migrationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }


  /**
   * migrations findFirstOrThrow
   */
  export type migrationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }


  /**
   * migrations findMany
   */
  export type migrationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }


  /**
   * migrations create
   */
  export type migrationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * The data needed to create a migrations.
     */
    data: XOR<migrationsCreateInput, migrationsUncheckedCreateInput>
  }


  /**
   * migrations createMany
   */
  export type migrationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many migrations.
     */
    data: migrationsCreateManyInput | migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * migrations update
   */
  export type migrationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * The data needed to update a migrations.
     */
    data: XOR<migrationsUpdateInput, migrationsUncheckedUpdateInput>
    /**
     * Choose, which migrations to update.
     */
    where: migrationsWhereUniqueInput
  }


  /**
   * migrations updateMany
   */
  export type migrationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update migrations.
     */
    data: XOR<migrationsUpdateManyMutationInput, migrationsUncheckedUpdateManyInput>
    /**
     * Filter which migrations to update
     */
    where?: migrationsWhereInput
  }


  /**
   * migrations upsert
   */
  export type migrationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * The filter to search for the migrations to update in case it exists.
     */
    where: migrationsWhereUniqueInput
    /**
     * In case the migrations found by the `where` argument doesn't exist, create a new migrations with this data.
     */
    create: XOR<migrationsCreateInput, migrationsUncheckedCreateInput>
    /**
     * In case the migrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<migrationsUpdateInput, migrationsUncheckedUpdateInput>
  }


  /**
   * migrations delete
   */
  export type migrationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Filter which migrations to delete.
     */
    where: migrationsWhereUniqueInput
  }


  /**
   * migrations deleteMany
   */
  export type migrationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migrations to delete
     */
    where?: migrationsWhereInput
  }


  /**
   * migrations without action
   */
  export type migrationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AuthorsScalarFieldEnum: {
    author_id: 'author_id',
    author_type: 'author_type',
    author_name: 'author_name',
    author_name_bn: 'author_name_bn',
    author_slug: 'author_slug',
    author_initial: 'author_initial',
    author_initial_bn: 'author_initial_bn',
    author_bio: 'author_bio',
    author_bio_bn: 'author_bio_bn',
    img_path: 'img_path',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AuthorsScalarFieldEnum = (typeof AuthorsScalarFieldEnum)[keyof typeof AuthorsScalarFieldEnum]


  export const Bn_adsScalarFieldEnum: {
    id: 'id',
    type: 'type',
    page: 'page',
    position: 'position',
    dfp_header_code: 'dfp_header_code',
    code: 'code',
    desktop_image_path: 'desktop_image_path',
    mobile_image_path: 'mobile_image_path',
    external_link: 'external_link',
    start_time: 'start_time',
    end_time: 'end_time',
    status: 'status',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Bn_adsScalarFieldEnum = (typeof Bn_adsScalarFieldEnum)[keyof typeof Bn_adsScalarFieldEnum]


  export const Bn_breaking_newsScalarFieldEnum: {
    id: 'id',
    news_title: 'news_title',
    news_link: 'news_link',
    position: 'position',
    hours: 'hours',
    user_id: 'user_id',
    expired_time: 'expired_time',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Bn_breaking_newsScalarFieldEnum = (typeof Bn_breaking_newsScalarFieldEnum)[keyof typeof Bn_breaking_newsScalarFieldEnum]


  export const Bn_categoriesScalarFieldEnum: {
    cat_id: 'cat_id',
    cat_type: 'cat_type',
    cat_name: 'cat_name',
    cat_name_bn: 'cat_name_bn',
    cat_slug: 'cat_slug',
    cat_title: 'cat_title',
    cat_meta_keyword: 'cat_meta_keyword',
    cat_meta_description: 'cat_meta_description',
    cat_position: 'cat_position',
    top_menu: 'top_menu',
    footer_menu: 'footer_menu',
    status: 'status',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Bn_categoriesScalarFieldEnum = (typeof Bn_categoriesScalarFieldEnum)[keyof typeof Bn_categoriesScalarFieldEnum]


  export const Bn_content_positionsScalarFieldEnum: {
    position_id: 'position_id',
    position_name: 'position_name',
    position_slug: 'position_slug',
    cat_id: 'cat_id',
    special_cat_id: 'special_cat_id',
    subcat_id: 'subcat_id',
    content_ids: 'content_ids',
    total_content: 'total_content',
    status: 'status',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Bn_content_positionsScalarFieldEnum = (typeof Bn_content_positionsScalarFieldEnum)[keyof typeof Bn_content_positionsScalarFieldEnum]


  export const Bn_contentsScalarFieldEnum: {
    content_id: 'content_id',
    content_type: 'content_type',
    cat_id: 'cat_id',
    subcat_id: 'subcat_id',
    special_cat_id: 'special_cat_id',
    country_id: 'country_id',
    division_id: 'division_id',
    district_id: 'district_id',
    upozilla_id: 'upozilla_id',
    content_heading: 'content_heading',
    content_sub_heading: 'content_sub_heading',
    author_slugs: 'author_slugs',
    author_name: 'author_name',
    content_brief: 'content_brief',
    content_details: 'content_details',
    img_xs_path: 'img_xs_path',
    img_sm_path: 'img_sm_path',
    img_sm_caption: 'img_sm_caption',
    img_bg_path: 'img_bg_path',
    og_image: 'og_image',
    img_bg_caption: 'img_bg_caption',
    related_ids: 'related_ids',
    photo_ids: 'photo_ids',
    video_type: 'video_type',
    video_id: 'video_id',
    uploader_id: 'uploader_id',
    reporter_id: 'reporter_id',
    tags: 'tags',
    meta_keywords: 'meta_keywords',
    timeline_tag: 'timeline_tag',
    podcast_id: 'podcast_id',
    status: 'status',
    scroll: 'scroll',
    total_hit: 'total_hit',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Bn_contentsScalarFieldEnum = (typeof Bn_contentsScalarFieldEnum)[keyof typeof Bn_contentsScalarFieldEnum]


  export const Bn_mobile_adsScalarFieldEnum: {
    id: 'id',
    type: 'type',
    page: 'page',
    position: 'position',
    dfp_header_code: 'dfp_header_code',
    code: 'code',
    mobile_image_path: 'mobile_image_path',
    external_link: 'external_link',
    start_time: 'start_time',
    end_time: 'end_time',
    status: 'status',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Bn_mobile_adsScalarFieldEnum = (typeof Bn_mobile_adsScalarFieldEnum)[keyof typeof Bn_mobile_adsScalarFieldEnum]


  export const Bn_position_fixedScalarFieldEnum: {
    id: 'id',
    position_number: 'position_number',
    news_id: 'news_id',
    is_fixed: 'is_fixed',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Bn_position_fixedScalarFieldEnum = (typeof Bn_position_fixedScalarFieldEnum)[keyof typeof Bn_position_fixedScalarFieldEnum]


  export const Bn_subcategoriesScalarFieldEnum: {
    subcat_id: 'subcat_id',
    cat_id: 'cat_id',
    subcat_name: 'subcat_name',
    subcat_name_bn: 'subcat_name_bn',
    subcat_slug: 'subcat_slug',
    subcat_meta_keyword: 'subcat_meta_keyword',
    subcat_meta_description: 'subcat_meta_description',
    subcat_position: 'subcat_position',
    status: 'status',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Bn_subcategoriesScalarFieldEnum = (typeof Bn_subcategoriesScalarFieldEnum)[keyof typeof Bn_subcategoriesScalarFieldEnum]


  export const Bn_tagsScalarFieldEnum: {
    tag_id: 'tag_id',
    tag_type: 'tag_type',
    tag_name: 'tag_name',
    tag_slug: 'tag_slug',
    description: 'description',
    img_path: 'img_path',
    approval: 'approval',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Bn_tagsScalarFieldEnum = (typeof Bn_tagsScalarFieldEnum)[keyof typeof Bn_tagsScalarFieldEnum]


  export const Bn_video_categoriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    name_bn: 'name_bn',
    meta_keywords: 'meta_keywords',
    meta_description: 'meta_description',
    og_img_path: 'og_img_path',
    position: 'position',
    user_id: 'user_id',
    status: 'status',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Bn_video_categoriesScalarFieldEnum = (typeof Bn_video_categoriesScalarFieldEnum)[keyof typeof Bn_video_categoriesScalarFieldEnum]


  export const Bn_video_positionsScalarFieldEnum: {
    position_id: 'position_id',
    position_name: 'position_name',
    cat_id: 'cat_id',
    subcat_id: 'subcat_id',
    video_ids: 'video_ids',
    total_video: 'total_video',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Bn_video_positionsScalarFieldEnum = (typeof Bn_video_positionsScalarFieldEnum)[keyof typeof Bn_video_positionsScalarFieldEnum]


  export const Bn_videosScalarFieldEnum: {
    id: 'id',
    cat_id: 'cat_id',
    type: 'type',
    title: 'title',
    code: 'code',
    img_bg_path: 'img_bg_path',
    img_sm_path: 'img_sm_path',
    img_xs_path: 'img_xs_path',
    link: 'link',
    meta_keywords: 'meta_keywords',
    meta_description: 'meta_description',
    user_id: 'user_id',
    target: 'target',
    is_live: 'is_live',
    status: 'status',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Bn_videosScalarFieldEnum = (typeof Bn_videosScalarFieldEnum)[keyof typeof Bn_videosScalarFieldEnum]


  export const CountriesScalarFieldEnum: {
    country_id: 'country_id',
    country_name: 'country_name',
    country_name_bn: 'country_name_bn',
    country_slug: 'country_slug',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CountriesScalarFieldEnum = (typeof CountriesScalarFieldEnum)[keyof typeof CountriesScalarFieldEnum]


  export const DistrictsScalarFieldEnum: {
    district_id: 'district_id',
    division_id: 'division_id',
    district_name: 'district_name',
    district_name_bn: 'district_name_bn',
    district_slug: 'district_slug',
    district_title: 'district_title',
    meta_description: 'meta_description',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DistrictsScalarFieldEnum = (typeof DistrictsScalarFieldEnum)[keyof typeof DistrictsScalarFieldEnum]


  export const DivisionsScalarFieldEnum: {
    division_id: 'division_id',
    division_name: 'division_name',
    division_name_bn: 'division_name_bn',
    division_slug: 'division_slug',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DivisionsScalarFieldEnum = (typeof DivisionsScalarFieldEnum)[keyof typeof DivisionsScalarFieldEnum]


  export const ElectionsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    total_center: 'total_center',
    casted_center: 'casted_center',
    party_one_name: 'party_one_name',
    party_two_name: 'party_two_name',
    party_three_name: 'party_three_name',
    party_four_name: 'party_four_name',
    party_one_logo: 'party_one_logo',
    party_two_logo: 'party_two_logo',
    party_three_logo: 'party_three_logo',
    party_four_logo: 'party_four_logo',
    party_one_votes: 'party_one_votes',
    party_two_votes: 'party_two_votes',
    party_three_votes: 'party_three_votes',
    party_four_votes: 'party_four_votes',
    status: 'status',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ElectionsScalarFieldEnum = (typeof ElectionsScalarFieldEnum)[keyof typeof ElectionsScalarFieldEnum]


  export const Epaper_pagesScalarFieldEnum: {
    id: 'id',
    epaper_id: 'epaper_id',
    img_path: 'img_path',
    img_thumb_path: 'img_thumb_path',
    img_large_path: 'img_large_path',
    page_no: 'page_no',
    user_id: 'user_id',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Epaper_pagesScalarFieldEnum = (typeof Epaper_pagesScalarFieldEnum)[keyof typeof Epaper_pagesScalarFieldEnum]


  export const EpapersScalarFieldEnum: {
    id: 'id',
    paper_date: 'paper_date',
    total_page: 'total_page',
    meta_keywords: 'meta_keywords',
    meta_description: 'meta_description',
    og_img_path: 'og_img_path',
    user_id: 'user_id',
    status: 'status',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type EpapersScalarFieldEnum = (typeof EpapersScalarFieldEnum)[keyof typeof EpapersScalarFieldEnum]


  export const Magazine_pagesScalarFieldEnum: {
    id: 'id',
    magazine_id: 'magazine_id',
    img_path: 'img_path',
    img_thumb_path: 'img_thumb_path',
    img_large_path: 'img_large_path',
    counter: 'counter',
    user_id: 'user_id',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Magazine_pagesScalarFieldEnum = (typeof Magazine_pagesScalarFieldEnum)[keyof typeof Magazine_pagesScalarFieldEnum]


  export const MagazinesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    total_page: 'total_page',
    meta_keywords: 'meta_keywords',
    meta_description: 'meta_description',
    og_img_path: 'og_img_path',
    user_id: 'user_id',
    status: 'status',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type MagazinesScalarFieldEnum = (typeof MagazinesScalarFieldEnum)[keyof typeof MagazinesScalarFieldEnum]


  export const Manual_documentsScalarFieldEnum: {
    doc_id: 'doc_id',
    doc_path: 'doc_path',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Manual_documentsScalarFieldEnum = (typeof Manual_documentsScalarFieldEnum)[keyof typeof Manual_documentsScalarFieldEnum]


  export const Manual_photosScalarFieldEnum: {
    photo_id: 'photo_id',
    img_path: 'img_path',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Manual_photosScalarFieldEnum = (typeof Manual_photosScalarFieldEnum)[keyof typeof Manual_photosScalarFieldEnum]


  export const Mis_usersScalarFieldEnum: {
    user_id: 'user_id',
    user_type: 'user_type',
    admin_id: 'admin_id',
    dept_type: 'dept_type',
    user_name: 'user_name',
    user_name_bn: 'user_name_bn',
    user_slug: 'user_slug',
    user_initial: 'user_initial',
    user_initial_bn: 'user_initial_bn',
    user_bio: 'user_bio',
    user_bio_bn: 'user_bio_bn',
    img_path: 'img_path',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Mis_usersScalarFieldEnum = (typeof Mis_usersScalarFieldEnum)[keyof typeof Mis_usersScalarFieldEnum]


  export const Monthly_foldersScalarFieldEnum: {
    folder_id: 'folder_id',
    folder_name: 'folder_name',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Monthly_foldersScalarFieldEnum = (typeof Monthly_foldersScalarFieldEnum)[keyof typeof Monthly_foldersScalarFieldEnum]


  export const P_album_positionsScalarFieldEnum: {
    position_id: 'position_id',
    position_name: 'position_name',
    position_slug: 'position_slug',
    cat_id: 'cat_id',
    special_cat_id: 'special_cat_id',
    subcat_id: 'subcat_id',
    content_ids: 'content_ids',
    total_content: 'total_content',
    status: 'status',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type P_album_positionsScalarFieldEnum = (typeof P_album_positionsScalarFieldEnum)[keyof typeof P_album_positionsScalarFieldEnum]


  export const P_albumsScalarFieldEnum: {
    album_id: 'album_id',
    cat_id: 'cat_id',
    subcat_id: 'subcat_id',
    album_name: 'album_name',
    short_description: 'short_description',
    album_details: 'album_details',
    photographer_name: 'photographer_name',
    tag: 'tag',
    status: 'status',
    total_hit: 'total_hit',
    deletable: 'deletable',
    user_id: 'user_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type P_albumsScalarFieldEnum = (typeof P_albumsScalarFieldEnum)[keyof typeof P_albumsScalarFieldEnum]


  export const P_categoriesScalarFieldEnum: {
    cat_id: 'cat_id',
    cat_name: 'cat_name',
    cat_name_bn: 'cat_name_bn',
    cat_slug: 'cat_slug',
    cat_meta_keyword: 'cat_meta_keyword',
    cat_meta_description: 'cat_meta_description',
    cat_position: 'cat_position',
    top_menu: 'top_menu',
    footer_menu: 'footer_menu',
    status: 'status',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type P_categoriesScalarFieldEnum = (typeof P_categoriesScalarFieldEnum)[keyof typeof P_categoriesScalarFieldEnum]


  export const P_galleriesScalarFieldEnum: {
    id: 'id',
    album_id: 'album_id',
    photo: 'photo',
    photo_capture: 'photo_capture',
    feature_image: 'feature_image',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type P_galleriesScalarFieldEnum = (typeof P_galleriesScalarFieldEnum)[keyof typeof P_galleriesScalarFieldEnum]


  export const P_subcategoriesScalarFieldEnum: {
    subcat_id: 'subcat_id',
    cat_id: 'cat_id',
    subcat_name: 'subcat_name',
    subcat_name_bn: 'subcat_name_bn',
    subcat_slug: 'subcat_slug',
    subcat_meta_keyword: 'subcat_meta_keyword',
    subcat_meta_description: 'subcat_meta_description',
    subcat_position: 'subcat_position',
    status: 'status',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type P_subcategoriesScalarFieldEnum = (typeof P_subcategoriesScalarFieldEnum)[keyof typeof P_subcategoriesScalarFieldEnum]


  export const Site_settingsScalarFieldEnum: {
    id: 'id',
    site_name: 'site_name',
    favicon: 'favicon',
    logo: 'logo',
    logo_header: 'logo_header',
    logo_footer: 'logo_footer',
    title: 'title',
    meta_keywords: 'meta_keywords',
    meta_description: 'meta_description',
    og_image: 'og_image',
    post_ogimage: 'post_ogimage',
    social_links: 'social_links',
    facebook: 'facebook',
    twitter: 'twitter',
    google_plus: 'google_plus',
    youtube: 'youtube',
    instagram: 'instagram',
    linkedin: 'linkedin',
    editor_meta: 'editor_meta',
    address: 'address',
    copyright: 'copyright',
    show_special: 'show_special',
    special_title: 'special_title',
    special_link: 'special_link',
    show_live_tv: 'show_live_tv',
    show_video_live_tv: 'show_video_live_tv',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Site_settingsScalarFieldEnum = (typeof Site_settingsScalarFieldEnum)[keyof typeof Site_settingsScalarFieldEnum]


  export const SurveysScalarFieldEnum: {
    survey_id: 'survey_id',
    title: 'title',
    from_date: 'from_date',
    to_date: 'to_date',
    ha: 'ha',
    na: 'na',
    no_comment: 'no_comment',
    status: 'status',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SurveysScalarFieldEnum = (typeof SurveysScalarFieldEnum)[keyof typeof SurveysScalarFieldEnum]


  export const UpozillasScalarFieldEnum: {
    upozilla_id: 'upozilla_id',
    district_id: 'district_id',
    division_id: 'division_id',
    upozilla_name: 'upozilla_name',
    upozilla_name_bn: 'upozilla_name_bn',
    upozilla_title: 'upozilla_title',
    upozilla_slug: 'upozilla_slug',
    meta_description: 'meta_description',
    deletable: 'deletable',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UpozillasScalarFieldEnum = (typeof UpozillasScalarFieldEnum)[keyof typeof UpozillasScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    designation: 'designation',
    username: 'username',
    email: 'email',
    email_verified_at: 'email_verified_at',
    password: 'password',
    two_factor_secret: 'two_factor_secret',
    two_factor_recovery_codes: 'two_factor_recovery_codes',
    role: 'role',
    bn_cat_ids: 'bn_cat_ids',
    status: 'status',
    visibility: 'visibility',
    deletable: 'deletable',
    remember_token: 'remember_token',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const CounterScalarFieldEnum: {
    id: 'id',
    counter_name: 'counter_name',
    counter_time: 'counter_time',
    time: 'time',
    date: 'date',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CounterScalarFieldEnum = (typeof CounterScalarFieldEnum)[keyof typeof CounterScalarFieldEnum]


  export const MigrationsScalarFieldEnum: {
    id: 'id',
    migration: 'migration',
    batch: 'batch'
  };

  export type MigrationsScalarFieldEnum = (typeof MigrationsScalarFieldEnum)[keyof typeof MigrationsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type authorsWhereInput = {
    AND?: authorsWhereInput | authorsWhereInput[]
    OR?: authorsWhereInput[]
    NOT?: authorsWhereInput | authorsWhereInput[]
    author_id?: IntFilter<"authors"> | number
    author_type?: IntFilter<"authors"> | number
    author_name?: StringFilter<"authors"> | string
    author_name_bn?: StringFilter<"authors"> | string
    author_slug?: StringFilter<"authors"> | string
    author_initial?: StringFilter<"authors"> | string
    author_initial_bn?: StringFilter<"authors"> | string
    author_bio?: StringNullableFilter<"authors"> | string | null
    author_bio_bn?: StringNullableFilter<"authors"> | string | null
    img_path?: StringNullableFilter<"authors"> | string | null
    deletable?: IntFilter<"authors"> | number
    created_at?: DateTimeNullableFilter<"authors"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"authors"> | Date | string | null
  }

  export type authorsOrderByWithRelationInput = {
    author_id?: SortOrder
    author_type?: SortOrder
    author_name?: SortOrder
    author_name_bn?: SortOrder
    author_slug?: SortOrder
    author_initial?: SortOrder
    author_initial_bn?: SortOrder
    author_bio?: SortOrderInput | SortOrder
    author_bio_bn?: SortOrderInput | SortOrder
    img_path?: SortOrderInput | SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type authorsWhereUniqueInput = Prisma.AtLeast<{
    author_id?: number
    author_slug?: string
    author_initial?: string
    AND?: authorsWhereInput | authorsWhereInput[]
    OR?: authorsWhereInput[]
    NOT?: authorsWhereInput | authorsWhereInput[]
    author_type?: IntFilter<"authors"> | number
    author_name?: StringFilter<"authors"> | string
    author_name_bn?: StringFilter<"authors"> | string
    author_initial_bn?: StringFilter<"authors"> | string
    author_bio?: StringNullableFilter<"authors"> | string | null
    author_bio_bn?: StringNullableFilter<"authors"> | string | null
    img_path?: StringNullableFilter<"authors"> | string | null
    deletable?: IntFilter<"authors"> | number
    created_at?: DateTimeNullableFilter<"authors"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"authors"> | Date | string | null
  }, "author_id" | "author_slug" | "author_initial">

  export type authorsOrderByWithAggregationInput = {
    author_id?: SortOrder
    author_type?: SortOrder
    author_name?: SortOrder
    author_name_bn?: SortOrder
    author_slug?: SortOrder
    author_initial?: SortOrder
    author_initial_bn?: SortOrder
    author_bio?: SortOrderInput | SortOrder
    author_bio_bn?: SortOrderInput | SortOrder
    img_path?: SortOrderInput | SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: authorsCountOrderByAggregateInput
    _avg?: authorsAvgOrderByAggregateInput
    _max?: authorsMaxOrderByAggregateInput
    _min?: authorsMinOrderByAggregateInput
    _sum?: authorsSumOrderByAggregateInput
  }

  export type authorsScalarWhereWithAggregatesInput = {
    AND?: authorsScalarWhereWithAggregatesInput | authorsScalarWhereWithAggregatesInput[]
    OR?: authorsScalarWhereWithAggregatesInput[]
    NOT?: authorsScalarWhereWithAggregatesInput | authorsScalarWhereWithAggregatesInput[]
    author_id?: IntWithAggregatesFilter<"authors"> | number
    author_type?: IntWithAggregatesFilter<"authors"> | number
    author_name?: StringWithAggregatesFilter<"authors"> | string
    author_name_bn?: StringWithAggregatesFilter<"authors"> | string
    author_slug?: StringWithAggregatesFilter<"authors"> | string
    author_initial?: StringWithAggregatesFilter<"authors"> | string
    author_initial_bn?: StringWithAggregatesFilter<"authors"> | string
    author_bio?: StringNullableWithAggregatesFilter<"authors"> | string | null
    author_bio_bn?: StringNullableWithAggregatesFilter<"authors"> | string | null
    img_path?: StringNullableWithAggregatesFilter<"authors"> | string | null
    deletable?: IntWithAggregatesFilter<"authors"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"authors"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"authors"> | Date | string | null
  }

  export type bn_adsWhereInput = {
    AND?: bn_adsWhereInput | bn_adsWhereInput[]
    OR?: bn_adsWhereInput[]
    NOT?: bn_adsWhereInput | bn_adsWhereInput[]
    id?: IntFilter<"bn_ads"> | number
    type?: IntNullableFilter<"bn_ads"> | number | null
    page?: IntNullableFilter<"bn_ads"> | number | null
    position?: IntNullableFilter<"bn_ads"> | number | null
    dfp_header_code?: StringNullableFilter<"bn_ads"> | string | null
    code?: StringNullableFilter<"bn_ads"> | string | null
    desktop_image_path?: StringNullableFilter<"bn_ads"> | string | null
    mobile_image_path?: StringNullableFilter<"bn_ads"> | string | null
    external_link?: StringNullableFilter<"bn_ads"> | string | null
    start_time?: DateTimeNullableFilter<"bn_ads"> | Date | string | null
    end_time?: DateTimeNullableFilter<"bn_ads"> | Date | string | null
    status?: IntNullableFilter<"bn_ads"> | number | null
    deletable?: IntNullableFilter<"bn_ads"> | number | null
    created_at?: DateTimeNullableFilter<"bn_ads"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_ads"> | Date | string | null
  }

  export type bn_adsOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    page?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    dfp_header_code?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    desktop_image_path?: SortOrderInput | SortOrder
    mobile_image_path?: SortOrderInput | SortOrder
    external_link?: SortOrderInput | SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    deletable?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type bn_adsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bn_adsWhereInput | bn_adsWhereInput[]
    OR?: bn_adsWhereInput[]
    NOT?: bn_adsWhereInput | bn_adsWhereInput[]
    type?: IntNullableFilter<"bn_ads"> | number | null
    page?: IntNullableFilter<"bn_ads"> | number | null
    position?: IntNullableFilter<"bn_ads"> | number | null
    dfp_header_code?: StringNullableFilter<"bn_ads"> | string | null
    code?: StringNullableFilter<"bn_ads"> | string | null
    desktop_image_path?: StringNullableFilter<"bn_ads"> | string | null
    mobile_image_path?: StringNullableFilter<"bn_ads"> | string | null
    external_link?: StringNullableFilter<"bn_ads"> | string | null
    start_time?: DateTimeNullableFilter<"bn_ads"> | Date | string | null
    end_time?: DateTimeNullableFilter<"bn_ads"> | Date | string | null
    status?: IntNullableFilter<"bn_ads"> | number | null
    deletable?: IntNullableFilter<"bn_ads"> | number | null
    created_at?: DateTimeNullableFilter<"bn_ads"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_ads"> | Date | string | null
  }, "id">

  export type bn_adsOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    page?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    dfp_header_code?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    desktop_image_path?: SortOrderInput | SortOrder
    mobile_image_path?: SortOrderInput | SortOrder
    external_link?: SortOrderInput | SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    deletable?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: bn_adsCountOrderByAggregateInput
    _avg?: bn_adsAvgOrderByAggregateInput
    _max?: bn_adsMaxOrderByAggregateInput
    _min?: bn_adsMinOrderByAggregateInput
    _sum?: bn_adsSumOrderByAggregateInput
  }

  export type bn_adsScalarWhereWithAggregatesInput = {
    AND?: bn_adsScalarWhereWithAggregatesInput | bn_adsScalarWhereWithAggregatesInput[]
    OR?: bn_adsScalarWhereWithAggregatesInput[]
    NOT?: bn_adsScalarWhereWithAggregatesInput | bn_adsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bn_ads"> | number
    type?: IntNullableWithAggregatesFilter<"bn_ads"> | number | null
    page?: IntNullableWithAggregatesFilter<"bn_ads"> | number | null
    position?: IntNullableWithAggregatesFilter<"bn_ads"> | number | null
    dfp_header_code?: StringNullableWithAggregatesFilter<"bn_ads"> | string | null
    code?: StringNullableWithAggregatesFilter<"bn_ads"> | string | null
    desktop_image_path?: StringNullableWithAggregatesFilter<"bn_ads"> | string | null
    mobile_image_path?: StringNullableWithAggregatesFilter<"bn_ads"> | string | null
    external_link?: StringNullableWithAggregatesFilter<"bn_ads"> | string | null
    start_time?: DateTimeNullableWithAggregatesFilter<"bn_ads"> | Date | string | null
    end_time?: DateTimeNullableWithAggregatesFilter<"bn_ads"> | Date | string | null
    status?: IntNullableWithAggregatesFilter<"bn_ads"> | number | null
    deletable?: IntNullableWithAggregatesFilter<"bn_ads"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"bn_ads"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"bn_ads"> | Date | string | null
  }

  export type bn_breaking_newsWhereInput = {
    AND?: bn_breaking_newsWhereInput | bn_breaking_newsWhereInput[]
    OR?: bn_breaking_newsWhereInput[]
    NOT?: bn_breaking_newsWhereInput | bn_breaking_newsWhereInput[]
    id?: IntFilter<"bn_breaking_news"> | number
    news_title?: StringNullableFilter<"bn_breaking_news"> | string | null
    news_link?: StringNullableFilter<"bn_breaking_news"> | string | null
    position?: IntNullableFilter<"bn_breaking_news"> | number | null
    hours?: IntNullableFilter<"bn_breaking_news"> | number | null
    user_id?: IntFilter<"bn_breaking_news"> | number
    expired_time?: DateTimeNullableFilter<"bn_breaking_news"> | Date | string | null
    created_at?: DateTimeNullableFilter<"bn_breaking_news"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_breaking_news"> | Date | string | null
  }

  export type bn_breaking_newsOrderByWithRelationInput = {
    id?: SortOrder
    news_title?: SortOrderInput | SortOrder
    news_link?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    hours?: SortOrderInput | SortOrder
    user_id?: SortOrder
    expired_time?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type bn_breaking_newsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bn_breaking_newsWhereInput | bn_breaking_newsWhereInput[]
    OR?: bn_breaking_newsWhereInput[]
    NOT?: bn_breaking_newsWhereInput | bn_breaking_newsWhereInput[]
    news_title?: StringNullableFilter<"bn_breaking_news"> | string | null
    news_link?: StringNullableFilter<"bn_breaking_news"> | string | null
    position?: IntNullableFilter<"bn_breaking_news"> | number | null
    hours?: IntNullableFilter<"bn_breaking_news"> | number | null
    user_id?: IntFilter<"bn_breaking_news"> | number
    expired_time?: DateTimeNullableFilter<"bn_breaking_news"> | Date | string | null
    created_at?: DateTimeNullableFilter<"bn_breaking_news"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_breaking_news"> | Date | string | null
  }, "id">

  export type bn_breaking_newsOrderByWithAggregationInput = {
    id?: SortOrder
    news_title?: SortOrderInput | SortOrder
    news_link?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    hours?: SortOrderInput | SortOrder
    user_id?: SortOrder
    expired_time?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: bn_breaking_newsCountOrderByAggregateInput
    _avg?: bn_breaking_newsAvgOrderByAggregateInput
    _max?: bn_breaking_newsMaxOrderByAggregateInput
    _min?: bn_breaking_newsMinOrderByAggregateInput
    _sum?: bn_breaking_newsSumOrderByAggregateInput
  }

  export type bn_breaking_newsScalarWhereWithAggregatesInput = {
    AND?: bn_breaking_newsScalarWhereWithAggregatesInput | bn_breaking_newsScalarWhereWithAggregatesInput[]
    OR?: bn_breaking_newsScalarWhereWithAggregatesInput[]
    NOT?: bn_breaking_newsScalarWhereWithAggregatesInput | bn_breaking_newsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bn_breaking_news"> | number
    news_title?: StringNullableWithAggregatesFilter<"bn_breaking_news"> | string | null
    news_link?: StringNullableWithAggregatesFilter<"bn_breaking_news"> | string | null
    position?: IntNullableWithAggregatesFilter<"bn_breaking_news"> | number | null
    hours?: IntNullableWithAggregatesFilter<"bn_breaking_news"> | number | null
    user_id?: IntWithAggregatesFilter<"bn_breaking_news"> | number
    expired_time?: DateTimeNullableWithAggregatesFilter<"bn_breaking_news"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"bn_breaking_news"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"bn_breaking_news"> | Date | string | null
  }

  export type bn_categoriesWhereInput = {
    AND?: bn_categoriesWhereInput | bn_categoriesWhereInput[]
    OR?: bn_categoriesWhereInput[]
    NOT?: bn_categoriesWhereInput | bn_categoriesWhereInput[]
    cat_id?: IntFilter<"bn_categories"> | number
    cat_type?: IntFilter<"bn_categories"> | number
    cat_name?: StringFilter<"bn_categories"> | string
    cat_name_bn?: StringFilter<"bn_categories"> | string
    cat_slug?: StringFilter<"bn_categories"> | string
    cat_title?: StringNullableFilter<"bn_categories"> | string | null
    cat_meta_keyword?: StringNullableFilter<"bn_categories"> | string | null
    cat_meta_description?: StringNullableFilter<"bn_categories"> | string | null
    cat_position?: IntFilter<"bn_categories"> | number
    top_menu?: IntFilter<"bn_categories"> | number
    footer_menu?: IntFilter<"bn_categories"> | number
    status?: IntFilter<"bn_categories"> | number
    deletable?: IntFilter<"bn_categories"> | number
    created_at?: DateTimeNullableFilter<"bn_categories"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_categories"> | Date | string | null
  }

  export type bn_categoriesOrderByWithRelationInput = {
    cat_id?: SortOrder
    cat_type?: SortOrder
    cat_name?: SortOrder
    cat_name_bn?: SortOrder
    cat_slug?: SortOrder
    cat_title?: SortOrderInput | SortOrder
    cat_meta_keyword?: SortOrderInput | SortOrder
    cat_meta_description?: SortOrderInput | SortOrder
    cat_position?: SortOrder
    top_menu?: SortOrder
    footer_menu?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type bn_categoriesWhereUniqueInput = Prisma.AtLeast<{
    cat_id?: number
    AND?: bn_categoriesWhereInput | bn_categoriesWhereInput[]
    OR?: bn_categoriesWhereInput[]
    NOT?: bn_categoriesWhereInput | bn_categoriesWhereInput[]
    cat_type?: IntFilter<"bn_categories"> | number
    cat_name?: StringFilter<"bn_categories"> | string
    cat_name_bn?: StringFilter<"bn_categories"> | string
    cat_slug?: StringFilter<"bn_categories"> | string
    cat_title?: StringNullableFilter<"bn_categories"> | string | null
    cat_meta_keyword?: StringNullableFilter<"bn_categories"> | string | null
    cat_meta_description?: StringNullableFilter<"bn_categories"> | string | null
    cat_position?: IntFilter<"bn_categories"> | number
    top_menu?: IntFilter<"bn_categories"> | number
    footer_menu?: IntFilter<"bn_categories"> | number
    status?: IntFilter<"bn_categories"> | number
    deletable?: IntFilter<"bn_categories"> | number
    created_at?: DateTimeNullableFilter<"bn_categories"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_categories"> | Date | string | null
  }, "cat_id">

  export type bn_categoriesOrderByWithAggregationInput = {
    cat_id?: SortOrder
    cat_type?: SortOrder
    cat_name?: SortOrder
    cat_name_bn?: SortOrder
    cat_slug?: SortOrder
    cat_title?: SortOrderInput | SortOrder
    cat_meta_keyword?: SortOrderInput | SortOrder
    cat_meta_description?: SortOrderInput | SortOrder
    cat_position?: SortOrder
    top_menu?: SortOrder
    footer_menu?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: bn_categoriesCountOrderByAggregateInput
    _avg?: bn_categoriesAvgOrderByAggregateInput
    _max?: bn_categoriesMaxOrderByAggregateInput
    _min?: bn_categoriesMinOrderByAggregateInput
    _sum?: bn_categoriesSumOrderByAggregateInput
  }

  export type bn_categoriesScalarWhereWithAggregatesInput = {
    AND?: bn_categoriesScalarWhereWithAggregatesInput | bn_categoriesScalarWhereWithAggregatesInput[]
    OR?: bn_categoriesScalarWhereWithAggregatesInput[]
    NOT?: bn_categoriesScalarWhereWithAggregatesInput | bn_categoriesScalarWhereWithAggregatesInput[]
    cat_id?: IntWithAggregatesFilter<"bn_categories"> | number
    cat_type?: IntWithAggregatesFilter<"bn_categories"> | number
    cat_name?: StringWithAggregatesFilter<"bn_categories"> | string
    cat_name_bn?: StringWithAggregatesFilter<"bn_categories"> | string
    cat_slug?: StringWithAggregatesFilter<"bn_categories"> | string
    cat_title?: StringNullableWithAggregatesFilter<"bn_categories"> | string | null
    cat_meta_keyword?: StringNullableWithAggregatesFilter<"bn_categories"> | string | null
    cat_meta_description?: StringNullableWithAggregatesFilter<"bn_categories"> | string | null
    cat_position?: IntWithAggregatesFilter<"bn_categories"> | number
    top_menu?: IntWithAggregatesFilter<"bn_categories"> | number
    footer_menu?: IntWithAggregatesFilter<"bn_categories"> | number
    status?: IntWithAggregatesFilter<"bn_categories"> | number
    deletable?: IntWithAggregatesFilter<"bn_categories"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"bn_categories"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"bn_categories"> | Date | string | null
  }

  export type bn_content_positionsWhereInput = {
    AND?: bn_content_positionsWhereInput | bn_content_positionsWhereInput[]
    OR?: bn_content_positionsWhereInput[]
    NOT?: bn_content_positionsWhereInput | bn_content_positionsWhereInput[]
    position_id?: IntFilter<"bn_content_positions"> | number
    position_name?: StringFilter<"bn_content_positions"> | string
    position_slug?: StringFilter<"bn_content_positions"> | string
    cat_id?: IntNullableFilter<"bn_content_positions"> | number | null
    special_cat_id?: IntNullableFilter<"bn_content_positions"> | number | null
    subcat_id?: IntNullableFilter<"bn_content_positions"> | number | null
    content_ids?: StringNullableFilter<"bn_content_positions"> | string | null
    total_content?: IntNullableFilter<"bn_content_positions"> | number | null
    status?: IntFilter<"bn_content_positions"> | number
    deletable?: IntFilter<"bn_content_positions"> | number
    created_at?: DateTimeNullableFilter<"bn_content_positions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_content_positions"> | Date | string | null
  }

  export type bn_content_positionsOrderByWithRelationInput = {
    position_id?: SortOrder
    position_name?: SortOrder
    position_slug?: SortOrder
    cat_id?: SortOrderInput | SortOrder
    special_cat_id?: SortOrderInput | SortOrder
    subcat_id?: SortOrderInput | SortOrder
    content_ids?: SortOrderInput | SortOrder
    total_content?: SortOrderInput | SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type bn_content_positionsWhereUniqueInput = Prisma.AtLeast<{
    position_id?: number
    AND?: bn_content_positionsWhereInput | bn_content_positionsWhereInput[]
    OR?: bn_content_positionsWhereInput[]
    NOT?: bn_content_positionsWhereInput | bn_content_positionsWhereInput[]
    position_name?: StringFilter<"bn_content_positions"> | string
    position_slug?: StringFilter<"bn_content_positions"> | string
    cat_id?: IntNullableFilter<"bn_content_positions"> | number | null
    special_cat_id?: IntNullableFilter<"bn_content_positions"> | number | null
    subcat_id?: IntNullableFilter<"bn_content_positions"> | number | null
    content_ids?: StringNullableFilter<"bn_content_positions"> | string | null
    total_content?: IntNullableFilter<"bn_content_positions"> | number | null
    status?: IntFilter<"bn_content_positions"> | number
    deletable?: IntFilter<"bn_content_positions"> | number
    created_at?: DateTimeNullableFilter<"bn_content_positions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_content_positions"> | Date | string | null
  }, "position_id">

  export type bn_content_positionsOrderByWithAggregationInput = {
    position_id?: SortOrder
    position_name?: SortOrder
    position_slug?: SortOrder
    cat_id?: SortOrderInput | SortOrder
    special_cat_id?: SortOrderInput | SortOrder
    subcat_id?: SortOrderInput | SortOrder
    content_ids?: SortOrderInput | SortOrder
    total_content?: SortOrderInput | SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: bn_content_positionsCountOrderByAggregateInput
    _avg?: bn_content_positionsAvgOrderByAggregateInput
    _max?: bn_content_positionsMaxOrderByAggregateInput
    _min?: bn_content_positionsMinOrderByAggregateInput
    _sum?: bn_content_positionsSumOrderByAggregateInput
  }

  export type bn_content_positionsScalarWhereWithAggregatesInput = {
    AND?: bn_content_positionsScalarWhereWithAggregatesInput | bn_content_positionsScalarWhereWithAggregatesInput[]
    OR?: bn_content_positionsScalarWhereWithAggregatesInput[]
    NOT?: bn_content_positionsScalarWhereWithAggregatesInput | bn_content_positionsScalarWhereWithAggregatesInput[]
    position_id?: IntWithAggregatesFilter<"bn_content_positions"> | number
    position_name?: StringWithAggregatesFilter<"bn_content_positions"> | string
    position_slug?: StringWithAggregatesFilter<"bn_content_positions"> | string
    cat_id?: IntNullableWithAggregatesFilter<"bn_content_positions"> | number | null
    special_cat_id?: IntNullableWithAggregatesFilter<"bn_content_positions"> | number | null
    subcat_id?: IntNullableWithAggregatesFilter<"bn_content_positions"> | number | null
    content_ids?: StringNullableWithAggregatesFilter<"bn_content_positions"> | string | null
    total_content?: IntNullableWithAggregatesFilter<"bn_content_positions"> | number | null
    status?: IntWithAggregatesFilter<"bn_content_positions"> | number
    deletable?: IntWithAggregatesFilter<"bn_content_positions"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"bn_content_positions"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"bn_content_positions"> | Date | string | null
  }

  export type bn_contentsWhereInput = {
    AND?: bn_contentsWhereInput | bn_contentsWhereInput[]
    OR?: bn_contentsWhereInput[]
    NOT?: bn_contentsWhereInput | bn_contentsWhereInput[]
    content_id?: IntFilter<"bn_contents"> | number
    content_type?: IntFilter<"bn_contents"> | number
    cat_id?: IntFilter<"bn_contents"> | number
    subcat_id?: IntFilter<"bn_contents"> | number
    special_cat_id?: IntFilter<"bn_contents"> | number
    country_id?: IntFilter<"bn_contents"> | number
    division_id?: IntFilter<"bn_contents"> | number
    district_id?: IntFilter<"bn_contents"> | number
    upozilla_id?: IntFilter<"bn_contents"> | number
    content_heading?: StringFilter<"bn_contents"> | string
    content_sub_heading?: StringNullableFilter<"bn_contents"> | string | null
    author_slugs?: StringNullableFilter<"bn_contents"> | string | null
    author_name?: StringNullableFilter<"bn_contents"> | string | null
    content_brief?: StringNullableFilter<"bn_contents"> | string | null
    content_details?: StringFilter<"bn_contents"> | string
    img_xs_path?: StringNullableFilter<"bn_contents"> | string | null
    img_sm_path?: StringNullableFilter<"bn_contents"> | string | null
    img_sm_caption?: StringNullableFilter<"bn_contents"> | string | null
    img_bg_path?: StringNullableFilter<"bn_contents"> | string | null
    og_image?: StringNullableFilter<"bn_contents"> | string | null
    img_bg_caption?: StringNullableFilter<"bn_contents"> | string | null
    related_ids?: StringNullableFilter<"bn_contents"> | string | null
    photo_ids?: StringNullableFilter<"bn_contents"> | string | null
    video_type?: IntNullableFilter<"bn_contents"> | number | null
    video_id?: StringNullableFilter<"bn_contents"> | string | null
    uploader_id?: IntFilter<"bn_contents"> | number
    reporter_id?: IntNullableFilter<"bn_contents"> | number | null
    tags?: StringNullableFilter<"bn_contents"> | string | null
    meta_keywords?: StringNullableFilter<"bn_contents"> | string | null
    timeline_tag?: StringNullableFilter<"bn_contents"> | string | null
    podcast_id?: StringNullableFilter<"bn_contents"> | string | null
    status?: IntFilter<"bn_contents"> | number
    scroll?: IntFilter<"bn_contents"> | number
    total_hit?: IntFilter<"bn_contents"> | number
    deletable?: IntFilter<"bn_contents"> | number
    created_at?: DateTimeNullableFilter<"bn_contents"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_contents"> | Date | string | null
  }

  export type bn_contentsOrderByWithRelationInput = {
    content_id?: SortOrder
    content_type?: SortOrder
    cat_id?: SortOrder
    subcat_id?: SortOrder
    special_cat_id?: SortOrder
    country_id?: SortOrder
    division_id?: SortOrder
    district_id?: SortOrder
    upozilla_id?: SortOrder
    content_heading?: SortOrder
    content_sub_heading?: SortOrderInput | SortOrder
    author_slugs?: SortOrderInput | SortOrder
    author_name?: SortOrderInput | SortOrder
    content_brief?: SortOrderInput | SortOrder
    content_details?: SortOrder
    img_xs_path?: SortOrderInput | SortOrder
    img_sm_path?: SortOrderInput | SortOrder
    img_sm_caption?: SortOrderInput | SortOrder
    img_bg_path?: SortOrderInput | SortOrder
    og_image?: SortOrderInput | SortOrder
    img_bg_caption?: SortOrderInput | SortOrder
    related_ids?: SortOrderInput | SortOrder
    photo_ids?: SortOrderInput | SortOrder
    video_type?: SortOrderInput | SortOrder
    video_id?: SortOrderInput | SortOrder
    uploader_id?: SortOrder
    reporter_id?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    meta_keywords?: SortOrderInput | SortOrder
    timeline_tag?: SortOrderInput | SortOrder
    podcast_id?: SortOrderInput | SortOrder
    status?: SortOrder
    scroll?: SortOrder
    total_hit?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type bn_contentsWhereUniqueInput = Prisma.AtLeast<{
    content_id?: number
    AND?: bn_contentsWhereInput | bn_contentsWhereInput[]
    OR?: bn_contentsWhereInput[]
    NOT?: bn_contentsWhereInput | bn_contentsWhereInput[]
    content_type?: IntFilter<"bn_contents"> | number
    cat_id?: IntFilter<"bn_contents"> | number
    subcat_id?: IntFilter<"bn_contents"> | number
    special_cat_id?: IntFilter<"bn_contents"> | number
    country_id?: IntFilter<"bn_contents"> | number
    division_id?: IntFilter<"bn_contents"> | number
    district_id?: IntFilter<"bn_contents"> | number
    upozilla_id?: IntFilter<"bn_contents"> | number
    content_heading?: StringFilter<"bn_contents"> | string
    content_sub_heading?: StringNullableFilter<"bn_contents"> | string | null
    author_slugs?: StringNullableFilter<"bn_contents"> | string | null
    author_name?: StringNullableFilter<"bn_contents"> | string | null
    content_brief?: StringNullableFilter<"bn_contents"> | string | null
    content_details?: StringFilter<"bn_contents"> | string
    img_xs_path?: StringNullableFilter<"bn_contents"> | string | null
    img_sm_path?: StringNullableFilter<"bn_contents"> | string | null
    img_sm_caption?: StringNullableFilter<"bn_contents"> | string | null
    img_bg_path?: StringNullableFilter<"bn_contents"> | string | null
    og_image?: StringNullableFilter<"bn_contents"> | string | null
    img_bg_caption?: StringNullableFilter<"bn_contents"> | string | null
    related_ids?: StringNullableFilter<"bn_contents"> | string | null
    photo_ids?: StringNullableFilter<"bn_contents"> | string | null
    video_type?: IntNullableFilter<"bn_contents"> | number | null
    video_id?: StringNullableFilter<"bn_contents"> | string | null
    uploader_id?: IntFilter<"bn_contents"> | number
    reporter_id?: IntNullableFilter<"bn_contents"> | number | null
    tags?: StringNullableFilter<"bn_contents"> | string | null
    meta_keywords?: StringNullableFilter<"bn_contents"> | string | null
    timeline_tag?: StringNullableFilter<"bn_contents"> | string | null
    podcast_id?: StringNullableFilter<"bn_contents"> | string | null
    status?: IntFilter<"bn_contents"> | number
    scroll?: IntFilter<"bn_contents"> | number
    total_hit?: IntFilter<"bn_contents"> | number
    deletable?: IntFilter<"bn_contents"> | number
    created_at?: DateTimeNullableFilter<"bn_contents"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_contents"> | Date | string | null
  }, "content_id">

  export type bn_contentsOrderByWithAggregationInput = {
    content_id?: SortOrder
    content_type?: SortOrder
    cat_id?: SortOrder
    subcat_id?: SortOrder
    special_cat_id?: SortOrder
    country_id?: SortOrder
    division_id?: SortOrder
    district_id?: SortOrder
    upozilla_id?: SortOrder
    content_heading?: SortOrder
    content_sub_heading?: SortOrderInput | SortOrder
    author_slugs?: SortOrderInput | SortOrder
    author_name?: SortOrderInput | SortOrder
    content_brief?: SortOrderInput | SortOrder
    content_details?: SortOrder
    img_xs_path?: SortOrderInput | SortOrder
    img_sm_path?: SortOrderInput | SortOrder
    img_sm_caption?: SortOrderInput | SortOrder
    img_bg_path?: SortOrderInput | SortOrder
    og_image?: SortOrderInput | SortOrder
    img_bg_caption?: SortOrderInput | SortOrder
    related_ids?: SortOrderInput | SortOrder
    photo_ids?: SortOrderInput | SortOrder
    video_type?: SortOrderInput | SortOrder
    video_id?: SortOrderInput | SortOrder
    uploader_id?: SortOrder
    reporter_id?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    meta_keywords?: SortOrderInput | SortOrder
    timeline_tag?: SortOrderInput | SortOrder
    podcast_id?: SortOrderInput | SortOrder
    status?: SortOrder
    scroll?: SortOrder
    total_hit?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: bn_contentsCountOrderByAggregateInput
    _avg?: bn_contentsAvgOrderByAggregateInput
    _max?: bn_contentsMaxOrderByAggregateInput
    _min?: bn_contentsMinOrderByAggregateInput
    _sum?: bn_contentsSumOrderByAggregateInput
  }

  export type bn_contentsScalarWhereWithAggregatesInput = {
    AND?: bn_contentsScalarWhereWithAggregatesInput | bn_contentsScalarWhereWithAggregatesInput[]
    OR?: bn_contentsScalarWhereWithAggregatesInput[]
    NOT?: bn_contentsScalarWhereWithAggregatesInput | bn_contentsScalarWhereWithAggregatesInput[]
    content_id?: IntWithAggregatesFilter<"bn_contents"> | number
    content_type?: IntWithAggregatesFilter<"bn_contents"> | number
    cat_id?: IntWithAggregatesFilter<"bn_contents"> | number
    subcat_id?: IntWithAggregatesFilter<"bn_contents"> | number
    special_cat_id?: IntWithAggregatesFilter<"bn_contents"> | number
    country_id?: IntWithAggregatesFilter<"bn_contents"> | number
    division_id?: IntWithAggregatesFilter<"bn_contents"> | number
    district_id?: IntWithAggregatesFilter<"bn_contents"> | number
    upozilla_id?: IntWithAggregatesFilter<"bn_contents"> | number
    content_heading?: StringWithAggregatesFilter<"bn_contents"> | string
    content_sub_heading?: StringNullableWithAggregatesFilter<"bn_contents"> | string | null
    author_slugs?: StringNullableWithAggregatesFilter<"bn_contents"> | string | null
    author_name?: StringNullableWithAggregatesFilter<"bn_contents"> | string | null
    content_brief?: StringNullableWithAggregatesFilter<"bn_contents"> | string | null
    content_details?: StringWithAggregatesFilter<"bn_contents"> | string
    img_xs_path?: StringNullableWithAggregatesFilter<"bn_contents"> | string | null
    img_sm_path?: StringNullableWithAggregatesFilter<"bn_contents"> | string | null
    img_sm_caption?: StringNullableWithAggregatesFilter<"bn_contents"> | string | null
    img_bg_path?: StringNullableWithAggregatesFilter<"bn_contents"> | string | null
    og_image?: StringNullableWithAggregatesFilter<"bn_contents"> | string | null
    img_bg_caption?: StringNullableWithAggregatesFilter<"bn_contents"> | string | null
    related_ids?: StringNullableWithAggregatesFilter<"bn_contents"> | string | null
    photo_ids?: StringNullableWithAggregatesFilter<"bn_contents"> | string | null
    video_type?: IntNullableWithAggregatesFilter<"bn_contents"> | number | null
    video_id?: StringNullableWithAggregatesFilter<"bn_contents"> | string | null
    uploader_id?: IntWithAggregatesFilter<"bn_contents"> | number
    reporter_id?: IntNullableWithAggregatesFilter<"bn_contents"> | number | null
    tags?: StringNullableWithAggregatesFilter<"bn_contents"> | string | null
    meta_keywords?: StringNullableWithAggregatesFilter<"bn_contents"> | string | null
    timeline_tag?: StringNullableWithAggregatesFilter<"bn_contents"> | string | null
    podcast_id?: StringNullableWithAggregatesFilter<"bn_contents"> | string | null
    status?: IntWithAggregatesFilter<"bn_contents"> | number
    scroll?: IntWithAggregatesFilter<"bn_contents"> | number
    total_hit?: IntWithAggregatesFilter<"bn_contents"> | number
    deletable?: IntWithAggregatesFilter<"bn_contents"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"bn_contents"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"bn_contents"> | Date | string | null
  }

  export type bn_mobile_adsWhereInput = {
    AND?: bn_mobile_adsWhereInput | bn_mobile_adsWhereInput[]
    OR?: bn_mobile_adsWhereInput[]
    NOT?: bn_mobile_adsWhereInput | bn_mobile_adsWhereInput[]
    id?: IntFilter<"bn_mobile_ads"> | number
    type?: IntNullableFilter<"bn_mobile_ads"> | number | null
    page?: IntNullableFilter<"bn_mobile_ads"> | number | null
    position?: IntNullableFilter<"bn_mobile_ads"> | number | null
    dfp_header_code?: StringNullableFilter<"bn_mobile_ads"> | string | null
    code?: StringNullableFilter<"bn_mobile_ads"> | string | null
    mobile_image_path?: StringNullableFilter<"bn_mobile_ads"> | string | null
    external_link?: StringNullableFilter<"bn_mobile_ads"> | string | null
    start_time?: DateTimeNullableFilter<"bn_mobile_ads"> | Date | string | null
    end_time?: DateTimeNullableFilter<"bn_mobile_ads"> | Date | string | null
    status?: IntNullableFilter<"bn_mobile_ads"> | number | null
    deletable?: IntNullableFilter<"bn_mobile_ads"> | number | null
    created_at?: DateTimeNullableFilter<"bn_mobile_ads"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_mobile_ads"> | Date | string | null
  }

  export type bn_mobile_adsOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    page?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    dfp_header_code?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    mobile_image_path?: SortOrderInput | SortOrder
    external_link?: SortOrderInput | SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    deletable?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type bn_mobile_adsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bn_mobile_adsWhereInput | bn_mobile_adsWhereInput[]
    OR?: bn_mobile_adsWhereInput[]
    NOT?: bn_mobile_adsWhereInput | bn_mobile_adsWhereInput[]
    type?: IntNullableFilter<"bn_mobile_ads"> | number | null
    page?: IntNullableFilter<"bn_mobile_ads"> | number | null
    position?: IntNullableFilter<"bn_mobile_ads"> | number | null
    dfp_header_code?: StringNullableFilter<"bn_mobile_ads"> | string | null
    code?: StringNullableFilter<"bn_mobile_ads"> | string | null
    mobile_image_path?: StringNullableFilter<"bn_mobile_ads"> | string | null
    external_link?: StringNullableFilter<"bn_mobile_ads"> | string | null
    start_time?: DateTimeNullableFilter<"bn_mobile_ads"> | Date | string | null
    end_time?: DateTimeNullableFilter<"bn_mobile_ads"> | Date | string | null
    status?: IntNullableFilter<"bn_mobile_ads"> | number | null
    deletable?: IntNullableFilter<"bn_mobile_ads"> | number | null
    created_at?: DateTimeNullableFilter<"bn_mobile_ads"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_mobile_ads"> | Date | string | null
  }, "id">

  export type bn_mobile_adsOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    page?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    dfp_header_code?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    mobile_image_path?: SortOrderInput | SortOrder
    external_link?: SortOrderInput | SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    deletable?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: bn_mobile_adsCountOrderByAggregateInput
    _avg?: bn_mobile_adsAvgOrderByAggregateInput
    _max?: bn_mobile_adsMaxOrderByAggregateInput
    _min?: bn_mobile_adsMinOrderByAggregateInput
    _sum?: bn_mobile_adsSumOrderByAggregateInput
  }

  export type bn_mobile_adsScalarWhereWithAggregatesInput = {
    AND?: bn_mobile_adsScalarWhereWithAggregatesInput | bn_mobile_adsScalarWhereWithAggregatesInput[]
    OR?: bn_mobile_adsScalarWhereWithAggregatesInput[]
    NOT?: bn_mobile_adsScalarWhereWithAggregatesInput | bn_mobile_adsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bn_mobile_ads"> | number
    type?: IntNullableWithAggregatesFilter<"bn_mobile_ads"> | number | null
    page?: IntNullableWithAggregatesFilter<"bn_mobile_ads"> | number | null
    position?: IntNullableWithAggregatesFilter<"bn_mobile_ads"> | number | null
    dfp_header_code?: StringNullableWithAggregatesFilter<"bn_mobile_ads"> | string | null
    code?: StringNullableWithAggregatesFilter<"bn_mobile_ads"> | string | null
    mobile_image_path?: StringNullableWithAggregatesFilter<"bn_mobile_ads"> | string | null
    external_link?: StringNullableWithAggregatesFilter<"bn_mobile_ads"> | string | null
    start_time?: DateTimeNullableWithAggregatesFilter<"bn_mobile_ads"> | Date | string | null
    end_time?: DateTimeNullableWithAggregatesFilter<"bn_mobile_ads"> | Date | string | null
    status?: IntNullableWithAggregatesFilter<"bn_mobile_ads"> | number | null
    deletable?: IntNullableWithAggregatesFilter<"bn_mobile_ads"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"bn_mobile_ads"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"bn_mobile_ads"> | Date | string | null
  }

  export type bn_position_fixedWhereInput = {
    AND?: bn_position_fixedWhereInput | bn_position_fixedWhereInput[]
    OR?: bn_position_fixedWhereInput[]
    NOT?: bn_position_fixedWhereInput | bn_position_fixedWhereInput[]
    id?: IntFilter<"bn_position_fixed"> | number
    position_number?: IntNullableFilter<"bn_position_fixed"> | number | null
    news_id?: IntNullableFilter<"bn_position_fixed"> | number | null
    is_fixed?: IntNullableFilter<"bn_position_fixed"> | number | null
    created_at?: DateTimeNullableFilter<"bn_position_fixed"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_position_fixed"> | Date | string | null
  }

  export type bn_position_fixedOrderByWithRelationInput = {
    id?: SortOrder
    position_number?: SortOrderInput | SortOrder
    news_id?: SortOrderInput | SortOrder
    is_fixed?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type bn_position_fixedWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bn_position_fixedWhereInput | bn_position_fixedWhereInput[]
    OR?: bn_position_fixedWhereInput[]
    NOT?: bn_position_fixedWhereInput | bn_position_fixedWhereInput[]
    position_number?: IntNullableFilter<"bn_position_fixed"> | number | null
    news_id?: IntNullableFilter<"bn_position_fixed"> | number | null
    is_fixed?: IntNullableFilter<"bn_position_fixed"> | number | null
    created_at?: DateTimeNullableFilter<"bn_position_fixed"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_position_fixed"> | Date | string | null
  }, "id">

  export type bn_position_fixedOrderByWithAggregationInput = {
    id?: SortOrder
    position_number?: SortOrderInput | SortOrder
    news_id?: SortOrderInput | SortOrder
    is_fixed?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: bn_position_fixedCountOrderByAggregateInput
    _avg?: bn_position_fixedAvgOrderByAggregateInput
    _max?: bn_position_fixedMaxOrderByAggregateInput
    _min?: bn_position_fixedMinOrderByAggregateInput
    _sum?: bn_position_fixedSumOrderByAggregateInput
  }

  export type bn_position_fixedScalarWhereWithAggregatesInput = {
    AND?: bn_position_fixedScalarWhereWithAggregatesInput | bn_position_fixedScalarWhereWithAggregatesInput[]
    OR?: bn_position_fixedScalarWhereWithAggregatesInput[]
    NOT?: bn_position_fixedScalarWhereWithAggregatesInput | bn_position_fixedScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bn_position_fixed"> | number
    position_number?: IntNullableWithAggregatesFilter<"bn_position_fixed"> | number | null
    news_id?: IntNullableWithAggregatesFilter<"bn_position_fixed"> | number | null
    is_fixed?: IntNullableWithAggregatesFilter<"bn_position_fixed"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"bn_position_fixed"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"bn_position_fixed"> | Date | string | null
  }

  export type bn_subcategoriesWhereInput = {
    AND?: bn_subcategoriesWhereInput | bn_subcategoriesWhereInput[]
    OR?: bn_subcategoriesWhereInput[]
    NOT?: bn_subcategoriesWhereInput | bn_subcategoriesWhereInput[]
    subcat_id?: IntFilter<"bn_subcategories"> | number
    cat_id?: IntFilter<"bn_subcategories"> | number
    subcat_name?: StringFilter<"bn_subcategories"> | string
    subcat_name_bn?: StringFilter<"bn_subcategories"> | string
    subcat_slug?: StringFilter<"bn_subcategories"> | string
    subcat_meta_keyword?: StringNullableFilter<"bn_subcategories"> | string | null
    subcat_meta_description?: StringNullableFilter<"bn_subcategories"> | string | null
    subcat_position?: IntFilter<"bn_subcategories"> | number
    status?: IntFilter<"bn_subcategories"> | number
    deletable?: IntFilter<"bn_subcategories"> | number
    created_at?: DateTimeNullableFilter<"bn_subcategories"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_subcategories"> | Date | string | null
  }

  export type bn_subcategoriesOrderByWithRelationInput = {
    subcat_id?: SortOrder
    cat_id?: SortOrder
    subcat_name?: SortOrder
    subcat_name_bn?: SortOrder
    subcat_slug?: SortOrder
    subcat_meta_keyword?: SortOrderInput | SortOrder
    subcat_meta_description?: SortOrderInput | SortOrder
    subcat_position?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type bn_subcategoriesWhereUniqueInput = Prisma.AtLeast<{
    subcat_id?: number
    AND?: bn_subcategoriesWhereInput | bn_subcategoriesWhereInput[]
    OR?: bn_subcategoriesWhereInput[]
    NOT?: bn_subcategoriesWhereInput | bn_subcategoriesWhereInput[]
    cat_id?: IntFilter<"bn_subcategories"> | number
    subcat_name?: StringFilter<"bn_subcategories"> | string
    subcat_name_bn?: StringFilter<"bn_subcategories"> | string
    subcat_slug?: StringFilter<"bn_subcategories"> | string
    subcat_meta_keyword?: StringNullableFilter<"bn_subcategories"> | string | null
    subcat_meta_description?: StringNullableFilter<"bn_subcategories"> | string | null
    subcat_position?: IntFilter<"bn_subcategories"> | number
    status?: IntFilter<"bn_subcategories"> | number
    deletable?: IntFilter<"bn_subcategories"> | number
    created_at?: DateTimeNullableFilter<"bn_subcategories"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_subcategories"> | Date | string | null
  }, "subcat_id">

  export type bn_subcategoriesOrderByWithAggregationInput = {
    subcat_id?: SortOrder
    cat_id?: SortOrder
    subcat_name?: SortOrder
    subcat_name_bn?: SortOrder
    subcat_slug?: SortOrder
    subcat_meta_keyword?: SortOrderInput | SortOrder
    subcat_meta_description?: SortOrderInput | SortOrder
    subcat_position?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: bn_subcategoriesCountOrderByAggregateInput
    _avg?: bn_subcategoriesAvgOrderByAggregateInput
    _max?: bn_subcategoriesMaxOrderByAggregateInput
    _min?: bn_subcategoriesMinOrderByAggregateInput
    _sum?: bn_subcategoriesSumOrderByAggregateInput
  }

  export type bn_subcategoriesScalarWhereWithAggregatesInput = {
    AND?: bn_subcategoriesScalarWhereWithAggregatesInput | bn_subcategoriesScalarWhereWithAggregatesInput[]
    OR?: bn_subcategoriesScalarWhereWithAggregatesInput[]
    NOT?: bn_subcategoriesScalarWhereWithAggregatesInput | bn_subcategoriesScalarWhereWithAggregatesInput[]
    subcat_id?: IntWithAggregatesFilter<"bn_subcategories"> | number
    cat_id?: IntWithAggregatesFilter<"bn_subcategories"> | number
    subcat_name?: StringWithAggregatesFilter<"bn_subcategories"> | string
    subcat_name_bn?: StringWithAggregatesFilter<"bn_subcategories"> | string
    subcat_slug?: StringWithAggregatesFilter<"bn_subcategories"> | string
    subcat_meta_keyword?: StringNullableWithAggregatesFilter<"bn_subcategories"> | string | null
    subcat_meta_description?: StringNullableWithAggregatesFilter<"bn_subcategories"> | string | null
    subcat_position?: IntWithAggregatesFilter<"bn_subcategories"> | number
    status?: IntWithAggregatesFilter<"bn_subcategories"> | number
    deletable?: IntWithAggregatesFilter<"bn_subcategories"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"bn_subcategories"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"bn_subcategories"> | Date | string | null
  }

  export type bn_tagsWhereInput = {
    AND?: bn_tagsWhereInput | bn_tagsWhereInput[]
    OR?: bn_tagsWhereInput[]
    NOT?: bn_tagsWhereInput | bn_tagsWhereInput[]
    tag_id?: IntFilter<"bn_tags"> | number
    tag_type?: IntNullableFilter<"bn_tags"> | number | null
    tag_name?: StringFilter<"bn_tags"> | string
    tag_slug?: StringFilter<"bn_tags"> | string
    description?: StringNullableFilter<"bn_tags"> | string | null
    img_path?: StringNullableFilter<"bn_tags"> | string | null
    approval?: IntFilter<"bn_tags"> | number
    deletable?: IntFilter<"bn_tags"> | number
    created_at?: DateTimeNullableFilter<"bn_tags"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_tags"> | Date | string | null
  }

  export type bn_tagsOrderByWithRelationInput = {
    tag_id?: SortOrder
    tag_type?: SortOrderInput | SortOrder
    tag_name?: SortOrder
    tag_slug?: SortOrder
    description?: SortOrderInput | SortOrder
    img_path?: SortOrderInput | SortOrder
    approval?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type bn_tagsWhereUniqueInput = Prisma.AtLeast<{
    tag_id?: number
    tag_name?: string
    tag_slug?: string
    AND?: bn_tagsWhereInput | bn_tagsWhereInput[]
    OR?: bn_tagsWhereInput[]
    NOT?: bn_tagsWhereInput | bn_tagsWhereInput[]
    tag_type?: IntNullableFilter<"bn_tags"> | number | null
    description?: StringNullableFilter<"bn_tags"> | string | null
    img_path?: StringNullableFilter<"bn_tags"> | string | null
    approval?: IntFilter<"bn_tags"> | number
    deletable?: IntFilter<"bn_tags"> | number
    created_at?: DateTimeNullableFilter<"bn_tags"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_tags"> | Date | string | null
  }, "tag_id" | "tag_name" | "tag_slug">

  export type bn_tagsOrderByWithAggregationInput = {
    tag_id?: SortOrder
    tag_type?: SortOrderInput | SortOrder
    tag_name?: SortOrder
    tag_slug?: SortOrder
    description?: SortOrderInput | SortOrder
    img_path?: SortOrderInput | SortOrder
    approval?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: bn_tagsCountOrderByAggregateInput
    _avg?: bn_tagsAvgOrderByAggregateInput
    _max?: bn_tagsMaxOrderByAggregateInput
    _min?: bn_tagsMinOrderByAggregateInput
    _sum?: bn_tagsSumOrderByAggregateInput
  }

  export type bn_tagsScalarWhereWithAggregatesInput = {
    AND?: bn_tagsScalarWhereWithAggregatesInput | bn_tagsScalarWhereWithAggregatesInput[]
    OR?: bn_tagsScalarWhereWithAggregatesInput[]
    NOT?: bn_tagsScalarWhereWithAggregatesInput | bn_tagsScalarWhereWithAggregatesInput[]
    tag_id?: IntWithAggregatesFilter<"bn_tags"> | number
    tag_type?: IntNullableWithAggregatesFilter<"bn_tags"> | number | null
    tag_name?: StringWithAggregatesFilter<"bn_tags"> | string
    tag_slug?: StringWithAggregatesFilter<"bn_tags"> | string
    description?: StringNullableWithAggregatesFilter<"bn_tags"> | string | null
    img_path?: StringNullableWithAggregatesFilter<"bn_tags"> | string | null
    approval?: IntWithAggregatesFilter<"bn_tags"> | number
    deletable?: IntWithAggregatesFilter<"bn_tags"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"bn_tags"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"bn_tags"> | Date | string | null
  }

  export type bn_video_categoriesWhereInput = {
    AND?: bn_video_categoriesWhereInput | bn_video_categoriesWhereInput[]
    OR?: bn_video_categoriesWhereInput[]
    NOT?: bn_video_categoriesWhereInput | bn_video_categoriesWhereInput[]
    id?: IntFilter<"bn_video_categories"> | number
    name?: StringNullableFilter<"bn_video_categories"> | string | null
    slug?: StringNullableFilter<"bn_video_categories"> | string | null
    name_bn?: StringNullableFilter<"bn_video_categories"> | string | null
    meta_keywords?: StringNullableFilter<"bn_video_categories"> | string | null
    meta_description?: StringNullableFilter<"bn_video_categories"> | string | null
    og_img_path?: StringNullableFilter<"bn_video_categories"> | string | null
    position?: IntNullableFilter<"bn_video_categories"> | number | null
    user_id?: IntNullableFilter<"bn_video_categories"> | number | null
    status?: IntNullableFilter<"bn_video_categories"> | number | null
    deletable?: IntNullableFilter<"bn_video_categories"> | number | null
    created_at?: DateTimeNullableFilter<"bn_video_categories"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_video_categories"> | Date | string | null
  }

  export type bn_video_categoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    name_bn?: SortOrderInput | SortOrder
    meta_keywords?: SortOrderInput | SortOrder
    meta_description?: SortOrderInput | SortOrder
    og_img_path?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    deletable?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type bn_video_categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bn_video_categoriesWhereInput | bn_video_categoriesWhereInput[]
    OR?: bn_video_categoriesWhereInput[]
    NOT?: bn_video_categoriesWhereInput | bn_video_categoriesWhereInput[]
    name?: StringNullableFilter<"bn_video_categories"> | string | null
    slug?: StringNullableFilter<"bn_video_categories"> | string | null
    name_bn?: StringNullableFilter<"bn_video_categories"> | string | null
    meta_keywords?: StringNullableFilter<"bn_video_categories"> | string | null
    meta_description?: StringNullableFilter<"bn_video_categories"> | string | null
    og_img_path?: StringNullableFilter<"bn_video_categories"> | string | null
    position?: IntNullableFilter<"bn_video_categories"> | number | null
    user_id?: IntNullableFilter<"bn_video_categories"> | number | null
    status?: IntNullableFilter<"bn_video_categories"> | number | null
    deletable?: IntNullableFilter<"bn_video_categories"> | number | null
    created_at?: DateTimeNullableFilter<"bn_video_categories"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_video_categories"> | Date | string | null
  }, "id">

  export type bn_video_categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    name_bn?: SortOrderInput | SortOrder
    meta_keywords?: SortOrderInput | SortOrder
    meta_description?: SortOrderInput | SortOrder
    og_img_path?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    deletable?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: bn_video_categoriesCountOrderByAggregateInput
    _avg?: bn_video_categoriesAvgOrderByAggregateInput
    _max?: bn_video_categoriesMaxOrderByAggregateInput
    _min?: bn_video_categoriesMinOrderByAggregateInput
    _sum?: bn_video_categoriesSumOrderByAggregateInput
  }

  export type bn_video_categoriesScalarWhereWithAggregatesInput = {
    AND?: bn_video_categoriesScalarWhereWithAggregatesInput | bn_video_categoriesScalarWhereWithAggregatesInput[]
    OR?: bn_video_categoriesScalarWhereWithAggregatesInput[]
    NOT?: bn_video_categoriesScalarWhereWithAggregatesInput | bn_video_categoriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bn_video_categories"> | number
    name?: StringNullableWithAggregatesFilter<"bn_video_categories"> | string | null
    slug?: StringNullableWithAggregatesFilter<"bn_video_categories"> | string | null
    name_bn?: StringNullableWithAggregatesFilter<"bn_video_categories"> | string | null
    meta_keywords?: StringNullableWithAggregatesFilter<"bn_video_categories"> | string | null
    meta_description?: StringNullableWithAggregatesFilter<"bn_video_categories"> | string | null
    og_img_path?: StringNullableWithAggregatesFilter<"bn_video_categories"> | string | null
    position?: IntNullableWithAggregatesFilter<"bn_video_categories"> | number | null
    user_id?: IntNullableWithAggregatesFilter<"bn_video_categories"> | number | null
    status?: IntNullableWithAggregatesFilter<"bn_video_categories"> | number | null
    deletable?: IntNullableWithAggregatesFilter<"bn_video_categories"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"bn_video_categories"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"bn_video_categories"> | Date | string | null
  }

  export type bn_video_positionsWhereInput = {
    AND?: bn_video_positionsWhereInput | bn_video_positionsWhereInput[]
    OR?: bn_video_positionsWhereInput[]
    NOT?: bn_video_positionsWhereInput | bn_video_positionsWhereInput[]
    position_id?: IntFilter<"bn_video_positions"> | number
    position_name?: StringFilter<"bn_video_positions"> | string
    cat_id?: IntNullableFilter<"bn_video_positions"> | number | null
    subcat_id?: IntNullableFilter<"bn_video_positions"> | number | null
    video_ids?: StringNullableFilter<"bn_video_positions"> | string | null
    total_video?: IntNullableFilter<"bn_video_positions"> | number | null
    deletable?: IntFilter<"bn_video_positions"> | number
    created_at?: DateTimeNullableFilter<"bn_video_positions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_video_positions"> | Date | string | null
  }

  export type bn_video_positionsOrderByWithRelationInput = {
    position_id?: SortOrder
    position_name?: SortOrder
    cat_id?: SortOrderInput | SortOrder
    subcat_id?: SortOrderInput | SortOrder
    video_ids?: SortOrderInput | SortOrder
    total_video?: SortOrderInput | SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type bn_video_positionsWhereUniqueInput = Prisma.AtLeast<{
    position_id?: number
    AND?: bn_video_positionsWhereInput | bn_video_positionsWhereInput[]
    OR?: bn_video_positionsWhereInput[]
    NOT?: bn_video_positionsWhereInput | bn_video_positionsWhereInput[]
    position_name?: StringFilter<"bn_video_positions"> | string
    cat_id?: IntNullableFilter<"bn_video_positions"> | number | null
    subcat_id?: IntNullableFilter<"bn_video_positions"> | number | null
    video_ids?: StringNullableFilter<"bn_video_positions"> | string | null
    total_video?: IntNullableFilter<"bn_video_positions"> | number | null
    deletable?: IntFilter<"bn_video_positions"> | number
    created_at?: DateTimeNullableFilter<"bn_video_positions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_video_positions"> | Date | string | null
  }, "position_id">

  export type bn_video_positionsOrderByWithAggregationInput = {
    position_id?: SortOrder
    position_name?: SortOrder
    cat_id?: SortOrderInput | SortOrder
    subcat_id?: SortOrderInput | SortOrder
    video_ids?: SortOrderInput | SortOrder
    total_video?: SortOrderInput | SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: bn_video_positionsCountOrderByAggregateInput
    _avg?: bn_video_positionsAvgOrderByAggregateInput
    _max?: bn_video_positionsMaxOrderByAggregateInput
    _min?: bn_video_positionsMinOrderByAggregateInput
    _sum?: bn_video_positionsSumOrderByAggregateInput
  }

  export type bn_video_positionsScalarWhereWithAggregatesInput = {
    AND?: bn_video_positionsScalarWhereWithAggregatesInput | bn_video_positionsScalarWhereWithAggregatesInput[]
    OR?: bn_video_positionsScalarWhereWithAggregatesInput[]
    NOT?: bn_video_positionsScalarWhereWithAggregatesInput | bn_video_positionsScalarWhereWithAggregatesInput[]
    position_id?: IntWithAggregatesFilter<"bn_video_positions"> | number
    position_name?: StringWithAggregatesFilter<"bn_video_positions"> | string
    cat_id?: IntNullableWithAggregatesFilter<"bn_video_positions"> | number | null
    subcat_id?: IntNullableWithAggregatesFilter<"bn_video_positions"> | number | null
    video_ids?: StringNullableWithAggregatesFilter<"bn_video_positions"> | string | null
    total_video?: IntNullableWithAggregatesFilter<"bn_video_positions"> | number | null
    deletable?: IntWithAggregatesFilter<"bn_video_positions"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"bn_video_positions"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"bn_video_positions"> | Date | string | null
  }

  export type bn_videosWhereInput = {
    AND?: bn_videosWhereInput | bn_videosWhereInput[]
    OR?: bn_videosWhereInput[]
    NOT?: bn_videosWhereInput | bn_videosWhereInput[]
    id?: IntFilter<"bn_videos"> | number
    cat_id?: IntNullableFilter<"bn_videos"> | number | null
    type?: IntNullableFilter<"bn_videos"> | number | null
    title?: StringNullableFilter<"bn_videos"> | string | null
    code?: StringNullableFilter<"bn_videos"> | string | null
    img_bg_path?: StringNullableFilter<"bn_videos"> | string | null
    img_sm_path?: StringNullableFilter<"bn_videos"> | string | null
    img_xs_path?: StringNullableFilter<"bn_videos"> | string | null
    link?: StringNullableFilter<"bn_videos"> | string | null
    meta_keywords?: StringNullableFilter<"bn_videos"> | string | null
    meta_description?: StringNullableFilter<"bn_videos"> | string | null
    user_id?: IntNullableFilter<"bn_videos"> | number | null
    target?: IntFilter<"bn_videos"> | number
    is_live?: IntFilter<"bn_videos"> | number
    status?: IntNullableFilter<"bn_videos"> | number | null
    deletable?: IntNullableFilter<"bn_videos"> | number | null
    created_at?: DateTimeNullableFilter<"bn_videos"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_videos"> | Date | string | null
  }

  export type bn_videosOrderByWithRelationInput = {
    id?: SortOrder
    cat_id?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    img_bg_path?: SortOrderInput | SortOrder
    img_sm_path?: SortOrderInput | SortOrder
    img_xs_path?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    meta_keywords?: SortOrderInput | SortOrder
    meta_description?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    target?: SortOrder
    is_live?: SortOrder
    status?: SortOrderInput | SortOrder
    deletable?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type bn_videosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bn_videosWhereInput | bn_videosWhereInput[]
    OR?: bn_videosWhereInput[]
    NOT?: bn_videosWhereInput | bn_videosWhereInput[]
    cat_id?: IntNullableFilter<"bn_videos"> | number | null
    type?: IntNullableFilter<"bn_videos"> | number | null
    title?: StringNullableFilter<"bn_videos"> | string | null
    code?: StringNullableFilter<"bn_videos"> | string | null
    img_bg_path?: StringNullableFilter<"bn_videos"> | string | null
    img_sm_path?: StringNullableFilter<"bn_videos"> | string | null
    img_xs_path?: StringNullableFilter<"bn_videos"> | string | null
    link?: StringNullableFilter<"bn_videos"> | string | null
    meta_keywords?: StringNullableFilter<"bn_videos"> | string | null
    meta_description?: StringNullableFilter<"bn_videos"> | string | null
    user_id?: IntNullableFilter<"bn_videos"> | number | null
    target?: IntFilter<"bn_videos"> | number
    is_live?: IntFilter<"bn_videos"> | number
    status?: IntNullableFilter<"bn_videos"> | number | null
    deletable?: IntNullableFilter<"bn_videos"> | number | null
    created_at?: DateTimeNullableFilter<"bn_videos"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bn_videos"> | Date | string | null
  }, "id">

  export type bn_videosOrderByWithAggregationInput = {
    id?: SortOrder
    cat_id?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    img_bg_path?: SortOrderInput | SortOrder
    img_sm_path?: SortOrderInput | SortOrder
    img_xs_path?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    meta_keywords?: SortOrderInput | SortOrder
    meta_description?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    target?: SortOrder
    is_live?: SortOrder
    status?: SortOrderInput | SortOrder
    deletable?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: bn_videosCountOrderByAggregateInput
    _avg?: bn_videosAvgOrderByAggregateInput
    _max?: bn_videosMaxOrderByAggregateInput
    _min?: bn_videosMinOrderByAggregateInput
    _sum?: bn_videosSumOrderByAggregateInput
  }

  export type bn_videosScalarWhereWithAggregatesInput = {
    AND?: bn_videosScalarWhereWithAggregatesInput | bn_videosScalarWhereWithAggregatesInput[]
    OR?: bn_videosScalarWhereWithAggregatesInput[]
    NOT?: bn_videosScalarWhereWithAggregatesInput | bn_videosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bn_videos"> | number
    cat_id?: IntNullableWithAggregatesFilter<"bn_videos"> | number | null
    type?: IntNullableWithAggregatesFilter<"bn_videos"> | number | null
    title?: StringNullableWithAggregatesFilter<"bn_videos"> | string | null
    code?: StringNullableWithAggregatesFilter<"bn_videos"> | string | null
    img_bg_path?: StringNullableWithAggregatesFilter<"bn_videos"> | string | null
    img_sm_path?: StringNullableWithAggregatesFilter<"bn_videos"> | string | null
    img_xs_path?: StringNullableWithAggregatesFilter<"bn_videos"> | string | null
    link?: StringNullableWithAggregatesFilter<"bn_videos"> | string | null
    meta_keywords?: StringNullableWithAggregatesFilter<"bn_videos"> | string | null
    meta_description?: StringNullableWithAggregatesFilter<"bn_videos"> | string | null
    user_id?: IntNullableWithAggregatesFilter<"bn_videos"> | number | null
    target?: IntWithAggregatesFilter<"bn_videos"> | number
    is_live?: IntWithAggregatesFilter<"bn_videos"> | number
    status?: IntNullableWithAggregatesFilter<"bn_videos"> | number | null
    deletable?: IntNullableWithAggregatesFilter<"bn_videos"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"bn_videos"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"bn_videos"> | Date | string | null
  }

  export type countriesWhereInput = {
    AND?: countriesWhereInput | countriesWhereInput[]
    OR?: countriesWhereInput[]
    NOT?: countriesWhereInput | countriesWhereInput[]
    country_id?: IntFilter<"countries"> | number
    country_name?: StringFilter<"countries"> | string
    country_name_bn?: StringFilter<"countries"> | string
    country_slug?: StringFilter<"countries"> | string
    deletable?: IntFilter<"countries"> | number
    created_at?: DateTimeNullableFilter<"countries"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"countries"> | Date | string | null
  }

  export type countriesOrderByWithRelationInput = {
    country_id?: SortOrder
    country_name?: SortOrder
    country_name_bn?: SortOrder
    country_slug?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type countriesWhereUniqueInput = Prisma.AtLeast<{
    country_id?: number
    AND?: countriesWhereInput | countriesWhereInput[]
    OR?: countriesWhereInput[]
    NOT?: countriesWhereInput | countriesWhereInput[]
    country_name?: StringFilter<"countries"> | string
    country_name_bn?: StringFilter<"countries"> | string
    country_slug?: StringFilter<"countries"> | string
    deletable?: IntFilter<"countries"> | number
    created_at?: DateTimeNullableFilter<"countries"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"countries"> | Date | string | null
  }, "country_id">

  export type countriesOrderByWithAggregationInput = {
    country_id?: SortOrder
    country_name?: SortOrder
    country_name_bn?: SortOrder
    country_slug?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: countriesCountOrderByAggregateInput
    _avg?: countriesAvgOrderByAggregateInput
    _max?: countriesMaxOrderByAggregateInput
    _min?: countriesMinOrderByAggregateInput
    _sum?: countriesSumOrderByAggregateInput
  }

  export type countriesScalarWhereWithAggregatesInput = {
    AND?: countriesScalarWhereWithAggregatesInput | countriesScalarWhereWithAggregatesInput[]
    OR?: countriesScalarWhereWithAggregatesInput[]
    NOT?: countriesScalarWhereWithAggregatesInput | countriesScalarWhereWithAggregatesInput[]
    country_id?: IntWithAggregatesFilter<"countries"> | number
    country_name?: StringWithAggregatesFilter<"countries"> | string
    country_name_bn?: StringWithAggregatesFilter<"countries"> | string
    country_slug?: StringWithAggregatesFilter<"countries"> | string
    deletable?: IntWithAggregatesFilter<"countries"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"countries"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"countries"> | Date | string | null
  }

  export type districtsWhereInput = {
    AND?: districtsWhereInput | districtsWhereInput[]
    OR?: districtsWhereInput[]
    NOT?: districtsWhereInput | districtsWhereInput[]
    district_id?: IntFilter<"districts"> | number
    division_id?: IntFilter<"districts"> | number
    district_name?: StringFilter<"districts"> | string
    district_name_bn?: StringFilter<"districts"> | string
    district_slug?: StringFilter<"districts"> | string
    district_title?: StringNullableFilter<"districts"> | string | null
    meta_description?: StringNullableFilter<"districts"> | string | null
    deletable?: IntFilter<"districts"> | number
    created_at?: DateTimeNullableFilter<"districts"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"districts"> | Date | string | null
  }

  export type districtsOrderByWithRelationInput = {
    district_id?: SortOrder
    division_id?: SortOrder
    district_name?: SortOrder
    district_name_bn?: SortOrder
    district_slug?: SortOrder
    district_title?: SortOrderInput | SortOrder
    meta_description?: SortOrderInput | SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type districtsWhereUniqueInput = Prisma.AtLeast<{
    district_id?: number
    AND?: districtsWhereInput | districtsWhereInput[]
    OR?: districtsWhereInput[]
    NOT?: districtsWhereInput | districtsWhereInput[]
    division_id?: IntFilter<"districts"> | number
    district_name?: StringFilter<"districts"> | string
    district_name_bn?: StringFilter<"districts"> | string
    district_slug?: StringFilter<"districts"> | string
    district_title?: StringNullableFilter<"districts"> | string | null
    meta_description?: StringNullableFilter<"districts"> | string | null
    deletable?: IntFilter<"districts"> | number
    created_at?: DateTimeNullableFilter<"districts"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"districts"> | Date | string | null
  }, "district_id">

  export type districtsOrderByWithAggregationInput = {
    district_id?: SortOrder
    division_id?: SortOrder
    district_name?: SortOrder
    district_name_bn?: SortOrder
    district_slug?: SortOrder
    district_title?: SortOrderInput | SortOrder
    meta_description?: SortOrderInput | SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: districtsCountOrderByAggregateInput
    _avg?: districtsAvgOrderByAggregateInput
    _max?: districtsMaxOrderByAggregateInput
    _min?: districtsMinOrderByAggregateInput
    _sum?: districtsSumOrderByAggregateInput
  }

  export type districtsScalarWhereWithAggregatesInput = {
    AND?: districtsScalarWhereWithAggregatesInput | districtsScalarWhereWithAggregatesInput[]
    OR?: districtsScalarWhereWithAggregatesInput[]
    NOT?: districtsScalarWhereWithAggregatesInput | districtsScalarWhereWithAggregatesInput[]
    district_id?: IntWithAggregatesFilter<"districts"> | number
    division_id?: IntWithAggregatesFilter<"districts"> | number
    district_name?: StringWithAggregatesFilter<"districts"> | string
    district_name_bn?: StringWithAggregatesFilter<"districts"> | string
    district_slug?: StringWithAggregatesFilter<"districts"> | string
    district_title?: StringNullableWithAggregatesFilter<"districts"> | string | null
    meta_description?: StringNullableWithAggregatesFilter<"districts"> | string | null
    deletable?: IntWithAggregatesFilter<"districts"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"districts"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"districts"> | Date | string | null
  }

  export type divisionsWhereInput = {
    AND?: divisionsWhereInput | divisionsWhereInput[]
    OR?: divisionsWhereInput[]
    NOT?: divisionsWhereInput | divisionsWhereInput[]
    division_id?: IntFilter<"divisions"> | number
    division_name?: StringFilter<"divisions"> | string
    division_name_bn?: StringFilter<"divisions"> | string
    division_slug?: StringFilter<"divisions"> | string
    deletable?: IntFilter<"divisions"> | number
    created_at?: DateTimeNullableFilter<"divisions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"divisions"> | Date | string | null
  }

  export type divisionsOrderByWithRelationInput = {
    division_id?: SortOrder
    division_name?: SortOrder
    division_name_bn?: SortOrder
    division_slug?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type divisionsWhereUniqueInput = Prisma.AtLeast<{
    division_id?: number
    AND?: divisionsWhereInput | divisionsWhereInput[]
    OR?: divisionsWhereInput[]
    NOT?: divisionsWhereInput | divisionsWhereInput[]
    division_name?: StringFilter<"divisions"> | string
    division_name_bn?: StringFilter<"divisions"> | string
    division_slug?: StringFilter<"divisions"> | string
    deletable?: IntFilter<"divisions"> | number
    created_at?: DateTimeNullableFilter<"divisions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"divisions"> | Date | string | null
  }, "division_id">

  export type divisionsOrderByWithAggregationInput = {
    division_id?: SortOrder
    division_name?: SortOrder
    division_name_bn?: SortOrder
    division_slug?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: divisionsCountOrderByAggregateInput
    _avg?: divisionsAvgOrderByAggregateInput
    _max?: divisionsMaxOrderByAggregateInput
    _min?: divisionsMinOrderByAggregateInput
    _sum?: divisionsSumOrderByAggregateInput
  }

  export type divisionsScalarWhereWithAggregatesInput = {
    AND?: divisionsScalarWhereWithAggregatesInput | divisionsScalarWhereWithAggregatesInput[]
    OR?: divisionsScalarWhereWithAggregatesInput[]
    NOT?: divisionsScalarWhereWithAggregatesInput | divisionsScalarWhereWithAggregatesInput[]
    division_id?: IntWithAggregatesFilter<"divisions"> | number
    division_name?: StringWithAggregatesFilter<"divisions"> | string
    division_name_bn?: StringWithAggregatesFilter<"divisions"> | string
    division_slug?: StringWithAggregatesFilter<"divisions"> | string
    deletable?: IntWithAggregatesFilter<"divisions"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"divisions"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"divisions"> | Date | string | null
  }

  export type electionsWhereInput = {
    AND?: electionsWhereInput | electionsWhereInput[]
    OR?: electionsWhereInput[]
    NOT?: electionsWhereInput | electionsWhereInput[]
    id?: IntFilter<"elections"> | number
    title?: StringNullableFilter<"elections"> | string | null
    total_center?: IntNullableFilter<"elections"> | number | null
    casted_center?: IntNullableFilter<"elections"> | number | null
    party_one_name?: StringNullableFilter<"elections"> | string | null
    party_two_name?: StringNullableFilter<"elections"> | string | null
    party_three_name?: StringNullableFilter<"elections"> | string | null
    party_four_name?: StringNullableFilter<"elections"> | string | null
    party_one_logo?: StringNullableFilter<"elections"> | string | null
    party_two_logo?: StringNullableFilter<"elections"> | string | null
    party_three_logo?: StringNullableFilter<"elections"> | string | null
    party_four_logo?: StringNullableFilter<"elections"> | string | null
    party_one_votes?: IntNullableFilter<"elections"> | number | null
    party_two_votes?: IntNullableFilter<"elections"> | number | null
    party_three_votes?: IntNullableFilter<"elections"> | number | null
    party_four_votes?: IntNullableFilter<"elections"> | number | null
    status?: IntNullableFilter<"elections"> | number | null
    deletable?: IntNullableFilter<"elections"> | number | null
    created_at?: DateTimeNullableFilter<"elections"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"elections"> | Date | string | null
  }

  export type electionsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    total_center?: SortOrderInput | SortOrder
    casted_center?: SortOrderInput | SortOrder
    party_one_name?: SortOrderInput | SortOrder
    party_two_name?: SortOrderInput | SortOrder
    party_three_name?: SortOrderInput | SortOrder
    party_four_name?: SortOrderInput | SortOrder
    party_one_logo?: SortOrderInput | SortOrder
    party_two_logo?: SortOrderInput | SortOrder
    party_three_logo?: SortOrderInput | SortOrder
    party_four_logo?: SortOrderInput | SortOrder
    party_one_votes?: SortOrderInput | SortOrder
    party_two_votes?: SortOrderInput | SortOrder
    party_three_votes?: SortOrderInput | SortOrder
    party_four_votes?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    deletable?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type electionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: electionsWhereInput | electionsWhereInput[]
    OR?: electionsWhereInput[]
    NOT?: electionsWhereInput | electionsWhereInput[]
    title?: StringNullableFilter<"elections"> | string | null
    total_center?: IntNullableFilter<"elections"> | number | null
    casted_center?: IntNullableFilter<"elections"> | number | null
    party_one_name?: StringNullableFilter<"elections"> | string | null
    party_two_name?: StringNullableFilter<"elections"> | string | null
    party_three_name?: StringNullableFilter<"elections"> | string | null
    party_four_name?: StringNullableFilter<"elections"> | string | null
    party_one_logo?: StringNullableFilter<"elections"> | string | null
    party_two_logo?: StringNullableFilter<"elections"> | string | null
    party_three_logo?: StringNullableFilter<"elections"> | string | null
    party_four_logo?: StringNullableFilter<"elections"> | string | null
    party_one_votes?: IntNullableFilter<"elections"> | number | null
    party_two_votes?: IntNullableFilter<"elections"> | number | null
    party_three_votes?: IntNullableFilter<"elections"> | number | null
    party_four_votes?: IntNullableFilter<"elections"> | number | null
    status?: IntNullableFilter<"elections"> | number | null
    deletable?: IntNullableFilter<"elections"> | number | null
    created_at?: DateTimeNullableFilter<"elections"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"elections"> | Date | string | null
  }, "id">

  export type electionsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    total_center?: SortOrderInput | SortOrder
    casted_center?: SortOrderInput | SortOrder
    party_one_name?: SortOrderInput | SortOrder
    party_two_name?: SortOrderInput | SortOrder
    party_three_name?: SortOrderInput | SortOrder
    party_four_name?: SortOrderInput | SortOrder
    party_one_logo?: SortOrderInput | SortOrder
    party_two_logo?: SortOrderInput | SortOrder
    party_three_logo?: SortOrderInput | SortOrder
    party_four_logo?: SortOrderInput | SortOrder
    party_one_votes?: SortOrderInput | SortOrder
    party_two_votes?: SortOrderInput | SortOrder
    party_three_votes?: SortOrderInput | SortOrder
    party_four_votes?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    deletable?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: electionsCountOrderByAggregateInput
    _avg?: electionsAvgOrderByAggregateInput
    _max?: electionsMaxOrderByAggregateInput
    _min?: electionsMinOrderByAggregateInput
    _sum?: electionsSumOrderByAggregateInput
  }

  export type electionsScalarWhereWithAggregatesInput = {
    AND?: electionsScalarWhereWithAggregatesInput | electionsScalarWhereWithAggregatesInput[]
    OR?: electionsScalarWhereWithAggregatesInput[]
    NOT?: electionsScalarWhereWithAggregatesInput | electionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"elections"> | number
    title?: StringNullableWithAggregatesFilter<"elections"> | string | null
    total_center?: IntNullableWithAggregatesFilter<"elections"> | number | null
    casted_center?: IntNullableWithAggregatesFilter<"elections"> | number | null
    party_one_name?: StringNullableWithAggregatesFilter<"elections"> | string | null
    party_two_name?: StringNullableWithAggregatesFilter<"elections"> | string | null
    party_three_name?: StringNullableWithAggregatesFilter<"elections"> | string | null
    party_four_name?: StringNullableWithAggregatesFilter<"elections"> | string | null
    party_one_logo?: StringNullableWithAggregatesFilter<"elections"> | string | null
    party_two_logo?: StringNullableWithAggregatesFilter<"elections"> | string | null
    party_three_logo?: StringNullableWithAggregatesFilter<"elections"> | string | null
    party_four_logo?: StringNullableWithAggregatesFilter<"elections"> | string | null
    party_one_votes?: IntNullableWithAggregatesFilter<"elections"> | number | null
    party_two_votes?: IntNullableWithAggregatesFilter<"elections"> | number | null
    party_three_votes?: IntNullableWithAggregatesFilter<"elections"> | number | null
    party_four_votes?: IntNullableWithAggregatesFilter<"elections"> | number | null
    status?: IntNullableWithAggregatesFilter<"elections"> | number | null
    deletable?: IntNullableWithAggregatesFilter<"elections"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"elections"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"elections"> | Date | string | null
  }

  export type epaper_pagesWhereInput = {
    AND?: epaper_pagesWhereInput | epaper_pagesWhereInput[]
    OR?: epaper_pagesWhereInput[]
    NOT?: epaper_pagesWhereInput | epaper_pagesWhereInput[]
    id?: IntFilter<"epaper_pages"> | number
    epaper_id?: IntFilter<"epaper_pages"> | number
    img_path?: StringNullableFilter<"epaper_pages"> | string | null
    img_thumb_path?: StringNullableFilter<"epaper_pages"> | string | null
    img_large_path?: StringNullableFilter<"epaper_pages"> | string | null
    page_no?: IntFilter<"epaper_pages"> | number
    user_id?: IntFilter<"epaper_pages"> | number
    deletable?: IntNullableFilter<"epaper_pages"> | number | null
    created_at?: DateTimeNullableFilter<"epaper_pages"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"epaper_pages"> | Date | string | null
  }

  export type epaper_pagesOrderByWithRelationInput = {
    id?: SortOrder
    epaper_id?: SortOrder
    img_path?: SortOrderInput | SortOrder
    img_thumb_path?: SortOrderInput | SortOrder
    img_large_path?: SortOrderInput | SortOrder
    page_no?: SortOrder
    user_id?: SortOrder
    deletable?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type epaper_pagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: epaper_pagesWhereInput | epaper_pagesWhereInput[]
    OR?: epaper_pagesWhereInput[]
    NOT?: epaper_pagesWhereInput | epaper_pagesWhereInput[]
    epaper_id?: IntFilter<"epaper_pages"> | number
    img_path?: StringNullableFilter<"epaper_pages"> | string | null
    img_thumb_path?: StringNullableFilter<"epaper_pages"> | string | null
    img_large_path?: StringNullableFilter<"epaper_pages"> | string | null
    page_no?: IntFilter<"epaper_pages"> | number
    user_id?: IntFilter<"epaper_pages"> | number
    deletable?: IntNullableFilter<"epaper_pages"> | number | null
    created_at?: DateTimeNullableFilter<"epaper_pages"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"epaper_pages"> | Date | string | null
  }, "id">

  export type epaper_pagesOrderByWithAggregationInput = {
    id?: SortOrder
    epaper_id?: SortOrder
    img_path?: SortOrderInput | SortOrder
    img_thumb_path?: SortOrderInput | SortOrder
    img_large_path?: SortOrderInput | SortOrder
    page_no?: SortOrder
    user_id?: SortOrder
    deletable?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: epaper_pagesCountOrderByAggregateInput
    _avg?: epaper_pagesAvgOrderByAggregateInput
    _max?: epaper_pagesMaxOrderByAggregateInput
    _min?: epaper_pagesMinOrderByAggregateInput
    _sum?: epaper_pagesSumOrderByAggregateInput
  }

  export type epaper_pagesScalarWhereWithAggregatesInput = {
    AND?: epaper_pagesScalarWhereWithAggregatesInput | epaper_pagesScalarWhereWithAggregatesInput[]
    OR?: epaper_pagesScalarWhereWithAggregatesInput[]
    NOT?: epaper_pagesScalarWhereWithAggregatesInput | epaper_pagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"epaper_pages"> | number
    epaper_id?: IntWithAggregatesFilter<"epaper_pages"> | number
    img_path?: StringNullableWithAggregatesFilter<"epaper_pages"> | string | null
    img_thumb_path?: StringNullableWithAggregatesFilter<"epaper_pages"> | string | null
    img_large_path?: StringNullableWithAggregatesFilter<"epaper_pages"> | string | null
    page_no?: IntWithAggregatesFilter<"epaper_pages"> | number
    user_id?: IntWithAggregatesFilter<"epaper_pages"> | number
    deletable?: IntNullableWithAggregatesFilter<"epaper_pages"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"epaper_pages"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"epaper_pages"> | Date | string | null
  }

  export type epapersWhereInput = {
    AND?: epapersWhereInput | epapersWhereInput[]
    OR?: epapersWhereInput[]
    NOT?: epapersWhereInput | epapersWhereInput[]
    id?: IntFilter<"epapers"> | number
    paper_date?: DateTimeNullableFilter<"epapers"> | Date | string | null
    total_page?: IntNullableFilter<"epapers"> | number | null
    meta_keywords?: StringNullableFilter<"epapers"> | string | null
    meta_description?: StringNullableFilter<"epapers"> | string | null
    og_img_path?: StringNullableFilter<"epapers"> | string | null
    user_id?: IntNullableFilter<"epapers"> | number | null
    status?: IntNullableFilter<"epapers"> | number | null
    deletable?: IntNullableFilter<"epapers"> | number | null
    created_at?: DateTimeNullableFilter<"epapers"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"epapers"> | Date | string | null
  }

  export type epapersOrderByWithRelationInput = {
    id?: SortOrder
    paper_date?: SortOrderInput | SortOrder
    total_page?: SortOrderInput | SortOrder
    meta_keywords?: SortOrderInput | SortOrder
    meta_description?: SortOrderInput | SortOrder
    og_img_path?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    deletable?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type epapersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: epapersWhereInput | epapersWhereInput[]
    OR?: epapersWhereInput[]
    NOT?: epapersWhereInput | epapersWhereInput[]
    paper_date?: DateTimeNullableFilter<"epapers"> | Date | string | null
    total_page?: IntNullableFilter<"epapers"> | number | null
    meta_keywords?: StringNullableFilter<"epapers"> | string | null
    meta_description?: StringNullableFilter<"epapers"> | string | null
    og_img_path?: StringNullableFilter<"epapers"> | string | null
    user_id?: IntNullableFilter<"epapers"> | number | null
    status?: IntNullableFilter<"epapers"> | number | null
    deletable?: IntNullableFilter<"epapers"> | number | null
    created_at?: DateTimeNullableFilter<"epapers"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"epapers"> | Date | string | null
  }, "id">

  export type epapersOrderByWithAggregationInput = {
    id?: SortOrder
    paper_date?: SortOrderInput | SortOrder
    total_page?: SortOrderInput | SortOrder
    meta_keywords?: SortOrderInput | SortOrder
    meta_description?: SortOrderInput | SortOrder
    og_img_path?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    deletable?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: epapersCountOrderByAggregateInput
    _avg?: epapersAvgOrderByAggregateInput
    _max?: epapersMaxOrderByAggregateInput
    _min?: epapersMinOrderByAggregateInput
    _sum?: epapersSumOrderByAggregateInput
  }

  export type epapersScalarWhereWithAggregatesInput = {
    AND?: epapersScalarWhereWithAggregatesInput | epapersScalarWhereWithAggregatesInput[]
    OR?: epapersScalarWhereWithAggregatesInput[]
    NOT?: epapersScalarWhereWithAggregatesInput | epapersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"epapers"> | number
    paper_date?: DateTimeNullableWithAggregatesFilter<"epapers"> | Date | string | null
    total_page?: IntNullableWithAggregatesFilter<"epapers"> | number | null
    meta_keywords?: StringNullableWithAggregatesFilter<"epapers"> | string | null
    meta_description?: StringNullableWithAggregatesFilter<"epapers"> | string | null
    og_img_path?: StringNullableWithAggregatesFilter<"epapers"> | string | null
    user_id?: IntNullableWithAggregatesFilter<"epapers"> | number | null
    status?: IntNullableWithAggregatesFilter<"epapers"> | number | null
    deletable?: IntNullableWithAggregatesFilter<"epapers"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"epapers"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"epapers"> | Date | string | null
  }

  export type magazine_pagesWhereInput = {
    AND?: magazine_pagesWhereInput | magazine_pagesWhereInput[]
    OR?: magazine_pagesWhereInput[]
    NOT?: magazine_pagesWhereInput | magazine_pagesWhereInput[]
    id?: IntFilter<"magazine_pages"> | number
    magazine_id?: IntFilter<"magazine_pages"> | number
    img_path?: StringNullableFilter<"magazine_pages"> | string | null
    img_thumb_path?: StringNullableFilter<"magazine_pages"> | string | null
    img_large_path?: StringNullableFilter<"magazine_pages"> | string | null
    counter?: IntFilter<"magazine_pages"> | number
    user_id?: IntFilter<"magazine_pages"> | number
    deletable?: IntNullableFilter<"magazine_pages"> | number | null
    created_at?: DateTimeNullableFilter<"magazine_pages"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"magazine_pages"> | Date | string | null
  }

  export type magazine_pagesOrderByWithRelationInput = {
    id?: SortOrder
    magazine_id?: SortOrder
    img_path?: SortOrderInput | SortOrder
    img_thumb_path?: SortOrderInput | SortOrder
    img_large_path?: SortOrderInput | SortOrder
    counter?: SortOrder
    user_id?: SortOrder
    deletable?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type magazine_pagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: magazine_pagesWhereInput | magazine_pagesWhereInput[]
    OR?: magazine_pagesWhereInput[]
    NOT?: magazine_pagesWhereInput | magazine_pagesWhereInput[]
    magazine_id?: IntFilter<"magazine_pages"> | number
    img_path?: StringNullableFilter<"magazine_pages"> | string | null
    img_thumb_path?: StringNullableFilter<"magazine_pages"> | string | null
    img_large_path?: StringNullableFilter<"magazine_pages"> | string | null
    counter?: IntFilter<"magazine_pages"> | number
    user_id?: IntFilter<"magazine_pages"> | number
    deletable?: IntNullableFilter<"magazine_pages"> | number | null
    created_at?: DateTimeNullableFilter<"magazine_pages"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"magazine_pages"> | Date | string | null
  }, "id">

  export type magazine_pagesOrderByWithAggregationInput = {
    id?: SortOrder
    magazine_id?: SortOrder
    img_path?: SortOrderInput | SortOrder
    img_thumb_path?: SortOrderInput | SortOrder
    img_large_path?: SortOrderInput | SortOrder
    counter?: SortOrder
    user_id?: SortOrder
    deletable?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: magazine_pagesCountOrderByAggregateInput
    _avg?: magazine_pagesAvgOrderByAggregateInput
    _max?: magazine_pagesMaxOrderByAggregateInput
    _min?: magazine_pagesMinOrderByAggregateInput
    _sum?: magazine_pagesSumOrderByAggregateInput
  }

  export type magazine_pagesScalarWhereWithAggregatesInput = {
    AND?: magazine_pagesScalarWhereWithAggregatesInput | magazine_pagesScalarWhereWithAggregatesInput[]
    OR?: magazine_pagesScalarWhereWithAggregatesInput[]
    NOT?: magazine_pagesScalarWhereWithAggregatesInput | magazine_pagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"magazine_pages"> | number
    magazine_id?: IntWithAggregatesFilter<"magazine_pages"> | number
    img_path?: StringNullableWithAggregatesFilter<"magazine_pages"> | string | null
    img_thumb_path?: StringNullableWithAggregatesFilter<"magazine_pages"> | string | null
    img_large_path?: StringNullableWithAggregatesFilter<"magazine_pages"> | string | null
    counter?: IntWithAggregatesFilter<"magazine_pages"> | number
    user_id?: IntWithAggregatesFilter<"magazine_pages"> | number
    deletable?: IntNullableWithAggregatesFilter<"magazine_pages"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"magazine_pages"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"magazine_pages"> | Date | string | null
  }

  export type magazinesWhereInput = {
    AND?: magazinesWhereInput | magazinesWhereInput[]
    OR?: magazinesWhereInput[]
    NOT?: magazinesWhereInput | magazinesWhereInput[]
    id?: IntFilter<"magazines"> | number
    name?: StringNullableFilter<"magazines"> | string | null
    total_page?: IntNullableFilter<"magazines"> | number | null
    meta_keywords?: StringNullableFilter<"magazines"> | string | null
    meta_description?: StringFilter<"magazines"> | string
    og_img_path?: StringNullableFilter<"magazines"> | string | null
    user_id?: IntNullableFilter<"magazines"> | number | null
    status?: IntNullableFilter<"magazines"> | number | null
    deletable?: IntNullableFilter<"magazines"> | number | null
    created_at?: DateTimeNullableFilter<"magazines"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"magazines"> | Date | string | null
  }

  export type magazinesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    total_page?: SortOrderInput | SortOrder
    meta_keywords?: SortOrderInput | SortOrder
    meta_description?: SortOrder
    og_img_path?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    deletable?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type magazinesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: magazinesWhereInput | magazinesWhereInput[]
    OR?: magazinesWhereInput[]
    NOT?: magazinesWhereInput | magazinesWhereInput[]
    name?: StringNullableFilter<"magazines"> | string | null
    total_page?: IntNullableFilter<"magazines"> | number | null
    meta_keywords?: StringNullableFilter<"magazines"> | string | null
    meta_description?: StringFilter<"magazines"> | string
    og_img_path?: StringNullableFilter<"magazines"> | string | null
    user_id?: IntNullableFilter<"magazines"> | number | null
    status?: IntNullableFilter<"magazines"> | number | null
    deletable?: IntNullableFilter<"magazines"> | number | null
    created_at?: DateTimeNullableFilter<"magazines"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"magazines"> | Date | string | null
  }, "id">

  export type magazinesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    total_page?: SortOrderInput | SortOrder
    meta_keywords?: SortOrderInput | SortOrder
    meta_description?: SortOrder
    og_img_path?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    deletable?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: magazinesCountOrderByAggregateInput
    _avg?: magazinesAvgOrderByAggregateInput
    _max?: magazinesMaxOrderByAggregateInput
    _min?: magazinesMinOrderByAggregateInput
    _sum?: magazinesSumOrderByAggregateInput
  }

  export type magazinesScalarWhereWithAggregatesInput = {
    AND?: magazinesScalarWhereWithAggregatesInput | magazinesScalarWhereWithAggregatesInput[]
    OR?: magazinesScalarWhereWithAggregatesInput[]
    NOT?: magazinesScalarWhereWithAggregatesInput | magazinesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"magazines"> | number
    name?: StringNullableWithAggregatesFilter<"magazines"> | string | null
    total_page?: IntNullableWithAggregatesFilter<"magazines"> | number | null
    meta_keywords?: StringNullableWithAggregatesFilter<"magazines"> | string | null
    meta_description?: StringWithAggregatesFilter<"magazines"> | string
    og_img_path?: StringNullableWithAggregatesFilter<"magazines"> | string | null
    user_id?: IntNullableWithAggregatesFilter<"magazines"> | number | null
    status?: IntNullableWithAggregatesFilter<"magazines"> | number | null
    deletable?: IntNullableWithAggregatesFilter<"magazines"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"magazines"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"magazines"> | Date | string | null
  }

  export type manual_documentsWhereInput = {
    AND?: manual_documentsWhereInput | manual_documentsWhereInput[]
    OR?: manual_documentsWhereInput[]
    NOT?: manual_documentsWhereInput | manual_documentsWhereInput[]
    doc_id?: IntFilter<"manual_documents"> | number
    doc_path?: StringFilter<"manual_documents"> | string
    deletable?: IntFilter<"manual_documents"> | number
    created_at?: DateTimeNullableFilter<"manual_documents"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"manual_documents"> | Date | string | null
  }

  export type manual_documentsOrderByWithRelationInput = {
    doc_id?: SortOrder
    doc_path?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type manual_documentsWhereUniqueInput = Prisma.AtLeast<{
    doc_id?: number
    AND?: manual_documentsWhereInput | manual_documentsWhereInput[]
    OR?: manual_documentsWhereInput[]
    NOT?: manual_documentsWhereInput | manual_documentsWhereInput[]
    doc_path?: StringFilter<"manual_documents"> | string
    deletable?: IntFilter<"manual_documents"> | number
    created_at?: DateTimeNullableFilter<"manual_documents"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"manual_documents"> | Date | string | null
  }, "doc_id">

  export type manual_documentsOrderByWithAggregationInput = {
    doc_id?: SortOrder
    doc_path?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: manual_documentsCountOrderByAggregateInput
    _avg?: manual_documentsAvgOrderByAggregateInput
    _max?: manual_documentsMaxOrderByAggregateInput
    _min?: manual_documentsMinOrderByAggregateInput
    _sum?: manual_documentsSumOrderByAggregateInput
  }

  export type manual_documentsScalarWhereWithAggregatesInput = {
    AND?: manual_documentsScalarWhereWithAggregatesInput | manual_documentsScalarWhereWithAggregatesInput[]
    OR?: manual_documentsScalarWhereWithAggregatesInput[]
    NOT?: manual_documentsScalarWhereWithAggregatesInput | manual_documentsScalarWhereWithAggregatesInput[]
    doc_id?: IntWithAggregatesFilter<"manual_documents"> | number
    doc_path?: StringWithAggregatesFilter<"manual_documents"> | string
    deletable?: IntWithAggregatesFilter<"manual_documents"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"manual_documents"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"manual_documents"> | Date | string | null
  }

  export type manual_photosWhereInput = {
    AND?: manual_photosWhereInput | manual_photosWhereInput[]
    OR?: manual_photosWhereInput[]
    NOT?: manual_photosWhereInput | manual_photosWhereInput[]
    photo_id?: IntFilter<"manual_photos"> | number
    img_path?: StringFilter<"manual_photos"> | string
    deletable?: IntFilter<"manual_photos"> | number
    created_at?: DateTimeNullableFilter<"manual_photos"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"manual_photos"> | Date | string | null
  }

  export type manual_photosOrderByWithRelationInput = {
    photo_id?: SortOrder
    img_path?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type manual_photosWhereUniqueInput = Prisma.AtLeast<{
    photo_id?: number
    AND?: manual_photosWhereInput | manual_photosWhereInput[]
    OR?: manual_photosWhereInput[]
    NOT?: manual_photosWhereInput | manual_photosWhereInput[]
    img_path?: StringFilter<"manual_photos"> | string
    deletable?: IntFilter<"manual_photos"> | number
    created_at?: DateTimeNullableFilter<"manual_photos"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"manual_photos"> | Date | string | null
  }, "photo_id">

  export type manual_photosOrderByWithAggregationInput = {
    photo_id?: SortOrder
    img_path?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: manual_photosCountOrderByAggregateInput
    _avg?: manual_photosAvgOrderByAggregateInput
    _max?: manual_photosMaxOrderByAggregateInput
    _min?: manual_photosMinOrderByAggregateInput
    _sum?: manual_photosSumOrderByAggregateInput
  }

  export type manual_photosScalarWhereWithAggregatesInput = {
    AND?: manual_photosScalarWhereWithAggregatesInput | manual_photosScalarWhereWithAggregatesInput[]
    OR?: manual_photosScalarWhereWithAggregatesInput[]
    NOT?: manual_photosScalarWhereWithAggregatesInput | manual_photosScalarWhereWithAggregatesInput[]
    photo_id?: IntWithAggregatesFilter<"manual_photos"> | number
    img_path?: StringWithAggregatesFilter<"manual_photos"> | string
    deletable?: IntWithAggregatesFilter<"manual_photos"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"manual_photos"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"manual_photos"> | Date | string | null
  }

  export type mis_usersWhereInput = {
    AND?: mis_usersWhereInput | mis_usersWhereInput[]
    OR?: mis_usersWhereInput[]
    NOT?: mis_usersWhereInput | mis_usersWhereInput[]
    user_id?: IntFilter<"mis_users"> | number
    user_type?: IntFilter<"mis_users"> | number
    admin_id?: IntNullableFilter<"mis_users"> | number | null
    dept_type?: IntFilter<"mis_users"> | number
    user_name?: StringFilter<"mis_users"> | string
    user_name_bn?: StringNullableFilter<"mis_users"> | string | null
    user_slug?: StringFilter<"mis_users"> | string
    user_initial?: StringFilter<"mis_users"> | string
    user_initial_bn?: StringNullableFilter<"mis_users"> | string | null
    user_bio?: StringNullableFilter<"mis_users"> | string | null
    user_bio_bn?: StringNullableFilter<"mis_users"> | string | null
    img_path?: StringNullableFilter<"mis_users"> | string | null
    deletable?: IntFilter<"mis_users"> | number
    created_at?: DateTimeNullableFilter<"mis_users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"mis_users"> | Date | string | null
  }

  export type mis_usersOrderByWithRelationInput = {
    user_id?: SortOrder
    user_type?: SortOrder
    admin_id?: SortOrderInput | SortOrder
    dept_type?: SortOrder
    user_name?: SortOrder
    user_name_bn?: SortOrderInput | SortOrder
    user_slug?: SortOrder
    user_initial?: SortOrder
    user_initial_bn?: SortOrderInput | SortOrder
    user_bio?: SortOrderInput | SortOrder
    user_bio_bn?: SortOrderInput | SortOrder
    img_path?: SortOrderInput | SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type mis_usersWhereUniqueInput = Prisma.AtLeast<{
    user_id?: number
    AND?: mis_usersWhereInput | mis_usersWhereInput[]
    OR?: mis_usersWhereInput[]
    NOT?: mis_usersWhereInput | mis_usersWhereInput[]
    user_type?: IntFilter<"mis_users"> | number
    admin_id?: IntNullableFilter<"mis_users"> | number | null
    dept_type?: IntFilter<"mis_users"> | number
    user_name?: StringFilter<"mis_users"> | string
    user_name_bn?: StringNullableFilter<"mis_users"> | string | null
    user_slug?: StringFilter<"mis_users"> | string
    user_initial?: StringFilter<"mis_users"> | string
    user_initial_bn?: StringNullableFilter<"mis_users"> | string | null
    user_bio?: StringNullableFilter<"mis_users"> | string | null
    user_bio_bn?: StringNullableFilter<"mis_users"> | string | null
    img_path?: StringNullableFilter<"mis_users"> | string | null
    deletable?: IntFilter<"mis_users"> | number
    created_at?: DateTimeNullableFilter<"mis_users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"mis_users"> | Date | string | null
  }, "user_id">

  export type mis_usersOrderByWithAggregationInput = {
    user_id?: SortOrder
    user_type?: SortOrder
    admin_id?: SortOrderInput | SortOrder
    dept_type?: SortOrder
    user_name?: SortOrder
    user_name_bn?: SortOrderInput | SortOrder
    user_slug?: SortOrder
    user_initial?: SortOrder
    user_initial_bn?: SortOrderInput | SortOrder
    user_bio?: SortOrderInput | SortOrder
    user_bio_bn?: SortOrderInput | SortOrder
    img_path?: SortOrderInput | SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: mis_usersCountOrderByAggregateInput
    _avg?: mis_usersAvgOrderByAggregateInput
    _max?: mis_usersMaxOrderByAggregateInput
    _min?: mis_usersMinOrderByAggregateInput
    _sum?: mis_usersSumOrderByAggregateInput
  }

  export type mis_usersScalarWhereWithAggregatesInput = {
    AND?: mis_usersScalarWhereWithAggregatesInput | mis_usersScalarWhereWithAggregatesInput[]
    OR?: mis_usersScalarWhereWithAggregatesInput[]
    NOT?: mis_usersScalarWhereWithAggregatesInput | mis_usersScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"mis_users"> | number
    user_type?: IntWithAggregatesFilter<"mis_users"> | number
    admin_id?: IntNullableWithAggregatesFilter<"mis_users"> | number | null
    dept_type?: IntWithAggregatesFilter<"mis_users"> | number
    user_name?: StringWithAggregatesFilter<"mis_users"> | string
    user_name_bn?: StringNullableWithAggregatesFilter<"mis_users"> | string | null
    user_slug?: StringWithAggregatesFilter<"mis_users"> | string
    user_initial?: StringWithAggregatesFilter<"mis_users"> | string
    user_initial_bn?: StringNullableWithAggregatesFilter<"mis_users"> | string | null
    user_bio?: StringNullableWithAggregatesFilter<"mis_users"> | string | null
    user_bio_bn?: StringNullableWithAggregatesFilter<"mis_users"> | string | null
    img_path?: StringNullableWithAggregatesFilter<"mis_users"> | string | null
    deletable?: IntWithAggregatesFilter<"mis_users"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"mis_users"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"mis_users"> | Date | string | null
  }

  export type monthly_foldersWhereInput = {
    AND?: monthly_foldersWhereInput | monthly_foldersWhereInput[]
    OR?: monthly_foldersWhereInput[]
    NOT?: monthly_foldersWhereInput | monthly_foldersWhereInput[]
    folder_id?: IntFilter<"monthly_folders"> | number
    folder_name?: StringFilter<"monthly_folders"> | string
    deletable?: IntFilter<"monthly_folders"> | number
    created_at?: DateTimeNullableFilter<"monthly_folders"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"monthly_folders"> | Date | string | null
  }

  export type monthly_foldersOrderByWithRelationInput = {
    folder_id?: SortOrder
    folder_name?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type monthly_foldersWhereUniqueInput = Prisma.AtLeast<{
    folder_id?: number
    AND?: monthly_foldersWhereInput | monthly_foldersWhereInput[]
    OR?: monthly_foldersWhereInput[]
    NOT?: monthly_foldersWhereInput | monthly_foldersWhereInput[]
    folder_name?: StringFilter<"monthly_folders"> | string
    deletable?: IntFilter<"monthly_folders"> | number
    created_at?: DateTimeNullableFilter<"monthly_folders"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"monthly_folders"> | Date | string | null
  }, "folder_id">

  export type monthly_foldersOrderByWithAggregationInput = {
    folder_id?: SortOrder
    folder_name?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: monthly_foldersCountOrderByAggregateInput
    _avg?: monthly_foldersAvgOrderByAggregateInput
    _max?: monthly_foldersMaxOrderByAggregateInput
    _min?: monthly_foldersMinOrderByAggregateInput
    _sum?: monthly_foldersSumOrderByAggregateInput
  }

  export type monthly_foldersScalarWhereWithAggregatesInput = {
    AND?: monthly_foldersScalarWhereWithAggregatesInput | monthly_foldersScalarWhereWithAggregatesInput[]
    OR?: monthly_foldersScalarWhereWithAggregatesInput[]
    NOT?: monthly_foldersScalarWhereWithAggregatesInput | monthly_foldersScalarWhereWithAggregatesInput[]
    folder_id?: IntWithAggregatesFilter<"monthly_folders"> | number
    folder_name?: StringWithAggregatesFilter<"monthly_folders"> | string
    deletable?: IntWithAggregatesFilter<"monthly_folders"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"monthly_folders"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"monthly_folders"> | Date | string | null
  }

  export type p_album_positionsWhereInput = {
    AND?: p_album_positionsWhereInput | p_album_positionsWhereInput[]
    OR?: p_album_positionsWhereInput[]
    NOT?: p_album_positionsWhereInput | p_album_positionsWhereInput[]
    position_id?: IntFilter<"p_album_positions"> | number
    position_name?: StringFilter<"p_album_positions"> | string
    position_slug?: StringFilter<"p_album_positions"> | string
    cat_id?: IntNullableFilter<"p_album_positions"> | number | null
    special_cat_id?: IntNullableFilter<"p_album_positions"> | number | null
    subcat_id?: IntNullableFilter<"p_album_positions"> | number | null
    content_ids?: StringNullableFilter<"p_album_positions"> | string | null
    total_content?: IntNullableFilter<"p_album_positions"> | number | null
    status?: IntFilter<"p_album_positions"> | number
    deletable?: IntFilter<"p_album_positions"> | number
    created_at?: DateTimeNullableFilter<"p_album_positions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"p_album_positions"> | Date | string | null
  }

  export type p_album_positionsOrderByWithRelationInput = {
    position_id?: SortOrder
    position_name?: SortOrder
    position_slug?: SortOrder
    cat_id?: SortOrderInput | SortOrder
    special_cat_id?: SortOrderInput | SortOrder
    subcat_id?: SortOrderInput | SortOrder
    content_ids?: SortOrderInput | SortOrder
    total_content?: SortOrderInput | SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type p_album_positionsWhereUniqueInput = Prisma.AtLeast<{
    position_id?: number
    AND?: p_album_positionsWhereInput | p_album_positionsWhereInput[]
    OR?: p_album_positionsWhereInput[]
    NOT?: p_album_positionsWhereInput | p_album_positionsWhereInput[]
    position_name?: StringFilter<"p_album_positions"> | string
    position_slug?: StringFilter<"p_album_positions"> | string
    cat_id?: IntNullableFilter<"p_album_positions"> | number | null
    special_cat_id?: IntNullableFilter<"p_album_positions"> | number | null
    subcat_id?: IntNullableFilter<"p_album_positions"> | number | null
    content_ids?: StringNullableFilter<"p_album_positions"> | string | null
    total_content?: IntNullableFilter<"p_album_positions"> | number | null
    status?: IntFilter<"p_album_positions"> | number
    deletable?: IntFilter<"p_album_positions"> | number
    created_at?: DateTimeNullableFilter<"p_album_positions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"p_album_positions"> | Date | string | null
  }, "position_id">

  export type p_album_positionsOrderByWithAggregationInput = {
    position_id?: SortOrder
    position_name?: SortOrder
    position_slug?: SortOrder
    cat_id?: SortOrderInput | SortOrder
    special_cat_id?: SortOrderInput | SortOrder
    subcat_id?: SortOrderInput | SortOrder
    content_ids?: SortOrderInput | SortOrder
    total_content?: SortOrderInput | SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: p_album_positionsCountOrderByAggregateInput
    _avg?: p_album_positionsAvgOrderByAggregateInput
    _max?: p_album_positionsMaxOrderByAggregateInput
    _min?: p_album_positionsMinOrderByAggregateInput
    _sum?: p_album_positionsSumOrderByAggregateInput
  }

  export type p_album_positionsScalarWhereWithAggregatesInput = {
    AND?: p_album_positionsScalarWhereWithAggregatesInput | p_album_positionsScalarWhereWithAggregatesInput[]
    OR?: p_album_positionsScalarWhereWithAggregatesInput[]
    NOT?: p_album_positionsScalarWhereWithAggregatesInput | p_album_positionsScalarWhereWithAggregatesInput[]
    position_id?: IntWithAggregatesFilter<"p_album_positions"> | number
    position_name?: StringWithAggregatesFilter<"p_album_positions"> | string
    position_slug?: StringWithAggregatesFilter<"p_album_positions"> | string
    cat_id?: IntNullableWithAggregatesFilter<"p_album_positions"> | number | null
    special_cat_id?: IntNullableWithAggregatesFilter<"p_album_positions"> | number | null
    subcat_id?: IntNullableWithAggregatesFilter<"p_album_positions"> | number | null
    content_ids?: StringNullableWithAggregatesFilter<"p_album_positions"> | string | null
    total_content?: IntNullableWithAggregatesFilter<"p_album_positions"> | number | null
    status?: IntWithAggregatesFilter<"p_album_positions"> | number
    deletable?: IntWithAggregatesFilter<"p_album_positions"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"p_album_positions"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"p_album_positions"> | Date | string | null
  }

  export type p_albumsWhereInput = {
    AND?: p_albumsWhereInput | p_albumsWhereInput[]
    OR?: p_albumsWhereInput[]
    NOT?: p_albumsWhereInput | p_albumsWhereInput[]
    album_id?: IntFilter<"p_albums"> | number
    cat_id?: IntFilter<"p_albums"> | number
    subcat_id?: IntNullableFilter<"p_albums"> | number | null
    album_name?: StringFilter<"p_albums"> | string
    short_description?: StringNullableFilter<"p_albums"> | string | null
    album_details?: StringNullableFilter<"p_albums"> | string | null
    photographer_name?: StringNullableFilter<"p_albums"> | string | null
    tag?: StringNullableFilter<"p_albums"> | string | null
    status?: IntFilter<"p_albums"> | number
    total_hit?: IntFilter<"p_albums"> | number
    deletable?: IntFilter<"p_albums"> | number
    user_id?: IntFilter<"p_albums"> | number
    created_at?: DateTimeNullableFilter<"p_albums"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"p_albums"> | Date | string | null
  }

  export type p_albumsOrderByWithRelationInput = {
    album_id?: SortOrder
    cat_id?: SortOrder
    subcat_id?: SortOrderInput | SortOrder
    album_name?: SortOrder
    short_description?: SortOrderInput | SortOrder
    album_details?: SortOrderInput | SortOrder
    photographer_name?: SortOrderInput | SortOrder
    tag?: SortOrderInput | SortOrder
    status?: SortOrder
    total_hit?: SortOrder
    deletable?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type p_albumsWhereUniqueInput = Prisma.AtLeast<{
    album_id?: number
    AND?: p_albumsWhereInput | p_albumsWhereInput[]
    OR?: p_albumsWhereInput[]
    NOT?: p_albumsWhereInput | p_albumsWhereInput[]
    cat_id?: IntFilter<"p_albums"> | number
    subcat_id?: IntNullableFilter<"p_albums"> | number | null
    album_name?: StringFilter<"p_albums"> | string
    short_description?: StringNullableFilter<"p_albums"> | string | null
    album_details?: StringNullableFilter<"p_albums"> | string | null
    photographer_name?: StringNullableFilter<"p_albums"> | string | null
    tag?: StringNullableFilter<"p_albums"> | string | null
    status?: IntFilter<"p_albums"> | number
    total_hit?: IntFilter<"p_albums"> | number
    deletable?: IntFilter<"p_albums"> | number
    user_id?: IntFilter<"p_albums"> | number
    created_at?: DateTimeNullableFilter<"p_albums"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"p_albums"> | Date | string | null
  }, "album_id">

  export type p_albumsOrderByWithAggregationInput = {
    album_id?: SortOrder
    cat_id?: SortOrder
    subcat_id?: SortOrderInput | SortOrder
    album_name?: SortOrder
    short_description?: SortOrderInput | SortOrder
    album_details?: SortOrderInput | SortOrder
    photographer_name?: SortOrderInput | SortOrder
    tag?: SortOrderInput | SortOrder
    status?: SortOrder
    total_hit?: SortOrder
    deletable?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: p_albumsCountOrderByAggregateInput
    _avg?: p_albumsAvgOrderByAggregateInput
    _max?: p_albumsMaxOrderByAggregateInput
    _min?: p_albumsMinOrderByAggregateInput
    _sum?: p_albumsSumOrderByAggregateInput
  }

  export type p_albumsScalarWhereWithAggregatesInput = {
    AND?: p_albumsScalarWhereWithAggregatesInput | p_albumsScalarWhereWithAggregatesInput[]
    OR?: p_albumsScalarWhereWithAggregatesInput[]
    NOT?: p_albumsScalarWhereWithAggregatesInput | p_albumsScalarWhereWithAggregatesInput[]
    album_id?: IntWithAggregatesFilter<"p_albums"> | number
    cat_id?: IntWithAggregatesFilter<"p_albums"> | number
    subcat_id?: IntNullableWithAggregatesFilter<"p_albums"> | number | null
    album_name?: StringWithAggregatesFilter<"p_albums"> | string
    short_description?: StringNullableWithAggregatesFilter<"p_albums"> | string | null
    album_details?: StringNullableWithAggregatesFilter<"p_albums"> | string | null
    photographer_name?: StringNullableWithAggregatesFilter<"p_albums"> | string | null
    tag?: StringNullableWithAggregatesFilter<"p_albums"> | string | null
    status?: IntWithAggregatesFilter<"p_albums"> | number
    total_hit?: IntWithAggregatesFilter<"p_albums"> | number
    deletable?: IntWithAggregatesFilter<"p_albums"> | number
    user_id?: IntWithAggregatesFilter<"p_albums"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"p_albums"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"p_albums"> | Date | string | null
  }

  export type p_categoriesWhereInput = {
    AND?: p_categoriesWhereInput | p_categoriesWhereInput[]
    OR?: p_categoriesWhereInput[]
    NOT?: p_categoriesWhereInput | p_categoriesWhereInput[]
    cat_id?: IntFilter<"p_categories"> | number
    cat_name?: StringFilter<"p_categories"> | string
    cat_name_bn?: StringFilter<"p_categories"> | string
    cat_slug?: StringFilter<"p_categories"> | string
    cat_meta_keyword?: StringNullableFilter<"p_categories"> | string | null
    cat_meta_description?: StringNullableFilter<"p_categories"> | string | null
    cat_position?: IntFilter<"p_categories"> | number
    top_menu?: IntFilter<"p_categories"> | number
    footer_menu?: IntFilter<"p_categories"> | number
    status?: IntFilter<"p_categories"> | number
    deletable?: IntFilter<"p_categories"> | number
    created_at?: DateTimeNullableFilter<"p_categories"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"p_categories"> | Date | string | null
  }

  export type p_categoriesOrderByWithRelationInput = {
    cat_id?: SortOrder
    cat_name?: SortOrder
    cat_name_bn?: SortOrder
    cat_slug?: SortOrder
    cat_meta_keyword?: SortOrderInput | SortOrder
    cat_meta_description?: SortOrderInput | SortOrder
    cat_position?: SortOrder
    top_menu?: SortOrder
    footer_menu?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type p_categoriesWhereUniqueInput = Prisma.AtLeast<{
    cat_id?: number
    AND?: p_categoriesWhereInput | p_categoriesWhereInput[]
    OR?: p_categoriesWhereInput[]
    NOT?: p_categoriesWhereInput | p_categoriesWhereInput[]
    cat_name?: StringFilter<"p_categories"> | string
    cat_name_bn?: StringFilter<"p_categories"> | string
    cat_slug?: StringFilter<"p_categories"> | string
    cat_meta_keyword?: StringNullableFilter<"p_categories"> | string | null
    cat_meta_description?: StringNullableFilter<"p_categories"> | string | null
    cat_position?: IntFilter<"p_categories"> | number
    top_menu?: IntFilter<"p_categories"> | number
    footer_menu?: IntFilter<"p_categories"> | number
    status?: IntFilter<"p_categories"> | number
    deletable?: IntFilter<"p_categories"> | number
    created_at?: DateTimeNullableFilter<"p_categories"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"p_categories"> | Date | string | null
  }, "cat_id">

  export type p_categoriesOrderByWithAggregationInput = {
    cat_id?: SortOrder
    cat_name?: SortOrder
    cat_name_bn?: SortOrder
    cat_slug?: SortOrder
    cat_meta_keyword?: SortOrderInput | SortOrder
    cat_meta_description?: SortOrderInput | SortOrder
    cat_position?: SortOrder
    top_menu?: SortOrder
    footer_menu?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: p_categoriesCountOrderByAggregateInput
    _avg?: p_categoriesAvgOrderByAggregateInput
    _max?: p_categoriesMaxOrderByAggregateInput
    _min?: p_categoriesMinOrderByAggregateInput
    _sum?: p_categoriesSumOrderByAggregateInput
  }

  export type p_categoriesScalarWhereWithAggregatesInput = {
    AND?: p_categoriesScalarWhereWithAggregatesInput | p_categoriesScalarWhereWithAggregatesInput[]
    OR?: p_categoriesScalarWhereWithAggregatesInput[]
    NOT?: p_categoriesScalarWhereWithAggregatesInput | p_categoriesScalarWhereWithAggregatesInput[]
    cat_id?: IntWithAggregatesFilter<"p_categories"> | number
    cat_name?: StringWithAggregatesFilter<"p_categories"> | string
    cat_name_bn?: StringWithAggregatesFilter<"p_categories"> | string
    cat_slug?: StringWithAggregatesFilter<"p_categories"> | string
    cat_meta_keyword?: StringNullableWithAggregatesFilter<"p_categories"> | string | null
    cat_meta_description?: StringNullableWithAggregatesFilter<"p_categories"> | string | null
    cat_position?: IntWithAggregatesFilter<"p_categories"> | number
    top_menu?: IntWithAggregatesFilter<"p_categories"> | number
    footer_menu?: IntWithAggregatesFilter<"p_categories"> | number
    status?: IntWithAggregatesFilter<"p_categories"> | number
    deletable?: IntWithAggregatesFilter<"p_categories"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"p_categories"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"p_categories"> | Date | string | null
  }

  export type p_galleriesWhereInput = {
    AND?: p_galleriesWhereInput | p_galleriesWhereInput[]
    OR?: p_galleriesWhereInput[]
    NOT?: p_galleriesWhereInput | p_galleriesWhereInput[]
    id?: IntFilter<"p_galleries"> | number
    album_id?: IntFilter<"p_galleries"> | number
    photo?: StringFilter<"p_galleries"> | string
    photo_capture?: StringNullableFilter<"p_galleries"> | string | null
    feature_image?: StringNullableFilter<"p_galleries"> | string | null
    created_at?: DateTimeNullableFilter<"p_galleries"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"p_galleries"> | Date | string | null
  }

  export type p_galleriesOrderByWithRelationInput = {
    id?: SortOrder
    album_id?: SortOrder
    photo?: SortOrder
    photo_capture?: SortOrderInput | SortOrder
    feature_image?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type p_galleriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: p_galleriesWhereInput | p_galleriesWhereInput[]
    OR?: p_galleriesWhereInput[]
    NOT?: p_galleriesWhereInput | p_galleriesWhereInput[]
    album_id?: IntFilter<"p_galleries"> | number
    photo?: StringFilter<"p_galleries"> | string
    photo_capture?: StringNullableFilter<"p_galleries"> | string | null
    feature_image?: StringNullableFilter<"p_galleries"> | string | null
    created_at?: DateTimeNullableFilter<"p_galleries"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"p_galleries"> | Date | string | null
  }, "id">

  export type p_galleriesOrderByWithAggregationInput = {
    id?: SortOrder
    album_id?: SortOrder
    photo?: SortOrder
    photo_capture?: SortOrderInput | SortOrder
    feature_image?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: p_galleriesCountOrderByAggregateInput
    _avg?: p_galleriesAvgOrderByAggregateInput
    _max?: p_galleriesMaxOrderByAggregateInput
    _min?: p_galleriesMinOrderByAggregateInput
    _sum?: p_galleriesSumOrderByAggregateInput
  }

  export type p_galleriesScalarWhereWithAggregatesInput = {
    AND?: p_galleriesScalarWhereWithAggregatesInput | p_galleriesScalarWhereWithAggregatesInput[]
    OR?: p_galleriesScalarWhereWithAggregatesInput[]
    NOT?: p_galleriesScalarWhereWithAggregatesInput | p_galleriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"p_galleries"> | number
    album_id?: IntWithAggregatesFilter<"p_galleries"> | number
    photo?: StringWithAggregatesFilter<"p_galleries"> | string
    photo_capture?: StringNullableWithAggregatesFilter<"p_galleries"> | string | null
    feature_image?: StringNullableWithAggregatesFilter<"p_galleries"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"p_galleries"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"p_galleries"> | Date | string | null
  }

  export type p_subcategoriesWhereInput = {
    AND?: p_subcategoriesWhereInput | p_subcategoriesWhereInput[]
    OR?: p_subcategoriesWhereInput[]
    NOT?: p_subcategoriesWhereInput | p_subcategoriesWhereInput[]
    subcat_id?: IntFilter<"p_subcategories"> | number
    cat_id?: IntFilter<"p_subcategories"> | number
    subcat_name?: StringFilter<"p_subcategories"> | string
    subcat_name_bn?: StringFilter<"p_subcategories"> | string
    subcat_slug?: StringFilter<"p_subcategories"> | string
    subcat_meta_keyword?: StringNullableFilter<"p_subcategories"> | string | null
    subcat_meta_description?: StringNullableFilter<"p_subcategories"> | string | null
    subcat_position?: IntFilter<"p_subcategories"> | number
    status?: IntFilter<"p_subcategories"> | number
    deletable?: IntFilter<"p_subcategories"> | number
    created_at?: DateTimeNullableFilter<"p_subcategories"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"p_subcategories"> | Date | string | null
  }

  export type p_subcategoriesOrderByWithRelationInput = {
    subcat_id?: SortOrder
    cat_id?: SortOrder
    subcat_name?: SortOrder
    subcat_name_bn?: SortOrder
    subcat_slug?: SortOrder
    subcat_meta_keyword?: SortOrderInput | SortOrder
    subcat_meta_description?: SortOrderInput | SortOrder
    subcat_position?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type p_subcategoriesWhereUniqueInput = Prisma.AtLeast<{
    subcat_id?: number
    AND?: p_subcategoriesWhereInput | p_subcategoriesWhereInput[]
    OR?: p_subcategoriesWhereInput[]
    NOT?: p_subcategoriesWhereInput | p_subcategoriesWhereInput[]
    cat_id?: IntFilter<"p_subcategories"> | number
    subcat_name?: StringFilter<"p_subcategories"> | string
    subcat_name_bn?: StringFilter<"p_subcategories"> | string
    subcat_slug?: StringFilter<"p_subcategories"> | string
    subcat_meta_keyword?: StringNullableFilter<"p_subcategories"> | string | null
    subcat_meta_description?: StringNullableFilter<"p_subcategories"> | string | null
    subcat_position?: IntFilter<"p_subcategories"> | number
    status?: IntFilter<"p_subcategories"> | number
    deletable?: IntFilter<"p_subcategories"> | number
    created_at?: DateTimeNullableFilter<"p_subcategories"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"p_subcategories"> | Date | string | null
  }, "subcat_id">

  export type p_subcategoriesOrderByWithAggregationInput = {
    subcat_id?: SortOrder
    cat_id?: SortOrder
    subcat_name?: SortOrder
    subcat_name_bn?: SortOrder
    subcat_slug?: SortOrder
    subcat_meta_keyword?: SortOrderInput | SortOrder
    subcat_meta_description?: SortOrderInput | SortOrder
    subcat_position?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: p_subcategoriesCountOrderByAggregateInput
    _avg?: p_subcategoriesAvgOrderByAggregateInput
    _max?: p_subcategoriesMaxOrderByAggregateInput
    _min?: p_subcategoriesMinOrderByAggregateInput
    _sum?: p_subcategoriesSumOrderByAggregateInput
  }

  export type p_subcategoriesScalarWhereWithAggregatesInput = {
    AND?: p_subcategoriesScalarWhereWithAggregatesInput | p_subcategoriesScalarWhereWithAggregatesInput[]
    OR?: p_subcategoriesScalarWhereWithAggregatesInput[]
    NOT?: p_subcategoriesScalarWhereWithAggregatesInput | p_subcategoriesScalarWhereWithAggregatesInput[]
    subcat_id?: IntWithAggregatesFilter<"p_subcategories"> | number
    cat_id?: IntWithAggregatesFilter<"p_subcategories"> | number
    subcat_name?: StringWithAggregatesFilter<"p_subcategories"> | string
    subcat_name_bn?: StringWithAggregatesFilter<"p_subcategories"> | string
    subcat_slug?: StringWithAggregatesFilter<"p_subcategories"> | string
    subcat_meta_keyword?: StringNullableWithAggregatesFilter<"p_subcategories"> | string | null
    subcat_meta_description?: StringNullableWithAggregatesFilter<"p_subcategories"> | string | null
    subcat_position?: IntWithAggregatesFilter<"p_subcategories"> | number
    status?: IntWithAggregatesFilter<"p_subcategories"> | number
    deletable?: IntWithAggregatesFilter<"p_subcategories"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"p_subcategories"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"p_subcategories"> | Date | string | null
  }

  export type site_settingsWhereInput = {
    AND?: site_settingsWhereInput | site_settingsWhereInput[]
    OR?: site_settingsWhereInput[]
    NOT?: site_settingsWhereInput | site_settingsWhereInput[]
    id?: IntFilter<"site_settings"> | number
    site_name?: StringNullableFilter<"site_settings"> | string | null
    favicon?: StringNullableFilter<"site_settings"> | string | null
    logo?: StringNullableFilter<"site_settings"> | string | null
    logo_header?: IntFilter<"site_settings"> | number
    logo_footer?: IntFilter<"site_settings"> | number
    title?: StringNullableFilter<"site_settings"> | string | null
    meta_keywords?: StringNullableFilter<"site_settings"> | string | null
    meta_description?: StringNullableFilter<"site_settings"> | string | null
    og_image?: StringNullableFilter<"site_settings"> | string | null
    post_ogimage?: StringNullableFilter<"site_settings"> | string | null
    social_links?: StringNullableFilter<"site_settings"> | string | null
    facebook?: StringNullableFilter<"site_settings"> | string | null
    twitter?: StringNullableFilter<"site_settings"> | string | null
    google_plus?: StringNullableFilter<"site_settings"> | string | null
    youtube?: StringNullableFilter<"site_settings"> | string | null
    instagram?: StringNullableFilter<"site_settings"> | string | null
    linkedin?: StringNullableFilter<"site_settings"> | string | null
    editor_meta?: StringNullableFilter<"site_settings"> | string | null
    address?: StringNullableFilter<"site_settings"> | string | null
    copyright?: StringNullableFilter<"site_settings"> | string | null
    show_special?: IntFilter<"site_settings"> | number
    special_title?: StringNullableFilter<"site_settings"> | string | null
    special_link?: StringNullableFilter<"site_settings"> | string | null
    show_live_tv?: IntFilter<"site_settings"> | number
    show_video_live_tv?: IntFilter<"site_settings"> | number
    created_at?: DateTimeNullableFilter<"site_settings"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"site_settings"> | Date | string | null
  }

  export type site_settingsOrderByWithRelationInput = {
    id?: SortOrder
    site_name?: SortOrderInput | SortOrder
    favicon?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    logo_header?: SortOrder
    logo_footer?: SortOrder
    title?: SortOrderInput | SortOrder
    meta_keywords?: SortOrderInput | SortOrder
    meta_description?: SortOrderInput | SortOrder
    og_image?: SortOrderInput | SortOrder
    post_ogimage?: SortOrderInput | SortOrder
    social_links?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    google_plus?: SortOrderInput | SortOrder
    youtube?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    editor_meta?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    copyright?: SortOrderInput | SortOrder
    show_special?: SortOrder
    special_title?: SortOrderInput | SortOrder
    special_link?: SortOrderInput | SortOrder
    show_live_tv?: SortOrder
    show_video_live_tv?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type site_settingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: site_settingsWhereInput | site_settingsWhereInput[]
    OR?: site_settingsWhereInput[]
    NOT?: site_settingsWhereInput | site_settingsWhereInput[]
    site_name?: StringNullableFilter<"site_settings"> | string | null
    favicon?: StringNullableFilter<"site_settings"> | string | null
    logo?: StringNullableFilter<"site_settings"> | string | null
    logo_header?: IntFilter<"site_settings"> | number
    logo_footer?: IntFilter<"site_settings"> | number
    title?: StringNullableFilter<"site_settings"> | string | null
    meta_keywords?: StringNullableFilter<"site_settings"> | string | null
    meta_description?: StringNullableFilter<"site_settings"> | string | null
    og_image?: StringNullableFilter<"site_settings"> | string | null
    post_ogimage?: StringNullableFilter<"site_settings"> | string | null
    social_links?: StringNullableFilter<"site_settings"> | string | null
    facebook?: StringNullableFilter<"site_settings"> | string | null
    twitter?: StringNullableFilter<"site_settings"> | string | null
    google_plus?: StringNullableFilter<"site_settings"> | string | null
    youtube?: StringNullableFilter<"site_settings"> | string | null
    instagram?: StringNullableFilter<"site_settings"> | string | null
    linkedin?: StringNullableFilter<"site_settings"> | string | null
    editor_meta?: StringNullableFilter<"site_settings"> | string | null
    address?: StringNullableFilter<"site_settings"> | string | null
    copyright?: StringNullableFilter<"site_settings"> | string | null
    show_special?: IntFilter<"site_settings"> | number
    special_title?: StringNullableFilter<"site_settings"> | string | null
    special_link?: StringNullableFilter<"site_settings"> | string | null
    show_live_tv?: IntFilter<"site_settings"> | number
    show_video_live_tv?: IntFilter<"site_settings"> | number
    created_at?: DateTimeNullableFilter<"site_settings"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"site_settings"> | Date | string | null
  }, "id">

  export type site_settingsOrderByWithAggregationInput = {
    id?: SortOrder
    site_name?: SortOrderInput | SortOrder
    favicon?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    logo_header?: SortOrder
    logo_footer?: SortOrder
    title?: SortOrderInput | SortOrder
    meta_keywords?: SortOrderInput | SortOrder
    meta_description?: SortOrderInput | SortOrder
    og_image?: SortOrderInput | SortOrder
    post_ogimage?: SortOrderInput | SortOrder
    social_links?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    google_plus?: SortOrderInput | SortOrder
    youtube?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    editor_meta?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    copyright?: SortOrderInput | SortOrder
    show_special?: SortOrder
    special_title?: SortOrderInput | SortOrder
    special_link?: SortOrderInput | SortOrder
    show_live_tv?: SortOrder
    show_video_live_tv?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: site_settingsCountOrderByAggregateInput
    _avg?: site_settingsAvgOrderByAggregateInput
    _max?: site_settingsMaxOrderByAggregateInput
    _min?: site_settingsMinOrderByAggregateInput
    _sum?: site_settingsSumOrderByAggregateInput
  }

  export type site_settingsScalarWhereWithAggregatesInput = {
    AND?: site_settingsScalarWhereWithAggregatesInput | site_settingsScalarWhereWithAggregatesInput[]
    OR?: site_settingsScalarWhereWithAggregatesInput[]
    NOT?: site_settingsScalarWhereWithAggregatesInput | site_settingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"site_settings"> | number
    site_name?: StringNullableWithAggregatesFilter<"site_settings"> | string | null
    favicon?: StringNullableWithAggregatesFilter<"site_settings"> | string | null
    logo?: StringNullableWithAggregatesFilter<"site_settings"> | string | null
    logo_header?: IntWithAggregatesFilter<"site_settings"> | number
    logo_footer?: IntWithAggregatesFilter<"site_settings"> | number
    title?: StringNullableWithAggregatesFilter<"site_settings"> | string | null
    meta_keywords?: StringNullableWithAggregatesFilter<"site_settings"> | string | null
    meta_description?: StringNullableWithAggregatesFilter<"site_settings"> | string | null
    og_image?: StringNullableWithAggregatesFilter<"site_settings"> | string | null
    post_ogimage?: StringNullableWithAggregatesFilter<"site_settings"> | string | null
    social_links?: StringNullableWithAggregatesFilter<"site_settings"> | string | null
    facebook?: StringNullableWithAggregatesFilter<"site_settings"> | string | null
    twitter?: StringNullableWithAggregatesFilter<"site_settings"> | string | null
    google_plus?: StringNullableWithAggregatesFilter<"site_settings"> | string | null
    youtube?: StringNullableWithAggregatesFilter<"site_settings"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"site_settings"> | string | null
    linkedin?: StringNullableWithAggregatesFilter<"site_settings"> | string | null
    editor_meta?: StringNullableWithAggregatesFilter<"site_settings"> | string | null
    address?: StringNullableWithAggregatesFilter<"site_settings"> | string | null
    copyright?: StringNullableWithAggregatesFilter<"site_settings"> | string | null
    show_special?: IntWithAggregatesFilter<"site_settings"> | number
    special_title?: StringNullableWithAggregatesFilter<"site_settings"> | string | null
    special_link?: StringNullableWithAggregatesFilter<"site_settings"> | string | null
    show_live_tv?: IntWithAggregatesFilter<"site_settings"> | number
    show_video_live_tv?: IntWithAggregatesFilter<"site_settings"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"site_settings"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"site_settings"> | Date | string | null
  }

  export type surveysWhereInput = {
    AND?: surveysWhereInput | surveysWhereInput[]
    OR?: surveysWhereInput[]
    NOT?: surveysWhereInput | surveysWhereInput[]
    survey_id?: IntFilter<"surveys"> | number
    title?: StringFilter<"surveys"> | string
    from_date?: DateTimeNullableFilter<"surveys"> | Date | string | null
    to_date?: DateTimeFilter<"surveys"> | Date | string
    ha?: IntFilter<"surveys"> | number
    na?: IntFilter<"surveys"> | number
    no_comment?: IntFilter<"surveys"> | number
    status?: IntFilter<"surveys"> | number
    deletable?: IntFilter<"surveys"> | number
    created_at?: DateTimeNullableFilter<"surveys"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"surveys"> | Date | string | null
  }

  export type surveysOrderByWithRelationInput = {
    survey_id?: SortOrder
    title?: SortOrder
    from_date?: SortOrderInput | SortOrder
    to_date?: SortOrder
    ha?: SortOrder
    na?: SortOrder
    no_comment?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type surveysWhereUniqueInput = Prisma.AtLeast<{
    survey_id?: number
    AND?: surveysWhereInput | surveysWhereInput[]
    OR?: surveysWhereInput[]
    NOT?: surveysWhereInput | surveysWhereInput[]
    title?: StringFilter<"surveys"> | string
    from_date?: DateTimeNullableFilter<"surveys"> | Date | string | null
    to_date?: DateTimeFilter<"surveys"> | Date | string
    ha?: IntFilter<"surveys"> | number
    na?: IntFilter<"surveys"> | number
    no_comment?: IntFilter<"surveys"> | number
    status?: IntFilter<"surveys"> | number
    deletable?: IntFilter<"surveys"> | number
    created_at?: DateTimeNullableFilter<"surveys"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"surveys"> | Date | string | null
  }, "survey_id">

  export type surveysOrderByWithAggregationInput = {
    survey_id?: SortOrder
    title?: SortOrder
    from_date?: SortOrderInput | SortOrder
    to_date?: SortOrder
    ha?: SortOrder
    na?: SortOrder
    no_comment?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: surveysCountOrderByAggregateInput
    _avg?: surveysAvgOrderByAggregateInput
    _max?: surveysMaxOrderByAggregateInput
    _min?: surveysMinOrderByAggregateInput
    _sum?: surveysSumOrderByAggregateInput
  }

  export type surveysScalarWhereWithAggregatesInput = {
    AND?: surveysScalarWhereWithAggregatesInput | surveysScalarWhereWithAggregatesInput[]
    OR?: surveysScalarWhereWithAggregatesInput[]
    NOT?: surveysScalarWhereWithAggregatesInput | surveysScalarWhereWithAggregatesInput[]
    survey_id?: IntWithAggregatesFilter<"surveys"> | number
    title?: StringWithAggregatesFilter<"surveys"> | string
    from_date?: DateTimeNullableWithAggregatesFilter<"surveys"> | Date | string | null
    to_date?: DateTimeWithAggregatesFilter<"surveys"> | Date | string
    ha?: IntWithAggregatesFilter<"surveys"> | number
    na?: IntWithAggregatesFilter<"surveys"> | number
    no_comment?: IntWithAggregatesFilter<"surveys"> | number
    status?: IntWithAggregatesFilter<"surveys"> | number
    deletable?: IntWithAggregatesFilter<"surveys"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"surveys"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"surveys"> | Date | string | null
  }

  export type upozillasWhereInput = {
    AND?: upozillasWhereInput | upozillasWhereInput[]
    OR?: upozillasWhereInput[]
    NOT?: upozillasWhereInput | upozillasWhereInput[]
    upozilla_id?: IntFilter<"upozillas"> | number
    district_id?: IntFilter<"upozillas"> | number
    division_id?: IntFilter<"upozillas"> | number
    upozilla_name?: StringFilter<"upozillas"> | string
    upozilla_name_bn?: StringFilter<"upozillas"> | string
    upozilla_title?: StringNullableFilter<"upozillas"> | string | null
    upozilla_slug?: StringFilter<"upozillas"> | string
    meta_description?: StringNullableFilter<"upozillas"> | string | null
    deletable?: IntFilter<"upozillas"> | number
    created_at?: DateTimeNullableFilter<"upozillas"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"upozillas"> | Date | string | null
  }

  export type upozillasOrderByWithRelationInput = {
    upozilla_id?: SortOrder
    district_id?: SortOrder
    division_id?: SortOrder
    upozilla_name?: SortOrder
    upozilla_name_bn?: SortOrder
    upozilla_title?: SortOrderInput | SortOrder
    upozilla_slug?: SortOrder
    meta_description?: SortOrderInput | SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type upozillasWhereUniqueInput = Prisma.AtLeast<{
    upozilla_id?: number
    AND?: upozillasWhereInput | upozillasWhereInput[]
    OR?: upozillasWhereInput[]
    NOT?: upozillasWhereInput | upozillasWhereInput[]
    district_id?: IntFilter<"upozillas"> | number
    division_id?: IntFilter<"upozillas"> | number
    upozilla_name?: StringFilter<"upozillas"> | string
    upozilla_name_bn?: StringFilter<"upozillas"> | string
    upozilla_title?: StringNullableFilter<"upozillas"> | string | null
    upozilla_slug?: StringFilter<"upozillas"> | string
    meta_description?: StringNullableFilter<"upozillas"> | string | null
    deletable?: IntFilter<"upozillas"> | number
    created_at?: DateTimeNullableFilter<"upozillas"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"upozillas"> | Date | string | null
  }, "upozilla_id">

  export type upozillasOrderByWithAggregationInput = {
    upozilla_id?: SortOrder
    district_id?: SortOrder
    division_id?: SortOrder
    upozilla_name?: SortOrder
    upozilla_name_bn?: SortOrder
    upozilla_title?: SortOrderInput | SortOrder
    upozilla_slug?: SortOrder
    meta_description?: SortOrderInput | SortOrder
    deletable?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: upozillasCountOrderByAggregateInput
    _avg?: upozillasAvgOrderByAggregateInput
    _max?: upozillasMaxOrderByAggregateInput
    _min?: upozillasMinOrderByAggregateInput
    _sum?: upozillasSumOrderByAggregateInput
  }

  export type upozillasScalarWhereWithAggregatesInput = {
    AND?: upozillasScalarWhereWithAggregatesInput | upozillasScalarWhereWithAggregatesInput[]
    OR?: upozillasScalarWhereWithAggregatesInput[]
    NOT?: upozillasScalarWhereWithAggregatesInput | upozillasScalarWhereWithAggregatesInput[]
    upozilla_id?: IntWithAggregatesFilter<"upozillas"> | number
    district_id?: IntWithAggregatesFilter<"upozillas"> | number
    division_id?: IntWithAggregatesFilter<"upozillas"> | number
    upozilla_name?: StringWithAggregatesFilter<"upozillas"> | string
    upozilla_name_bn?: StringWithAggregatesFilter<"upozillas"> | string
    upozilla_title?: StringNullableWithAggregatesFilter<"upozillas"> | string | null
    upozilla_slug?: StringWithAggregatesFilter<"upozillas"> | string
    meta_description?: StringNullableWithAggregatesFilter<"upozillas"> | string | null
    deletable?: IntWithAggregatesFilter<"upozillas"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"upozillas"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"upozillas"> | Date | string | null
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: IntFilter<"users"> | number
    name?: StringFilter<"users"> | string
    designation?: StringNullableFilter<"users"> | string | null
    username?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    email_verified_at?: DateTimeNullableFilter<"users"> | Date | string | null
    password?: StringFilter<"users"> | string
    two_factor_secret?: StringNullableFilter<"users"> | string | null
    two_factor_recovery_codes?: StringNullableFilter<"users"> | string | null
    role?: IntFilter<"users"> | number
    bn_cat_ids?: StringNullableFilter<"users"> | string | null
    status?: IntFilter<"users"> | number
    visibility?: IntFilter<"users"> | number
    deletable?: IntFilter<"users"> | number
    remember_token?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    designation?: SortOrderInput | SortOrder
    username?: SortOrder
    email?: SortOrder
    email_verified_at?: SortOrderInput | SortOrder
    password?: SortOrder
    two_factor_secret?: SortOrderInput | SortOrder
    two_factor_recovery_codes?: SortOrderInput | SortOrder
    role?: SortOrder
    bn_cat_ids?: SortOrderInput | SortOrder
    status?: SortOrder
    visibility?: SortOrder
    deletable?: SortOrder
    remember_token?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    name?: StringFilter<"users"> | string
    designation?: StringNullableFilter<"users"> | string | null
    username?: StringFilter<"users"> | string
    email_verified_at?: DateTimeNullableFilter<"users"> | Date | string | null
    password?: StringFilter<"users"> | string
    two_factor_secret?: StringNullableFilter<"users"> | string | null
    two_factor_recovery_codes?: StringNullableFilter<"users"> | string | null
    role?: IntFilter<"users"> | number
    bn_cat_ids?: StringNullableFilter<"users"> | string | null
    status?: IntFilter<"users"> | number
    visibility?: IntFilter<"users"> | number
    deletable?: IntFilter<"users"> | number
    remember_token?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
  }, "id" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    designation?: SortOrderInput | SortOrder
    username?: SortOrder
    email?: SortOrder
    email_verified_at?: SortOrderInput | SortOrder
    password?: SortOrder
    two_factor_secret?: SortOrderInput | SortOrder
    two_factor_recovery_codes?: SortOrderInput | SortOrder
    role?: SortOrder
    bn_cat_ids?: SortOrderInput | SortOrder
    status?: SortOrder
    visibility?: SortOrder
    deletable?: SortOrder
    remember_token?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users"> | number
    name?: StringWithAggregatesFilter<"users"> | string
    designation?: StringNullableWithAggregatesFilter<"users"> | string | null
    username?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    email_verified_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    password?: StringWithAggregatesFilter<"users"> | string
    two_factor_secret?: StringNullableWithAggregatesFilter<"users"> | string | null
    two_factor_recovery_codes?: StringNullableWithAggregatesFilter<"users"> | string | null
    role?: IntWithAggregatesFilter<"users"> | number
    bn_cat_ids?: StringNullableWithAggregatesFilter<"users"> | string | null
    status?: IntWithAggregatesFilter<"users"> | number
    visibility?: IntWithAggregatesFilter<"users"> | number
    deletable?: IntWithAggregatesFilter<"users"> | number
    remember_token?: StringNullableWithAggregatesFilter<"users"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
  }

  export type counterWhereInput = {
    AND?: counterWhereInput | counterWhereInput[]
    OR?: counterWhereInput[]
    NOT?: counterWhereInput | counterWhereInput[]
    id?: IntFilter<"counter"> | number
    counter_name?: StringFilter<"counter"> | string
    counter_time?: StringFilter<"counter"> | string
    time?: StringNullableFilter<"counter"> | string | null
    date?: StringNullableFilter<"counter"> | string | null
    status?: IntNullableFilter<"counter"> | number | null
    created_at?: DateTimeNullableFilter<"counter"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"counter"> | Date | string | null
  }

  export type counterOrderByWithRelationInput = {
    id?: SortOrder
    counter_name?: SortOrder
    counter_time?: SortOrder
    time?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type counterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: counterWhereInput | counterWhereInput[]
    OR?: counterWhereInput[]
    NOT?: counterWhereInput | counterWhereInput[]
    counter_name?: StringFilter<"counter"> | string
    counter_time?: StringFilter<"counter"> | string
    time?: StringNullableFilter<"counter"> | string | null
    date?: StringNullableFilter<"counter"> | string | null
    status?: IntNullableFilter<"counter"> | number | null
    created_at?: DateTimeNullableFilter<"counter"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"counter"> | Date | string | null
  }, "id">

  export type counterOrderByWithAggregationInput = {
    id?: SortOrder
    counter_name?: SortOrder
    counter_time?: SortOrder
    time?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: counterCountOrderByAggregateInput
    _avg?: counterAvgOrderByAggregateInput
    _max?: counterMaxOrderByAggregateInput
    _min?: counterMinOrderByAggregateInput
    _sum?: counterSumOrderByAggregateInput
  }

  export type counterScalarWhereWithAggregatesInput = {
    AND?: counterScalarWhereWithAggregatesInput | counterScalarWhereWithAggregatesInput[]
    OR?: counterScalarWhereWithAggregatesInput[]
    NOT?: counterScalarWhereWithAggregatesInput | counterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"counter"> | number
    counter_name?: StringWithAggregatesFilter<"counter"> | string
    counter_time?: StringWithAggregatesFilter<"counter"> | string
    time?: StringNullableWithAggregatesFilter<"counter"> | string | null
    date?: StringNullableWithAggregatesFilter<"counter"> | string | null
    status?: IntNullableWithAggregatesFilter<"counter"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"counter"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"counter"> | Date | string | null
  }

  export type migrationsWhereInput = {
    AND?: migrationsWhereInput | migrationsWhereInput[]
    OR?: migrationsWhereInput[]
    NOT?: migrationsWhereInput | migrationsWhereInput[]
    id?: IntFilter<"migrations"> | number
    migration?: StringFilter<"migrations"> | string
    batch?: IntFilter<"migrations"> | number
  }

  export type migrationsOrderByWithRelationInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
  }

  export type migrationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: migrationsWhereInput | migrationsWhereInput[]
    OR?: migrationsWhereInput[]
    NOT?: migrationsWhereInput | migrationsWhereInput[]
    migration?: StringFilter<"migrations"> | string
    batch?: IntFilter<"migrations"> | number
  }, "id">

  export type migrationsOrderByWithAggregationInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
    _count?: migrationsCountOrderByAggregateInput
    _avg?: migrationsAvgOrderByAggregateInput
    _max?: migrationsMaxOrderByAggregateInput
    _min?: migrationsMinOrderByAggregateInput
    _sum?: migrationsSumOrderByAggregateInput
  }

  export type migrationsScalarWhereWithAggregatesInput = {
    AND?: migrationsScalarWhereWithAggregatesInput | migrationsScalarWhereWithAggregatesInput[]
    OR?: migrationsScalarWhereWithAggregatesInput[]
    NOT?: migrationsScalarWhereWithAggregatesInput | migrationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"migrations"> | number
    migration?: StringWithAggregatesFilter<"migrations"> | string
    batch?: IntWithAggregatesFilter<"migrations"> | number
  }

  export type authorsCreateInput = {
    author_type?: number
    author_name: string
    author_name_bn: string
    author_slug: string
    author_initial: string
    author_initial_bn: string
    author_bio?: string | null
    author_bio_bn?: string | null
    img_path?: string | null
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type authorsUncheckedCreateInput = {
    author_id?: number
    author_type?: number
    author_name: string
    author_name_bn: string
    author_slug: string
    author_initial: string
    author_initial_bn: string
    author_bio?: string | null
    author_bio_bn?: string | null
    img_path?: string | null
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type authorsUpdateInput = {
    author_type?: IntFieldUpdateOperationsInput | number
    author_name?: StringFieldUpdateOperationsInput | string
    author_name_bn?: StringFieldUpdateOperationsInput | string
    author_slug?: StringFieldUpdateOperationsInput | string
    author_initial?: StringFieldUpdateOperationsInput | string
    author_initial_bn?: StringFieldUpdateOperationsInput | string
    author_bio?: NullableStringFieldUpdateOperationsInput | string | null
    author_bio_bn?: NullableStringFieldUpdateOperationsInput | string | null
    img_path?: NullableStringFieldUpdateOperationsInput | string | null
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type authorsUncheckedUpdateInput = {
    author_id?: IntFieldUpdateOperationsInput | number
    author_type?: IntFieldUpdateOperationsInput | number
    author_name?: StringFieldUpdateOperationsInput | string
    author_name_bn?: StringFieldUpdateOperationsInput | string
    author_slug?: StringFieldUpdateOperationsInput | string
    author_initial?: StringFieldUpdateOperationsInput | string
    author_initial_bn?: StringFieldUpdateOperationsInput | string
    author_bio?: NullableStringFieldUpdateOperationsInput | string | null
    author_bio_bn?: NullableStringFieldUpdateOperationsInput | string | null
    img_path?: NullableStringFieldUpdateOperationsInput | string | null
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type authorsCreateManyInput = {
    author_id?: number
    author_type?: number
    author_name: string
    author_name_bn: string
    author_slug: string
    author_initial: string
    author_initial_bn: string
    author_bio?: string | null
    author_bio_bn?: string | null
    img_path?: string | null
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type authorsUpdateManyMutationInput = {
    author_type?: IntFieldUpdateOperationsInput | number
    author_name?: StringFieldUpdateOperationsInput | string
    author_name_bn?: StringFieldUpdateOperationsInput | string
    author_slug?: StringFieldUpdateOperationsInput | string
    author_initial?: StringFieldUpdateOperationsInput | string
    author_initial_bn?: StringFieldUpdateOperationsInput | string
    author_bio?: NullableStringFieldUpdateOperationsInput | string | null
    author_bio_bn?: NullableStringFieldUpdateOperationsInput | string | null
    img_path?: NullableStringFieldUpdateOperationsInput | string | null
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type authorsUncheckedUpdateManyInput = {
    author_id?: IntFieldUpdateOperationsInput | number
    author_type?: IntFieldUpdateOperationsInput | number
    author_name?: StringFieldUpdateOperationsInput | string
    author_name_bn?: StringFieldUpdateOperationsInput | string
    author_slug?: StringFieldUpdateOperationsInput | string
    author_initial?: StringFieldUpdateOperationsInput | string
    author_initial_bn?: StringFieldUpdateOperationsInput | string
    author_bio?: NullableStringFieldUpdateOperationsInput | string | null
    author_bio_bn?: NullableStringFieldUpdateOperationsInput | string | null
    img_path?: NullableStringFieldUpdateOperationsInput | string | null
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_adsCreateInput = {
    type?: number | null
    page?: number | null
    position?: number | null
    dfp_header_code?: string | null
    code?: string | null
    desktop_image_path?: string | null
    mobile_image_path?: string | null
    external_link?: string | null
    start_time?: Date | string | null
    end_time?: Date | string | null
    status?: number | null
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_adsUncheckedCreateInput = {
    id?: number
    type?: number | null
    page?: number | null
    position?: number | null
    dfp_header_code?: string | null
    code?: string | null
    desktop_image_path?: string | null
    mobile_image_path?: string | null
    external_link?: string | null
    start_time?: Date | string | null
    end_time?: Date | string | null
    status?: number | null
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_adsUpdateInput = {
    type?: NullableIntFieldUpdateOperationsInput | number | null
    page?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    dfp_header_code?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    desktop_image_path?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_image_path?: NullableStringFieldUpdateOperationsInput | string | null
    external_link?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_adsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableIntFieldUpdateOperationsInput | number | null
    page?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    dfp_header_code?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    desktop_image_path?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_image_path?: NullableStringFieldUpdateOperationsInput | string | null
    external_link?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_adsCreateManyInput = {
    id?: number
    type?: number | null
    page?: number | null
    position?: number | null
    dfp_header_code?: string | null
    code?: string | null
    desktop_image_path?: string | null
    mobile_image_path?: string | null
    external_link?: string | null
    start_time?: Date | string | null
    end_time?: Date | string | null
    status?: number | null
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_adsUpdateManyMutationInput = {
    type?: NullableIntFieldUpdateOperationsInput | number | null
    page?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    dfp_header_code?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    desktop_image_path?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_image_path?: NullableStringFieldUpdateOperationsInput | string | null
    external_link?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_adsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableIntFieldUpdateOperationsInput | number | null
    page?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    dfp_header_code?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    desktop_image_path?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_image_path?: NullableStringFieldUpdateOperationsInput | string | null
    external_link?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_breaking_newsCreateInput = {
    news_title?: string | null
    news_link?: string | null
    position?: number | null
    hours?: number | null
    user_id: number
    expired_time?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_breaking_newsUncheckedCreateInput = {
    id?: number
    news_title?: string | null
    news_link?: string | null
    position?: number | null
    hours?: number | null
    user_id: number
    expired_time?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_breaking_newsUpdateInput = {
    news_title?: NullableStringFieldUpdateOperationsInput | string | null
    news_link?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    expired_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_breaking_newsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    news_title?: NullableStringFieldUpdateOperationsInput | string | null
    news_link?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    expired_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_breaking_newsCreateManyInput = {
    id?: number
    news_title?: string | null
    news_link?: string | null
    position?: number | null
    hours?: number | null
    user_id: number
    expired_time?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_breaking_newsUpdateManyMutationInput = {
    news_title?: NullableStringFieldUpdateOperationsInput | string | null
    news_link?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    expired_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_breaking_newsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    news_title?: NullableStringFieldUpdateOperationsInput | string | null
    news_link?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
    expired_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_categoriesCreateInput = {
    cat_type?: number
    cat_name: string
    cat_name_bn: string
    cat_slug: string
    cat_title?: string | null
    cat_meta_keyword?: string | null
    cat_meta_description?: string | null
    cat_position?: number
    top_menu?: number
    footer_menu?: number
    status?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_categoriesUncheckedCreateInput = {
    cat_id?: number
    cat_type?: number
    cat_name: string
    cat_name_bn: string
    cat_slug: string
    cat_title?: string | null
    cat_meta_keyword?: string | null
    cat_meta_description?: string | null
    cat_position?: number
    top_menu?: number
    footer_menu?: number
    status?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_categoriesUpdateInput = {
    cat_type?: IntFieldUpdateOperationsInput | number
    cat_name?: StringFieldUpdateOperationsInput | string
    cat_name_bn?: StringFieldUpdateOperationsInput | string
    cat_slug?: StringFieldUpdateOperationsInput | string
    cat_title?: NullableStringFieldUpdateOperationsInput | string | null
    cat_meta_keyword?: NullableStringFieldUpdateOperationsInput | string | null
    cat_meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    cat_position?: IntFieldUpdateOperationsInput | number
    top_menu?: IntFieldUpdateOperationsInput | number
    footer_menu?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_categoriesUncheckedUpdateInput = {
    cat_id?: IntFieldUpdateOperationsInput | number
    cat_type?: IntFieldUpdateOperationsInput | number
    cat_name?: StringFieldUpdateOperationsInput | string
    cat_name_bn?: StringFieldUpdateOperationsInput | string
    cat_slug?: StringFieldUpdateOperationsInput | string
    cat_title?: NullableStringFieldUpdateOperationsInput | string | null
    cat_meta_keyword?: NullableStringFieldUpdateOperationsInput | string | null
    cat_meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    cat_position?: IntFieldUpdateOperationsInput | number
    top_menu?: IntFieldUpdateOperationsInput | number
    footer_menu?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_categoriesCreateManyInput = {
    cat_id?: number
    cat_type?: number
    cat_name: string
    cat_name_bn: string
    cat_slug: string
    cat_title?: string | null
    cat_meta_keyword?: string | null
    cat_meta_description?: string | null
    cat_position?: number
    top_menu?: number
    footer_menu?: number
    status?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_categoriesUpdateManyMutationInput = {
    cat_type?: IntFieldUpdateOperationsInput | number
    cat_name?: StringFieldUpdateOperationsInput | string
    cat_name_bn?: StringFieldUpdateOperationsInput | string
    cat_slug?: StringFieldUpdateOperationsInput | string
    cat_title?: NullableStringFieldUpdateOperationsInput | string | null
    cat_meta_keyword?: NullableStringFieldUpdateOperationsInput | string | null
    cat_meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    cat_position?: IntFieldUpdateOperationsInput | number
    top_menu?: IntFieldUpdateOperationsInput | number
    footer_menu?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_categoriesUncheckedUpdateManyInput = {
    cat_id?: IntFieldUpdateOperationsInput | number
    cat_type?: IntFieldUpdateOperationsInput | number
    cat_name?: StringFieldUpdateOperationsInput | string
    cat_name_bn?: StringFieldUpdateOperationsInput | string
    cat_slug?: StringFieldUpdateOperationsInput | string
    cat_title?: NullableStringFieldUpdateOperationsInput | string | null
    cat_meta_keyword?: NullableStringFieldUpdateOperationsInput | string | null
    cat_meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    cat_position?: IntFieldUpdateOperationsInput | number
    top_menu?: IntFieldUpdateOperationsInput | number
    footer_menu?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_content_positionsCreateInput = {
    position_name: string
    position_slug: string
    cat_id?: number | null
    special_cat_id?: number | null
    subcat_id?: number | null
    content_ids?: string | null
    total_content?: number | null
    status?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_content_positionsUncheckedCreateInput = {
    position_id?: number
    position_name: string
    position_slug: string
    cat_id?: number | null
    special_cat_id?: number | null
    subcat_id?: number | null
    content_ids?: string | null
    total_content?: number | null
    status?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_content_positionsUpdateInput = {
    position_name?: StringFieldUpdateOperationsInput | string
    position_slug?: StringFieldUpdateOperationsInput | string
    cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    special_cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    subcat_id?: NullableIntFieldUpdateOperationsInput | number | null
    content_ids?: NullableStringFieldUpdateOperationsInput | string | null
    total_content?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_content_positionsUncheckedUpdateInput = {
    position_id?: IntFieldUpdateOperationsInput | number
    position_name?: StringFieldUpdateOperationsInput | string
    position_slug?: StringFieldUpdateOperationsInput | string
    cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    special_cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    subcat_id?: NullableIntFieldUpdateOperationsInput | number | null
    content_ids?: NullableStringFieldUpdateOperationsInput | string | null
    total_content?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_content_positionsCreateManyInput = {
    position_id?: number
    position_name: string
    position_slug: string
    cat_id?: number | null
    special_cat_id?: number | null
    subcat_id?: number | null
    content_ids?: string | null
    total_content?: number | null
    status?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_content_positionsUpdateManyMutationInput = {
    position_name?: StringFieldUpdateOperationsInput | string
    position_slug?: StringFieldUpdateOperationsInput | string
    cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    special_cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    subcat_id?: NullableIntFieldUpdateOperationsInput | number | null
    content_ids?: NullableStringFieldUpdateOperationsInput | string | null
    total_content?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_content_positionsUncheckedUpdateManyInput = {
    position_id?: IntFieldUpdateOperationsInput | number
    position_name?: StringFieldUpdateOperationsInput | string
    position_slug?: StringFieldUpdateOperationsInput | string
    cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    special_cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    subcat_id?: NullableIntFieldUpdateOperationsInput | number | null
    content_ids?: NullableStringFieldUpdateOperationsInput | string | null
    total_content?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_contentsCreateInput = {
    content_type?: number
    cat_id: number
    subcat_id?: number
    special_cat_id?: number
    country_id: number
    division_id?: number
    district_id?: number
    upozilla_id: number
    content_heading: string
    content_sub_heading?: string | null
    author_slugs?: string | null
    author_name?: string | null
    content_brief?: string | null
    content_details: string
    img_xs_path?: string | null
    img_sm_path?: string | null
    img_sm_caption?: string | null
    img_bg_path?: string | null
    og_image?: string | null
    img_bg_caption?: string | null
    related_ids?: string | null
    photo_ids?: string | null
    video_type?: number | null
    video_id?: string | null
    uploader_id: number
    reporter_id?: number | null
    tags?: string | null
    meta_keywords?: string | null
    timeline_tag?: string | null
    podcast_id?: string | null
    status?: number
    scroll?: number
    total_hit?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_contentsUncheckedCreateInput = {
    content_id?: number
    content_type?: number
    cat_id: number
    subcat_id?: number
    special_cat_id?: number
    country_id: number
    division_id?: number
    district_id?: number
    upozilla_id: number
    content_heading: string
    content_sub_heading?: string | null
    author_slugs?: string | null
    author_name?: string | null
    content_brief?: string | null
    content_details: string
    img_xs_path?: string | null
    img_sm_path?: string | null
    img_sm_caption?: string | null
    img_bg_path?: string | null
    og_image?: string | null
    img_bg_caption?: string | null
    related_ids?: string | null
    photo_ids?: string | null
    video_type?: number | null
    video_id?: string | null
    uploader_id: number
    reporter_id?: number | null
    tags?: string | null
    meta_keywords?: string | null
    timeline_tag?: string | null
    podcast_id?: string | null
    status?: number
    scroll?: number
    total_hit?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_contentsUpdateInput = {
    content_type?: IntFieldUpdateOperationsInput | number
    cat_id?: IntFieldUpdateOperationsInput | number
    subcat_id?: IntFieldUpdateOperationsInput | number
    special_cat_id?: IntFieldUpdateOperationsInput | number
    country_id?: IntFieldUpdateOperationsInput | number
    division_id?: IntFieldUpdateOperationsInput | number
    district_id?: IntFieldUpdateOperationsInput | number
    upozilla_id?: IntFieldUpdateOperationsInput | number
    content_heading?: StringFieldUpdateOperationsInput | string
    content_sub_heading?: NullableStringFieldUpdateOperationsInput | string | null
    author_slugs?: NullableStringFieldUpdateOperationsInput | string | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    content_brief?: NullableStringFieldUpdateOperationsInput | string | null
    content_details?: StringFieldUpdateOperationsInput | string
    img_xs_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_sm_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_sm_caption?: NullableStringFieldUpdateOperationsInput | string | null
    img_bg_path?: NullableStringFieldUpdateOperationsInput | string | null
    og_image?: NullableStringFieldUpdateOperationsInput | string | null
    img_bg_caption?: NullableStringFieldUpdateOperationsInput | string | null
    related_ids?: NullableStringFieldUpdateOperationsInput | string | null
    photo_ids?: NullableStringFieldUpdateOperationsInput | string | null
    video_type?: NullableIntFieldUpdateOperationsInput | number | null
    video_id?: NullableStringFieldUpdateOperationsInput | string | null
    uploader_id?: IntFieldUpdateOperationsInput | number
    reporter_id?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    timeline_tag?: NullableStringFieldUpdateOperationsInput | string | null
    podcast_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    scroll?: IntFieldUpdateOperationsInput | number
    total_hit?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_contentsUncheckedUpdateInput = {
    content_id?: IntFieldUpdateOperationsInput | number
    content_type?: IntFieldUpdateOperationsInput | number
    cat_id?: IntFieldUpdateOperationsInput | number
    subcat_id?: IntFieldUpdateOperationsInput | number
    special_cat_id?: IntFieldUpdateOperationsInput | number
    country_id?: IntFieldUpdateOperationsInput | number
    division_id?: IntFieldUpdateOperationsInput | number
    district_id?: IntFieldUpdateOperationsInput | number
    upozilla_id?: IntFieldUpdateOperationsInput | number
    content_heading?: StringFieldUpdateOperationsInput | string
    content_sub_heading?: NullableStringFieldUpdateOperationsInput | string | null
    author_slugs?: NullableStringFieldUpdateOperationsInput | string | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    content_brief?: NullableStringFieldUpdateOperationsInput | string | null
    content_details?: StringFieldUpdateOperationsInput | string
    img_xs_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_sm_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_sm_caption?: NullableStringFieldUpdateOperationsInput | string | null
    img_bg_path?: NullableStringFieldUpdateOperationsInput | string | null
    og_image?: NullableStringFieldUpdateOperationsInput | string | null
    img_bg_caption?: NullableStringFieldUpdateOperationsInput | string | null
    related_ids?: NullableStringFieldUpdateOperationsInput | string | null
    photo_ids?: NullableStringFieldUpdateOperationsInput | string | null
    video_type?: NullableIntFieldUpdateOperationsInput | number | null
    video_id?: NullableStringFieldUpdateOperationsInput | string | null
    uploader_id?: IntFieldUpdateOperationsInput | number
    reporter_id?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    timeline_tag?: NullableStringFieldUpdateOperationsInput | string | null
    podcast_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    scroll?: IntFieldUpdateOperationsInput | number
    total_hit?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_contentsCreateManyInput = {
    content_id?: number
    content_type?: number
    cat_id: number
    subcat_id?: number
    special_cat_id?: number
    country_id: number
    division_id?: number
    district_id?: number
    upozilla_id: number
    content_heading: string
    content_sub_heading?: string | null
    author_slugs?: string | null
    author_name?: string | null
    content_brief?: string | null
    content_details: string
    img_xs_path?: string | null
    img_sm_path?: string | null
    img_sm_caption?: string | null
    img_bg_path?: string | null
    og_image?: string | null
    img_bg_caption?: string | null
    related_ids?: string | null
    photo_ids?: string | null
    video_type?: number | null
    video_id?: string | null
    uploader_id: number
    reporter_id?: number | null
    tags?: string | null
    meta_keywords?: string | null
    timeline_tag?: string | null
    podcast_id?: string | null
    status?: number
    scroll?: number
    total_hit?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_contentsUpdateManyMutationInput = {
    content_type?: IntFieldUpdateOperationsInput | number
    cat_id?: IntFieldUpdateOperationsInput | number
    subcat_id?: IntFieldUpdateOperationsInput | number
    special_cat_id?: IntFieldUpdateOperationsInput | number
    country_id?: IntFieldUpdateOperationsInput | number
    division_id?: IntFieldUpdateOperationsInput | number
    district_id?: IntFieldUpdateOperationsInput | number
    upozilla_id?: IntFieldUpdateOperationsInput | number
    content_heading?: StringFieldUpdateOperationsInput | string
    content_sub_heading?: NullableStringFieldUpdateOperationsInput | string | null
    author_slugs?: NullableStringFieldUpdateOperationsInput | string | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    content_brief?: NullableStringFieldUpdateOperationsInput | string | null
    content_details?: StringFieldUpdateOperationsInput | string
    img_xs_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_sm_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_sm_caption?: NullableStringFieldUpdateOperationsInput | string | null
    img_bg_path?: NullableStringFieldUpdateOperationsInput | string | null
    og_image?: NullableStringFieldUpdateOperationsInput | string | null
    img_bg_caption?: NullableStringFieldUpdateOperationsInput | string | null
    related_ids?: NullableStringFieldUpdateOperationsInput | string | null
    photo_ids?: NullableStringFieldUpdateOperationsInput | string | null
    video_type?: NullableIntFieldUpdateOperationsInput | number | null
    video_id?: NullableStringFieldUpdateOperationsInput | string | null
    uploader_id?: IntFieldUpdateOperationsInput | number
    reporter_id?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    timeline_tag?: NullableStringFieldUpdateOperationsInput | string | null
    podcast_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    scroll?: IntFieldUpdateOperationsInput | number
    total_hit?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_contentsUncheckedUpdateManyInput = {
    content_id?: IntFieldUpdateOperationsInput | number
    content_type?: IntFieldUpdateOperationsInput | number
    cat_id?: IntFieldUpdateOperationsInput | number
    subcat_id?: IntFieldUpdateOperationsInput | number
    special_cat_id?: IntFieldUpdateOperationsInput | number
    country_id?: IntFieldUpdateOperationsInput | number
    division_id?: IntFieldUpdateOperationsInput | number
    district_id?: IntFieldUpdateOperationsInput | number
    upozilla_id?: IntFieldUpdateOperationsInput | number
    content_heading?: StringFieldUpdateOperationsInput | string
    content_sub_heading?: NullableStringFieldUpdateOperationsInput | string | null
    author_slugs?: NullableStringFieldUpdateOperationsInput | string | null
    author_name?: NullableStringFieldUpdateOperationsInput | string | null
    content_brief?: NullableStringFieldUpdateOperationsInput | string | null
    content_details?: StringFieldUpdateOperationsInput | string
    img_xs_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_sm_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_sm_caption?: NullableStringFieldUpdateOperationsInput | string | null
    img_bg_path?: NullableStringFieldUpdateOperationsInput | string | null
    og_image?: NullableStringFieldUpdateOperationsInput | string | null
    img_bg_caption?: NullableStringFieldUpdateOperationsInput | string | null
    related_ids?: NullableStringFieldUpdateOperationsInput | string | null
    photo_ids?: NullableStringFieldUpdateOperationsInput | string | null
    video_type?: NullableIntFieldUpdateOperationsInput | number | null
    video_id?: NullableStringFieldUpdateOperationsInput | string | null
    uploader_id?: IntFieldUpdateOperationsInput | number
    reporter_id?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    timeline_tag?: NullableStringFieldUpdateOperationsInput | string | null
    podcast_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    scroll?: IntFieldUpdateOperationsInput | number
    total_hit?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_mobile_adsCreateInput = {
    type?: number | null
    page?: number | null
    position?: number | null
    dfp_header_code?: string | null
    code?: string | null
    mobile_image_path?: string | null
    external_link?: string | null
    start_time?: Date | string | null
    end_time?: Date | string | null
    status?: number | null
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_mobile_adsUncheckedCreateInput = {
    id?: number
    type?: number | null
    page?: number | null
    position?: number | null
    dfp_header_code?: string | null
    code?: string | null
    mobile_image_path?: string | null
    external_link?: string | null
    start_time?: Date | string | null
    end_time?: Date | string | null
    status?: number | null
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_mobile_adsUpdateInput = {
    type?: NullableIntFieldUpdateOperationsInput | number | null
    page?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    dfp_header_code?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_image_path?: NullableStringFieldUpdateOperationsInput | string | null
    external_link?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_mobile_adsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableIntFieldUpdateOperationsInput | number | null
    page?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    dfp_header_code?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_image_path?: NullableStringFieldUpdateOperationsInput | string | null
    external_link?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_mobile_adsCreateManyInput = {
    id?: number
    type?: number | null
    page?: number | null
    position?: number | null
    dfp_header_code?: string | null
    code?: string | null
    mobile_image_path?: string | null
    external_link?: string | null
    start_time?: Date | string | null
    end_time?: Date | string | null
    status?: number | null
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_mobile_adsUpdateManyMutationInput = {
    type?: NullableIntFieldUpdateOperationsInput | number | null
    page?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    dfp_header_code?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_image_path?: NullableStringFieldUpdateOperationsInput | string | null
    external_link?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_mobile_adsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableIntFieldUpdateOperationsInput | number | null
    page?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    dfp_header_code?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_image_path?: NullableStringFieldUpdateOperationsInput | string | null
    external_link?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_position_fixedCreateInput = {
    position_number?: number | null
    news_id?: number | null
    is_fixed?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_position_fixedUncheckedCreateInput = {
    id?: number
    position_number?: number | null
    news_id?: number | null
    is_fixed?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_position_fixedUpdateInput = {
    position_number?: NullableIntFieldUpdateOperationsInput | number | null
    news_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_fixed?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_position_fixedUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    position_number?: NullableIntFieldUpdateOperationsInput | number | null
    news_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_fixed?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_position_fixedCreateManyInput = {
    id?: number
    position_number?: number | null
    news_id?: number | null
    is_fixed?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_position_fixedUpdateManyMutationInput = {
    position_number?: NullableIntFieldUpdateOperationsInput | number | null
    news_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_fixed?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_position_fixedUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    position_number?: NullableIntFieldUpdateOperationsInput | number | null
    news_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_fixed?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_subcategoriesCreateInput = {
    cat_id: number
    subcat_name: string
    subcat_name_bn: string
    subcat_slug: string
    subcat_meta_keyword?: string | null
    subcat_meta_description?: string | null
    subcat_position?: number
    status?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_subcategoriesUncheckedCreateInput = {
    subcat_id?: number
    cat_id: number
    subcat_name: string
    subcat_name_bn: string
    subcat_slug: string
    subcat_meta_keyword?: string | null
    subcat_meta_description?: string | null
    subcat_position?: number
    status?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_subcategoriesUpdateInput = {
    cat_id?: IntFieldUpdateOperationsInput | number
    subcat_name?: StringFieldUpdateOperationsInput | string
    subcat_name_bn?: StringFieldUpdateOperationsInput | string
    subcat_slug?: StringFieldUpdateOperationsInput | string
    subcat_meta_keyword?: NullableStringFieldUpdateOperationsInput | string | null
    subcat_meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    subcat_position?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_subcategoriesUncheckedUpdateInput = {
    subcat_id?: IntFieldUpdateOperationsInput | number
    cat_id?: IntFieldUpdateOperationsInput | number
    subcat_name?: StringFieldUpdateOperationsInput | string
    subcat_name_bn?: StringFieldUpdateOperationsInput | string
    subcat_slug?: StringFieldUpdateOperationsInput | string
    subcat_meta_keyword?: NullableStringFieldUpdateOperationsInput | string | null
    subcat_meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    subcat_position?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_subcategoriesCreateManyInput = {
    subcat_id?: number
    cat_id: number
    subcat_name: string
    subcat_name_bn: string
    subcat_slug: string
    subcat_meta_keyword?: string | null
    subcat_meta_description?: string | null
    subcat_position?: number
    status?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_subcategoriesUpdateManyMutationInput = {
    cat_id?: IntFieldUpdateOperationsInput | number
    subcat_name?: StringFieldUpdateOperationsInput | string
    subcat_name_bn?: StringFieldUpdateOperationsInput | string
    subcat_slug?: StringFieldUpdateOperationsInput | string
    subcat_meta_keyword?: NullableStringFieldUpdateOperationsInput | string | null
    subcat_meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    subcat_position?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_subcategoriesUncheckedUpdateManyInput = {
    subcat_id?: IntFieldUpdateOperationsInput | number
    cat_id?: IntFieldUpdateOperationsInput | number
    subcat_name?: StringFieldUpdateOperationsInput | string
    subcat_name_bn?: StringFieldUpdateOperationsInput | string
    subcat_slug?: StringFieldUpdateOperationsInput | string
    subcat_meta_keyword?: NullableStringFieldUpdateOperationsInput | string | null
    subcat_meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    subcat_position?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_tagsCreateInput = {
    tag_type?: number | null
    tag_name: string
    tag_slug: string
    description?: string | null
    img_path?: string | null
    approval?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_tagsUncheckedCreateInput = {
    tag_id?: number
    tag_type?: number | null
    tag_name: string
    tag_slug: string
    description?: string | null
    img_path?: string | null
    approval?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_tagsUpdateInput = {
    tag_type?: NullableIntFieldUpdateOperationsInput | number | null
    tag_name?: StringFieldUpdateOperationsInput | string
    tag_slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    img_path?: NullableStringFieldUpdateOperationsInput | string | null
    approval?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_tagsUncheckedUpdateInput = {
    tag_id?: IntFieldUpdateOperationsInput | number
    tag_type?: NullableIntFieldUpdateOperationsInput | number | null
    tag_name?: StringFieldUpdateOperationsInput | string
    tag_slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    img_path?: NullableStringFieldUpdateOperationsInput | string | null
    approval?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_tagsCreateManyInput = {
    tag_id?: number
    tag_type?: number | null
    tag_name: string
    tag_slug: string
    description?: string | null
    img_path?: string | null
    approval?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_tagsUpdateManyMutationInput = {
    tag_type?: NullableIntFieldUpdateOperationsInput | number | null
    tag_name?: StringFieldUpdateOperationsInput | string
    tag_slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    img_path?: NullableStringFieldUpdateOperationsInput | string | null
    approval?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_tagsUncheckedUpdateManyInput = {
    tag_id?: IntFieldUpdateOperationsInput | number
    tag_type?: NullableIntFieldUpdateOperationsInput | number | null
    tag_name?: StringFieldUpdateOperationsInput | string
    tag_slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    img_path?: NullableStringFieldUpdateOperationsInput | string | null
    approval?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_video_categoriesCreateInput = {
    name?: string | null
    slug?: string | null
    name_bn?: string | null
    meta_keywords?: string | null
    meta_description?: string | null
    og_img_path?: string | null
    position?: number | null
    user_id?: number | null
    status?: number | null
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_video_categoriesUncheckedCreateInput = {
    id?: number
    name?: string | null
    slug?: string | null
    name_bn?: string | null
    meta_keywords?: string | null
    meta_description?: string | null
    og_img_path?: string | null
    position?: number | null
    user_id?: number | null
    status?: number | null
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_video_categoriesUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name_bn?: NullableStringFieldUpdateOperationsInput | string | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    og_img_path?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_video_categoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name_bn?: NullableStringFieldUpdateOperationsInput | string | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    og_img_path?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_video_categoriesCreateManyInput = {
    id?: number
    name?: string | null
    slug?: string | null
    name_bn?: string | null
    meta_keywords?: string | null
    meta_description?: string | null
    og_img_path?: string | null
    position?: number | null
    user_id?: number | null
    status?: number | null
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_video_categoriesUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name_bn?: NullableStringFieldUpdateOperationsInput | string | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    og_img_path?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_video_categoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name_bn?: NullableStringFieldUpdateOperationsInput | string | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    og_img_path?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_video_positionsCreateInput = {
    position_name: string
    cat_id?: number | null
    subcat_id?: number | null
    video_ids?: string | null
    total_video?: number | null
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_video_positionsUncheckedCreateInput = {
    position_id?: number
    position_name: string
    cat_id?: number | null
    subcat_id?: number | null
    video_ids?: string | null
    total_video?: number | null
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_video_positionsUpdateInput = {
    position_name?: StringFieldUpdateOperationsInput | string
    cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    subcat_id?: NullableIntFieldUpdateOperationsInput | number | null
    video_ids?: NullableStringFieldUpdateOperationsInput | string | null
    total_video?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_video_positionsUncheckedUpdateInput = {
    position_id?: IntFieldUpdateOperationsInput | number
    position_name?: StringFieldUpdateOperationsInput | string
    cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    subcat_id?: NullableIntFieldUpdateOperationsInput | number | null
    video_ids?: NullableStringFieldUpdateOperationsInput | string | null
    total_video?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_video_positionsCreateManyInput = {
    position_id?: number
    position_name: string
    cat_id?: number | null
    subcat_id?: number | null
    video_ids?: string | null
    total_video?: number | null
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_video_positionsUpdateManyMutationInput = {
    position_name?: StringFieldUpdateOperationsInput | string
    cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    subcat_id?: NullableIntFieldUpdateOperationsInput | number | null
    video_ids?: NullableStringFieldUpdateOperationsInput | string | null
    total_video?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_video_positionsUncheckedUpdateManyInput = {
    position_id?: IntFieldUpdateOperationsInput | number
    position_name?: StringFieldUpdateOperationsInput | string
    cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    subcat_id?: NullableIntFieldUpdateOperationsInput | number | null
    video_ids?: NullableStringFieldUpdateOperationsInput | string | null
    total_video?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_videosCreateInput = {
    cat_id?: number | null
    type?: number | null
    title?: string | null
    code?: string | null
    img_bg_path?: string | null
    img_sm_path?: string | null
    img_xs_path?: string | null
    link?: string | null
    meta_keywords?: string | null
    meta_description?: string | null
    user_id?: number | null
    target?: number
    is_live?: number
    status?: number | null
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_videosUncheckedCreateInput = {
    id?: number
    cat_id?: number | null
    type?: number | null
    title?: string | null
    code?: string | null
    img_bg_path?: string | null
    img_sm_path?: string | null
    img_xs_path?: string | null
    link?: string | null
    meta_keywords?: string | null
    meta_description?: string | null
    user_id?: number | null
    target?: number
    is_live?: number
    status?: number | null
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_videosUpdateInput = {
    cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    img_bg_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_sm_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_xs_path?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    target?: IntFieldUpdateOperationsInput | number
    is_live?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_videosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    img_bg_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_sm_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_xs_path?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    target?: IntFieldUpdateOperationsInput | number
    is_live?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_videosCreateManyInput = {
    id?: number
    cat_id?: number | null
    type?: number | null
    title?: string | null
    code?: string | null
    img_bg_path?: string | null
    img_sm_path?: string | null
    img_xs_path?: string | null
    link?: string | null
    meta_keywords?: string | null
    meta_description?: string | null
    user_id?: number | null
    target?: number
    is_live?: number
    status?: number | null
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bn_videosUpdateManyMutationInput = {
    cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    img_bg_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_sm_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_xs_path?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    target?: IntFieldUpdateOperationsInput | number
    is_live?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bn_videosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    img_bg_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_sm_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_xs_path?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    target?: IntFieldUpdateOperationsInput | number
    is_live?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type countriesCreateInput = {
    country_name: string
    country_name_bn: string
    country_slug: string
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type countriesUncheckedCreateInput = {
    country_id?: number
    country_name: string
    country_name_bn: string
    country_slug: string
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type countriesUpdateInput = {
    country_name?: StringFieldUpdateOperationsInput | string
    country_name_bn?: StringFieldUpdateOperationsInput | string
    country_slug?: StringFieldUpdateOperationsInput | string
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type countriesUncheckedUpdateInput = {
    country_id?: IntFieldUpdateOperationsInput | number
    country_name?: StringFieldUpdateOperationsInput | string
    country_name_bn?: StringFieldUpdateOperationsInput | string
    country_slug?: StringFieldUpdateOperationsInput | string
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type countriesCreateManyInput = {
    country_id?: number
    country_name: string
    country_name_bn: string
    country_slug: string
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type countriesUpdateManyMutationInput = {
    country_name?: StringFieldUpdateOperationsInput | string
    country_name_bn?: StringFieldUpdateOperationsInput | string
    country_slug?: StringFieldUpdateOperationsInput | string
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type countriesUncheckedUpdateManyInput = {
    country_id?: IntFieldUpdateOperationsInput | number
    country_name?: StringFieldUpdateOperationsInput | string
    country_name_bn?: StringFieldUpdateOperationsInput | string
    country_slug?: StringFieldUpdateOperationsInput | string
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type districtsCreateInput = {
    division_id: number
    district_name: string
    district_name_bn: string
    district_slug: string
    district_title?: string | null
    meta_description?: string | null
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type districtsUncheckedCreateInput = {
    district_id?: number
    division_id: number
    district_name: string
    district_name_bn: string
    district_slug: string
    district_title?: string | null
    meta_description?: string | null
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type districtsUpdateInput = {
    division_id?: IntFieldUpdateOperationsInput | number
    district_name?: StringFieldUpdateOperationsInput | string
    district_name_bn?: StringFieldUpdateOperationsInput | string
    district_slug?: StringFieldUpdateOperationsInput | string
    district_title?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type districtsUncheckedUpdateInput = {
    district_id?: IntFieldUpdateOperationsInput | number
    division_id?: IntFieldUpdateOperationsInput | number
    district_name?: StringFieldUpdateOperationsInput | string
    district_name_bn?: StringFieldUpdateOperationsInput | string
    district_slug?: StringFieldUpdateOperationsInput | string
    district_title?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type districtsCreateManyInput = {
    district_id?: number
    division_id: number
    district_name: string
    district_name_bn: string
    district_slug: string
    district_title?: string | null
    meta_description?: string | null
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type districtsUpdateManyMutationInput = {
    division_id?: IntFieldUpdateOperationsInput | number
    district_name?: StringFieldUpdateOperationsInput | string
    district_name_bn?: StringFieldUpdateOperationsInput | string
    district_slug?: StringFieldUpdateOperationsInput | string
    district_title?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type districtsUncheckedUpdateManyInput = {
    district_id?: IntFieldUpdateOperationsInput | number
    division_id?: IntFieldUpdateOperationsInput | number
    district_name?: StringFieldUpdateOperationsInput | string
    district_name_bn?: StringFieldUpdateOperationsInput | string
    district_slug?: StringFieldUpdateOperationsInput | string
    district_title?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type divisionsCreateInput = {
    division_name: string
    division_name_bn: string
    division_slug: string
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type divisionsUncheckedCreateInput = {
    division_id?: number
    division_name: string
    division_name_bn: string
    division_slug: string
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type divisionsUpdateInput = {
    division_name?: StringFieldUpdateOperationsInput | string
    division_name_bn?: StringFieldUpdateOperationsInput | string
    division_slug?: StringFieldUpdateOperationsInput | string
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type divisionsUncheckedUpdateInput = {
    division_id?: IntFieldUpdateOperationsInput | number
    division_name?: StringFieldUpdateOperationsInput | string
    division_name_bn?: StringFieldUpdateOperationsInput | string
    division_slug?: StringFieldUpdateOperationsInput | string
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type divisionsCreateManyInput = {
    division_id?: number
    division_name: string
    division_name_bn: string
    division_slug: string
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type divisionsUpdateManyMutationInput = {
    division_name?: StringFieldUpdateOperationsInput | string
    division_name_bn?: StringFieldUpdateOperationsInput | string
    division_slug?: StringFieldUpdateOperationsInput | string
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type divisionsUncheckedUpdateManyInput = {
    division_id?: IntFieldUpdateOperationsInput | number
    division_name?: StringFieldUpdateOperationsInput | string
    division_name_bn?: StringFieldUpdateOperationsInput | string
    division_slug?: StringFieldUpdateOperationsInput | string
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type electionsCreateInput = {
    title?: string | null
    total_center?: number | null
    casted_center?: number | null
    party_one_name?: string | null
    party_two_name?: string | null
    party_three_name?: string | null
    party_four_name?: string | null
    party_one_logo?: string | null
    party_two_logo?: string | null
    party_three_logo?: string | null
    party_four_logo?: string | null
    party_one_votes?: number | null
    party_two_votes?: number | null
    party_three_votes?: number | null
    party_four_votes?: number | null
    status?: number | null
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type electionsUncheckedCreateInput = {
    id?: number
    title?: string | null
    total_center?: number | null
    casted_center?: number | null
    party_one_name?: string | null
    party_two_name?: string | null
    party_three_name?: string | null
    party_four_name?: string | null
    party_one_logo?: string | null
    party_two_logo?: string | null
    party_three_logo?: string | null
    party_four_logo?: string | null
    party_one_votes?: number | null
    party_two_votes?: number | null
    party_three_votes?: number | null
    party_four_votes?: number | null
    status?: number | null
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type electionsUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    total_center?: NullableIntFieldUpdateOperationsInput | number | null
    casted_center?: NullableIntFieldUpdateOperationsInput | number | null
    party_one_name?: NullableStringFieldUpdateOperationsInput | string | null
    party_two_name?: NullableStringFieldUpdateOperationsInput | string | null
    party_three_name?: NullableStringFieldUpdateOperationsInput | string | null
    party_four_name?: NullableStringFieldUpdateOperationsInput | string | null
    party_one_logo?: NullableStringFieldUpdateOperationsInput | string | null
    party_two_logo?: NullableStringFieldUpdateOperationsInput | string | null
    party_three_logo?: NullableStringFieldUpdateOperationsInput | string | null
    party_four_logo?: NullableStringFieldUpdateOperationsInput | string | null
    party_one_votes?: NullableIntFieldUpdateOperationsInput | number | null
    party_two_votes?: NullableIntFieldUpdateOperationsInput | number | null
    party_three_votes?: NullableIntFieldUpdateOperationsInput | number | null
    party_four_votes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type electionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    total_center?: NullableIntFieldUpdateOperationsInput | number | null
    casted_center?: NullableIntFieldUpdateOperationsInput | number | null
    party_one_name?: NullableStringFieldUpdateOperationsInput | string | null
    party_two_name?: NullableStringFieldUpdateOperationsInput | string | null
    party_three_name?: NullableStringFieldUpdateOperationsInput | string | null
    party_four_name?: NullableStringFieldUpdateOperationsInput | string | null
    party_one_logo?: NullableStringFieldUpdateOperationsInput | string | null
    party_two_logo?: NullableStringFieldUpdateOperationsInput | string | null
    party_three_logo?: NullableStringFieldUpdateOperationsInput | string | null
    party_four_logo?: NullableStringFieldUpdateOperationsInput | string | null
    party_one_votes?: NullableIntFieldUpdateOperationsInput | number | null
    party_two_votes?: NullableIntFieldUpdateOperationsInput | number | null
    party_three_votes?: NullableIntFieldUpdateOperationsInput | number | null
    party_four_votes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type electionsCreateManyInput = {
    id?: number
    title?: string | null
    total_center?: number | null
    casted_center?: number | null
    party_one_name?: string | null
    party_two_name?: string | null
    party_three_name?: string | null
    party_four_name?: string | null
    party_one_logo?: string | null
    party_two_logo?: string | null
    party_three_logo?: string | null
    party_four_logo?: string | null
    party_one_votes?: number | null
    party_two_votes?: number | null
    party_three_votes?: number | null
    party_four_votes?: number | null
    status?: number | null
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type electionsUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    total_center?: NullableIntFieldUpdateOperationsInput | number | null
    casted_center?: NullableIntFieldUpdateOperationsInput | number | null
    party_one_name?: NullableStringFieldUpdateOperationsInput | string | null
    party_two_name?: NullableStringFieldUpdateOperationsInput | string | null
    party_three_name?: NullableStringFieldUpdateOperationsInput | string | null
    party_four_name?: NullableStringFieldUpdateOperationsInput | string | null
    party_one_logo?: NullableStringFieldUpdateOperationsInput | string | null
    party_two_logo?: NullableStringFieldUpdateOperationsInput | string | null
    party_three_logo?: NullableStringFieldUpdateOperationsInput | string | null
    party_four_logo?: NullableStringFieldUpdateOperationsInput | string | null
    party_one_votes?: NullableIntFieldUpdateOperationsInput | number | null
    party_two_votes?: NullableIntFieldUpdateOperationsInput | number | null
    party_three_votes?: NullableIntFieldUpdateOperationsInput | number | null
    party_four_votes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type electionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    total_center?: NullableIntFieldUpdateOperationsInput | number | null
    casted_center?: NullableIntFieldUpdateOperationsInput | number | null
    party_one_name?: NullableStringFieldUpdateOperationsInput | string | null
    party_two_name?: NullableStringFieldUpdateOperationsInput | string | null
    party_three_name?: NullableStringFieldUpdateOperationsInput | string | null
    party_four_name?: NullableStringFieldUpdateOperationsInput | string | null
    party_one_logo?: NullableStringFieldUpdateOperationsInput | string | null
    party_two_logo?: NullableStringFieldUpdateOperationsInput | string | null
    party_three_logo?: NullableStringFieldUpdateOperationsInput | string | null
    party_four_logo?: NullableStringFieldUpdateOperationsInput | string | null
    party_one_votes?: NullableIntFieldUpdateOperationsInput | number | null
    party_two_votes?: NullableIntFieldUpdateOperationsInput | number | null
    party_three_votes?: NullableIntFieldUpdateOperationsInput | number | null
    party_four_votes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type epaper_pagesCreateInput = {
    epaper_id: number
    img_path?: string | null
    img_thumb_path?: string | null
    img_large_path?: string | null
    page_no: number
    user_id: number
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type epaper_pagesUncheckedCreateInput = {
    id?: number
    epaper_id: number
    img_path?: string | null
    img_thumb_path?: string | null
    img_large_path?: string | null
    page_no: number
    user_id: number
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type epaper_pagesUpdateInput = {
    epaper_id?: IntFieldUpdateOperationsInput | number
    img_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_thumb_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_large_path?: NullableStringFieldUpdateOperationsInput | string | null
    page_no?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type epaper_pagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    epaper_id?: IntFieldUpdateOperationsInput | number
    img_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_thumb_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_large_path?: NullableStringFieldUpdateOperationsInput | string | null
    page_no?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type epaper_pagesCreateManyInput = {
    id?: number
    epaper_id: number
    img_path?: string | null
    img_thumb_path?: string | null
    img_large_path?: string | null
    page_no: number
    user_id: number
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type epaper_pagesUpdateManyMutationInput = {
    epaper_id?: IntFieldUpdateOperationsInput | number
    img_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_thumb_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_large_path?: NullableStringFieldUpdateOperationsInput | string | null
    page_no?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type epaper_pagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    epaper_id?: IntFieldUpdateOperationsInput | number
    img_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_thumb_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_large_path?: NullableStringFieldUpdateOperationsInput | string | null
    page_no?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type epapersCreateInput = {
    paper_date?: Date | string | null
    total_page?: number | null
    meta_keywords?: string | null
    meta_description?: string | null
    og_img_path?: string | null
    user_id?: number | null
    status?: number | null
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type epapersUncheckedCreateInput = {
    id?: number
    paper_date?: Date | string | null
    total_page?: number | null
    meta_keywords?: string | null
    meta_description?: string | null
    og_img_path?: string | null
    user_id?: number | null
    status?: number | null
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type epapersUpdateInput = {
    paper_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_page?: NullableIntFieldUpdateOperationsInput | number | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    og_img_path?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type epapersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    paper_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_page?: NullableIntFieldUpdateOperationsInput | number | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    og_img_path?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type epapersCreateManyInput = {
    id?: number
    paper_date?: Date | string | null
    total_page?: number | null
    meta_keywords?: string | null
    meta_description?: string | null
    og_img_path?: string | null
    user_id?: number | null
    status?: number | null
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type epapersUpdateManyMutationInput = {
    paper_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_page?: NullableIntFieldUpdateOperationsInput | number | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    og_img_path?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type epapersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    paper_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total_page?: NullableIntFieldUpdateOperationsInput | number | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    og_img_path?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type magazine_pagesCreateInput = {
    magazine_id: number
    img_path?: string | null
    img_thumb_path?: string | null
    img_large_path?: string | null
    counter: number
    user_id: number
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type magazine_pagesUncheckedCreateInput = {
    id?: number
    magazine_id: number
    img_path?: string | null
    img_thumb_path?: string | null
    img_large_path?: string | null
    counter: number
    user_id: number
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type magazine_pagesUpdateInput = {
    magazine_id?: IntFieldUpdateOperationsInput | number
    img_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_thumb_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_large_path?: NullableStringFieldUpdateOperationsInput | string | null
    counter?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type magazine_pagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    magazine_id?: IntFieldUpdateOperationsInput | number
    img_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_thumb_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_large_path?: NullableStringFieldUpdateOperationsInput | string | null
    counter?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type magazine_pagesCreateManyInput = {
    id?: number
    magazine_id: number
    img_path?: string | null
    img_thumb_path?: string | null
    img_large_path?: string | null
    counter: number
    user_id: number
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type magazine_pagesUpdateManyMutationInput = {
    magazine_id?: IntFieldUpdateOperationsInput | number
    img_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_thumb_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_large_path?: NullableStringFieldUpdateOperationsInput | string | null
    counter?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type magazine_pagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    magazine_id?: IntFieldUpdateOperationsInput | number
    img_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_thumb_path?: NullableStringFieldUpdateOperationsInput | string | null
    img_large_path?: NullableStringFieldUpdateOperationsInput | string | null
    counter?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type magazinesCreateInput = {
    name?: string | null
    total_page?: number | null
    meta_keywords?: string | null
    meta_description: string
    og_img_path?: string | null
    user_id?: number | null
    status?: number | null
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type magazinesUncheckedCreateInput = {
    id?: number
    name?: string | null
    total_page?: number | null
    meta_keywords?: string | null
    meta_description: string
    og_img_path?: string | null
    user_id?: number | null
    status?: number | null
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type magazinesUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    total_page?: NullableIntFieldUpdateOperationsInput | number | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: StringFieldUpdateOperationsInput | string
    og_img_path?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type magazinesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    total_page?: NullableIntFieldUpdateOperationsInput | number | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: StringFieldUpdateOperationsInput | string
    og_img_path?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type magazinesCreateManyInput = {
    id?: number
    name?: string | null
    total_page?: number | null
    meta_keywords?: string | null
    meta_description: string
    og_img_path?: string | null
    user_id?: number | null
    status?: number | null
    deletable?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type magazinesUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    total_page?: NullableIntFieldUpdateOperationsInput | number | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: StringFieldUpdateOperationsInput | string
    og_img_path?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type magazinesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    total_page?: NullableIntFieldUpdateOperationsInput | number | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: StringFieldUpdateOperationsInput | string
    og_img_path?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    deletable?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type manual_documentsCreateInput = {
    doc_path: string
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type manual_documentsUncheckedCreateInput = {
    doc_id?: number
    doc_path: string
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type manual_documentsUpdateInput = {
    doc_path?: StringFieldUpdateOperationsInput | string
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type manual_documentsUncheckedUpdateInput = {
    doc_id?: IntFieldUpdateOperationsInput | number
    doc_path?: StringFieldUpdateOperationsInput | string
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type manual_documentsCreateManyInput = {
    doc_id?: number
    doc_path: string
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type manual_documentsUpdateManyMutationInput = {
    doc_path?: StringFieldUpdateOperationsInput | string
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type manual_documentsUncheckedUpdateManyInput = {
    doc_id?: IntFieldUpdateOperationsInput | number
    doc_path?: StringFieldUpdateOperationsInput | string
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type manual_photosCreateInput = {
    img_path: string
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type manual_photosUncheckedCreateInput = {
    photo_id?: number
    img_path: string
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type manual_photosUpdateInput = {
    img_path?: StringFieldUpdateOperationsInput | string
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type manual_photosUncheckedUpdateInput = {
    photo_id?: IntFieldUpdateOperationsInput | number
    img_path?: StringFieldUpdateOperationsInput | string
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type manual_photosCreateManyInput = {
    photo_id?: number
    img_path: string
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type manual_photosUpdateManyMutationInput = {
    img_path?: StringFieldUpdateOperationsInput | string
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type manual_photosUncheckedUpdateManyInput = {
    photo_id?: IntFieldUpdateOperationsInput | number
    img_path?: StringFieldUpdateOperationsInput | string
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mis_usersCreateInput = {
    user_type: number
    admin_id?: number | null
    dept_type: number
    user_name: string
    user_name_bn?: string | null
    user_slug: string
    user_initial: string
    user_initial_bn?: string | null
    user_bio?: string | null
    user_bio_bn?: string | null
    img_path?: string | null
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type mis_usersUncheckedCreateInput = {
    user_id?: number
    user_type: number
    admin_id?: number | null
    dept_type: number
    user_name: string
    user_name_bn?: string | null
    user_slug: string
    user_initial: string
    user_initial_bn?: string | null
    user_bio?: string | null
    user_bio_bn?: string | null
    img_path?: string | null
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type mis_usersUpdateInput = {
    user_type?: IntFieldUpdateOperationsInput | number
    admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    dept_type?: IntFieldUpdateOperationsInput | number
    user_name?: StringFieldUpdateOperationsInput | string
    user_name_bn?: NullableStringFieldUpdateOperationsInput | string | null
    user_slug?: StringFieldUpdateOperationsInput | string
    user_initial?: StringFieldUpdateOperationsInput | string
    user_initial_bn?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio_bn?: NullableStringFieldUpdateOperationsInput | string | null
    img_path?: NullableStringFieldUpdateOperationsInput | string | null
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mis_usersUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    user_type?: IntFieldUpdateOperationsInput | number
    admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    dept_type?: IntFieldUpdateOperationsInput | number
    user_name?: StringFieldUpdateOperationsInput | string
    user_name_bn?: NullableStringFieldUpdateOperationsInput | string | null
    user_slug?: StringFieldUpdateOperationsInput | string
    user_initial?: StringFieldUpdateOperationsInput | string
    user_initial_bn?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio_bn?: NullableStringFieldUpdateOperationsInput | string | null
    img_path?: NullableStringFieldUpdateOperationsInput | string | null
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mis_usersCreateManyInput = {
    user_id?: number
    user_type: number
    admin_id?: number | null
    dept_type: number
    user_name: string
    user_name_bn?: string | null
    user_slug: string
    user_initial: string
    user_initial_bn?: string | null
    user_bio?: string | null
    user_bio_bn?: string | null
    img_path?: string | null
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type mis_usersUpdateManyMutationInput = {
    user_type?: IntFieldUpdateOperationsInput | number
    admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    dept_type?: IntFieldUpdateOperationsInput | number
    user_name?: StringFieldUpdateOperationsInput | string
    user_name_bn?: NullableStringFieldUpdateOperationsInput | string | null
    user_slug?: StringFieldUpdateOperationsInput | string
    user_initial?: StringFieldUpdateOperationsInput | string
    user_initial_bn?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio_bn?: NullableStringFieldUpdateOperationsInput | string | null
    img_path?: NullableStringFieldUpdateOperationsInput | string | null
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mis_usersUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    user_type?: IntFieldUpdateOperationsInput | number
    admin_id?: NullableIntFieldUpdateOperationsInput | number | null
    dept_type?: IntFieldUpdateOperationsInput | number
    user_name?: StringFieldUpdateOperationsInput | string
    user_name_bn?: NullableStringFieldUpdateOperationsInput | string | null
    user_slug?: StringFieldUpdateOperationsInput | string
    user_initial?: StringFieldUpdateOperationsInput | string
    user_initial_bn?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio?: NullableStringFieldUpdateOperationsInput | string | null
    user_bio_bn?: NullableStringFieldUpdateOperationsInput | string | null
    img_path?: NullableStringFieldUpdateOperationsInput | string | null
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type monthly_foldersCreateInput = {
    folder_name: string
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type monthly_foldersUncheckedCreateInput = {
    folder_id?: number
    folder_name: string
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type monthly_foldersUpdateInput = {
    folder_name?: StringFieldUpdateOperationsInput | string
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type monthly_foldersUncheckedUpdateInput = {
    folder_id?: IntFieldUpdateOperationsInput | number
    folder_name?: StringFieldUpdateOperationsInput | string
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type monthly_foldersCreateManyInput = {
    folder_id?: number
    folder_name: string
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type monthly_foldersUpdateManyMutationInput = {
    folder_name?: StringFieldUpdateOperationsInput | string
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type monthly_foldersUncheckedUpdateManyInput = {
    folder_id?: IntFieldUpdateOperationsInput | number
    folder_name?: StringFieldUpdateOperationsInput | string
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type p_album_positionsCreateInput = {
    position_name: string
    position_slug: string
    cat_id?: number | null
    special_cat_id?: number | null
    subcat_id?: number | null
    content_ids?: string | null
    total_content?: number | null
    status?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type p_album_positionsUncheckedCreateInput = {
    position_id?: number
    position_name: string
    position_slug: string
    cat_id?: number | null
    special_cat_id?: number | null
    subcat_id?: number | null
    content_ids?: string | null
    total_content?: number | null
    status?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type p_album_positionsUpdateInput = {
    position_name?: StringFieldUpdateOperationsInput | string
    position_slug?: StringFieldUpdateOperationsInput | string
    cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    special_cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    subcat_id?: NullableIntFieldUpdateOperationsInput | number | null
    content_ids?: NullableStringFieldUpdateOperationsInput | string | null
    total_content?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type p_album_positionsUncheckedUpdateInput = {
    position_id?: IntFieldUpdateOperationsInput | number
    position_name?: StringFieldUpdateOperationsInput | string
    position_slug?: StringFieldUpdateOperationsInput | string
    cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    special_cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    subcat_id?: NullableIntFieldUpdateOperationsInput | number | null
    content_ids?: NullableStringFieldUpdateOperationsInput | string | null
    total_content?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type p_album_positionsCreateManyInput = {
    position_id?: number
    position_name: string
    position_slug: string
    cat_id?: number | null
    special_cat_id?: number | null
    subcat_id?: number | null
    content_ids?: string | null
    total_content?: number | null
    status?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type p_album_positionsUpdateManyMutationInput = {
    position_name?: StringFieldUpdateOperationsInput | string
    position_slug?: StringFieldUpdateOperationsInput | string
    cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    special_cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    subcat_id?: NullableIntFieldUpdateOperationsInput | number | null
    content_ids?: NullableStringFieldUpdateOperationsInput | string | null
    total_content?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type p_album_positionsUncheckedUpdateManyInput = {
    position_id?: IntFieldUpdateOperationsInput | number
    position_name?: StringFieldUpdateOperationsInput | string
    position_slug?: StringFieldUpdateOperationsInput | string
    cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    special_cat_id?: NullableIntFieldUpdateOperationsInput | number | null
    subcat_id?: NullableIntFieldUpdateOperationsInput | number | null
    content_ids?: NullableStringFieldUpdateOperationsInput | string | null
    total_content?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type p_albumsCreateInput = {
    cat_id: number
    subcat_id?: number | null
    album_name: string
    short_description?: string | null
    album_details?: string | null
    photographer_name?: string | null
    tag?: string | null
    status?: number
    total_hit?: number
    deletable?: number
    user_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type p_albumsUncheckedCreateInput = {
    album_id?: number
    cat_id: number
    subcat_id?: number | null
    album_name: string
    short_description?: string | null
    album_details?: string | null
    photographer_name?: string | null
    tag?: string | null
    status?: number
    total_hit?: number
    deletable?: number
    user_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type p_albumsUpdateInput = {
    cat_id?: IntFieldUpdateOperationsInput | number
    subcat_id?: NullableIntFieldUpdateOperationsInput | number | null
    album_name?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    album_details?: NullableStringFieldUpdateOperationsInput | string | null
    photographer_name?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    total_hit?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type p_albumsUncheckedUpdateInput = {
    album_id?: IntFieldUpdateOperationsInput | number
    cat_id?: IntFieldUpdateOperationsInput | number
    subcat_id?: NullableIntFieldUpdateOperationsInput | number | null
    album_name?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    album_details?: NullableStringFieldUpdateOperationsInput | string | null
    photographer_name?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    total_hit?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type p_albumsCreateManyInput = {
    album_id?: number
    cat_id: number
    subcat_id?: number | null
    album_name: string
    short_description?: string | null
    album_details?: string | null
    photographer_name?: string | null
    tag?: string | null
    status?: number
    total_hit?: number
    deletable?: number
    user_id: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type p_albumsUpdateManyMutationInput = {
    cat_id?: IntFieldUpdateOperationsInput | number
    subcat_id?: NullableIntFieldUpdateOperationsInput | number | null
    album_name?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    album_details?: NullableStringFieldUpdateOperationsInput | string | null
    photographer_name?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    total_hit?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type p_albumsUncheckedUpdateManyInput = {
    album_id?: IntFieldUpdateOperationsInput | number
    cat_id?: IntFieldUpdateOperationsInput | number
    subcat_id?: NullableIntFieldUpdateOperationsInput | number | null
    album_name?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    album_details?: NullableStringFieldUpdateOperationsInput | string | null
    photographer_name?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    total_hit?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type p_categoriesCreateInput = {
    cat_name: string
    cat_name_bn: string
    cat_slug: string
    cat_meta_keyword?: string | null
    cat_meta_description?: string | null
    cat_position?: number
    top_menu?: number
    footer_menu?: number
    status?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type p_categoriesUncheckedCreateInput = {
    cat_id?: number
    cat_name: string
    cat_name_bn: string
    cat_slug: string
    cat_meta_keyword?: string | null
    cat_meta_description?: string | null
    cat_position?: number
    top_menu?: number
    footer_menu?: number
    status?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type p_categoriesUpdateInput = {
    cat_name?: StringFieldUpdateOperationsInput | string
    cat_name_bn?: StringFieldUpdateOperationsInput | string
    cat_slug?: StringFieldUpdateOperationsInput | string
    cat_meta_keyword?: NullableStringFieldUpdateOperationsInput | string | null
    cat_meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    cat_position?: IntFieldUpdateOperationsInput | number
    top_menu?: IntFieldUpdateOperationsInput | number
    footer_menu?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type p_categoriesUncheckedUpdateInput = {
    cat_id?: IntFieldUpdateOperationsInput | number
    cat_name?: StringFieldUpdateOperationsInput | string
    cat_name_bn?: StringFieldUpdateOperationsInput | string
    cat_slug?: StringFieldUpdateOperationsInput | string
    cat_meta_keyword?: NullableStringFieldUpdateOperationsInput | string | null
    cat_meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    cat_position?: IntFieldUpdateOperationsInput | number
    top_menu?: IntFieldUpdateOperationsInput | number
    footer_menu?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type p_categoriesCreateManyInput = {
    cat_id?: number
    cat_name: string
    cat_name_bn: string
    cat_slug: string
    cat_meta_keyword?: string | null
    cat_meta_description?: string | null
    cat_position?: number
    top_menu?: number
    footer_menu?: number
    status?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type p_categoriesUpdateManyMutationInput = {
    cat_name?: StringFieldUpdateOperationsInput | string
    cat_name_bn?: StringFieldUpdateOperationsInput | string
    cat_slug?: StringFieldUpdateOperationsInput | string
    cat_meta_keyword?: NullableStringFieldUpdateOperationsInput | string | null
    cat_meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    cat_position?: IntFieldUpdateOperationsInput | number
    top_menu?: IntFieldUpdateOperationsInput | number
    footer_menu?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type p_categoriesUncheckedUpdateManyInput = {
    cat_id?: IntFieldUpdateOperationsInput | number
    cat_name?: StringFieldUpdateOperationsInput | string
    cat_name_bn?: StringFieldUpdateOperationsInput | string
    cat_slug?: StringFieldUpdateOperationsInput | string
    cat_meta_keyword?: NullableStringFieldUpdateOperationsInput | string | null
    cat_meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    cat_position?: IntFieldUpdateOperationsInput | number
    top_menu?: IntFieldUpdateOperationsInput | number
    footer_menu?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type p_galleriesCreateInput = {
    album_id: number
    photo: string
    photo_capture?: string | null
    feature_image?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type p_galleriesUncheckedCreateInput = {
    id?: number
    album_id: number
    photo: string
    photo_capture?: string | null
    feature_image?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type p_galleriesUpdateInput = {
    album_id?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
    photo_capture?: NullableStringFieldUpdateOperationsInput | string | null
    feature_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type p_galleriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    album_id?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
    photo_capture?: NullableStringFieldUpdateOperationsInput | string | null
    feature_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type p_galleriesCreateManyInput = {
    id?: number
    album_id: number
    photo: string
    photo_capture?: string | null
    feature_image?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type p_galleriesUpdateManyMutationInput = {
    album_id?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
    photo_capture?: NullableStringFieldUpdateOperationsInput | string | null
    feature_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type p_galleriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    album_id?: IntFieldUpdateOperationsInput | number
    photo?: StringFieldUpdateOperationsInput | string
    photo_capture?: NullableStringFieldUpdateOperationsInput | string | null
    feature_image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type p_subcategoriesCreateInput = {
    cat_id: number
    subcat_name: string
    subcat_name_bn: string
    subcat_slug: string
    subcat_meta_keyword?: string | null
    subcat_meta_description?: string | null
    subcat_position?: number
    status?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type p_subcategoriesUncheckedCreateInput = {
    subcat_id?: number
    cat_id: number
    subcat_name: string
    subcat_name_bn: string
    subcat_slug: string
    subcat_meta_keyword?: string | null
    subcat_meta_description?: string | null
    subcat_position?: number
    status?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type p_subcategoriesUpdateInput = {
    cat_id?: IntFieldUpdateOperationsInput | number
    subcat_name?: StringFieldUpdateOperationsInput | string
    subcat_name_bn?: StringFieldUpdateOperationsInput | string
    subcat_slug?: StringFieldUpdateOperationsInput | string
    subcat_meta_keyword?: NullableStringFieldUpdateOperationsInput | string | null
    subcat_meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    subcat_position?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type p_subcategoriesUncheckedUpdateInput = {
    subcat_id?: IntFieldUpdateOperationsInput | number
    cat_id?: IntFieldUpdateOperationsInput | number
    subcat_name?: StringFieldUpdateOperationsInput | string
    subcat_name_bn?: StringFieldUpdateOperationsInput | string
    subcat_slug?: StringFieldUpdateOperationsInput | string
    subcat_meta_keyword?: NullableStringFieldUpdateOperationsInput | string | null
    subcat_meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    subcat_position?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type p_subcategoriesCreateManyInput = {
    subcat_id?: number
    cat_id: number
    subcat_name: string
    subcat_name_bn: string
    subcat_slug: string
    subcat_meta_keyword?: string | null
    subcat_meta_description?: string | null
    subcat_position?: number
    status?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type p_subcategoriesUpdateManyMutationInput = {
    cat_id?: IntFieldUpdateOperationsInput | number
    subcat_name?: StringFieldUpdateOperationsInput | string
    subcat_name_bn?: StringFieldUpdateOperationsInput | string
    subcat_slug?: StringFieldUpdateOperationsInput | string
    subcat_meta_keyword?: NullableStringFieldUpdateOperationsInput | string | null
    subcat_meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    subcat_position?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type p_subcategoriesUncheckedUpdateManyInput = {
    subcat_id?: IntFieldUpdateOperationsInput | number
    cat_id?: IntFieldUpdateOperationsInput | number
    subcat_name?: StringFieldUpdateOperationsInput | string
    subcat_name_bn?: StringFieldUpdateOperationsInput | string
    subcat_slug?: StringFieldUpdateOperationsInput | string
    subcat_meta_keyword?: NullableStringFieldUpdateOperationsInput | string | null
    subcat_meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    subcat_position?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type site_settingsCreateInput = {
    site_name?: string | null
    favicon?: string | null
    logo?: string | null
    logo_header?: number
    logo_footer?: number
    title?: string | null
    meta_keywords?: string | null
    meta_description?: string | null
    og_image?: string | null
    post_ogimage?: string | null
    social_links?: string | null
    facebook?: string | null
    twitter?: string | null
    google_plus?: string | null
    youtube?: string | null
    instagram?: string | null
    linkedin?: string | null
    editor_meta?: string | null
    address?: string | null
    copyright?: string | null
    show_special?: number
    special_title?: string | null
    special_link?: string | null
    show_live_tv?: number
    show_video_live_tv?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type site_settingsUncheckedCreateInput = {
    id?: number
    site_name?: string | null
    favicon?: string | null
    logo?: string | null
    logo_header?: number
    logo_footer?: number
    title?: string | null
    meta_keywords?: string | null
    meta_description?: string | null
    og_image?: string | null
    post_ogimage?: string | null
    social_links?: string | null
    facebook?: string | null
    twitter?: string | null
    google_plus?: string | null
    youtube?: string | null
    instagram?: string | null
    linkedin?: string | null
    editor_meta?: string | null
    address?: string | null
    copyright?: string | null
    show_special?: number
    special_title?: string | null
    special_link?: string | null
    show_live_tv?: number
    show_video_live_tv?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type site_settingsUpdateInput = {
    site_name?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    logo_header?: IntFieldUpdateOperationsInput | number
    logo_footer?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    og_image?: NullableStringFieldUpdateOperationsInput | string | null
    post_ogimage?: NullableStringFieldUpdateOperationsInput | string | null
    social_links?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    google_plus?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    editor_meta?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    show_special?: IntFieldUpdateOperationsInput | number
    special_title?: NullableStringFieldUpdateOperationsInput | string | null
    special_link?: NullableStringFieldUpdateOperationsInput | string | null
    show_live_tv?: IntFieldUpdateOperationsInput | number
    show_video_live_tv?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type site_settingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_name?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    logo_header?: IntFieldUpdateOperationsInput | number
    logo_footer?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    og_image?: NullableStringFieldUpdateOperationsInput | string | null
    post_ogimage?: NullableStringFieldUpdateOperationsInput | string | null
    social_links?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    google_plus?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    editor_meta?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    show_special?: IntFieldUpdateOperationsInput | number
    special_title?: NullableStringFieldUpdateOperationsInput | string | null
    special_link?: NullableStringFieldUpdateOperationsInput | string | null
    show_live_tv?: IntFieldUpdateOperationsInput | number
    show_video_live_tv?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type site_settingsCreateManyInput = {
    id?: number
    site_name?: string | null
    favicon?: string | null
    logo?: string | null
    logo_header?: number
    logo_footer?: number
    title?: string | null
    meta_keywords?: string | null
    meta_description?: string | null
    og_image?: string | null
    post_ogimage?: string | null
    social_links?: string | null
    facebook?: string | null
    twitter?: string | null
    google_plus?: string | null
    youtube?: string | null
    instagram?: string | null
    linkedin?: string | null
    editor_meta?: string | null
    address?: string | null
    copyright?: string | null
    show_special?: number
    special_title?: string | null
    special_link?: string | null
    show_live_tv?: number
    show_video_live_tv?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type site_settingsUpdateManyMutationInput = {
    site_name?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    logo_header?: IntFieldUpdateOperationsInput | number
    logo_footer?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    og_image?: NullableStringFieldUpdateOperationsInput | string | null
    post_ogimage?: NullableStringFieldUpdateOperationsInput | string | null
    social_links?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    google_plus?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    editor_meta?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    show_special?: IntFieldUpdateOperationsInput | number
    special_title?: NullableStringFieldUpdateOperationsInput | string | null
    special_link?: NullableStringFieldUpdateOperationsInput | string | null
    show_live_tv?: IntFieldUpdateOperationsInput | number
    show_video_live_tv?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type site_settingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_name?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    logo_header?: IntFieldUpdateOperationsInput | number
    logo_footer?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    meta_keywords?: NullableStringFieldUpdateOperationsInput | string | null
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    og_image?: NullableStringFieldUpdateOperationsInput | string | null
    post_ogimage?: NullableStringFieldUpdateOperationsInput | string | null
    social_links?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    google_plus?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    editor_meta?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    copyright?: NullableStringFieldUpdateOperationsInput | string | null
    show_special?: IntFieldUpdateOperationsInput | number
    special_title?: NullableStringFieldUpdateOperationsInput | string | null
    special_link?: NullableStringFieldUpdateOperationsInput | string | null
    show_live_tv?: IntFieldUpdateOperationsInput | number
    show_video_live_tv?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type surveysCreateInput = {
    title: string
    from_date?: Date | string | null
    to_date: Date | string
    ha?: number
    na?: number
    no_comment?: number
    status?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type surveysUncheckedCreateInput = {
    survey_id?: number
    title: string
    from_date?: Date | string | null
    to_date: Date | string
    ha?: number
    na?: number
    no_comment?: number
    status?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type surveysUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    from_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    to_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ha?: IntFieldUpdateOperationsInput | number
    na?: IntFieldUpdateOperationsInput | number
    no_comment?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type surveysUncheckedUpdateInput = {
    survey_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    from_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    to_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ha?: IntFieldUpdateOperationsInput | number
    na?: IntFieldUpdateOperationsInput | number
    no_comment?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type surveysCreateManyInput = {
    survey_id?: number
    title: string
    from_date?: Date | string | null
    to_date: Date | string
    ha?: number
    na?: number
    no_comment?: number
    status?: number
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type surveysUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    from_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    to_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ha?: IntFieldUpdateOperationsInput | number
    na?: IntFieldUpdateOperationsInput | number
    no_comment?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type surveysUncheckedUpdateManyInput = {
    survey_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    from_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    to_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ha?: IntFieldUpdateOperationsInput | number
    na?: IntFieldUpdateOperationsInput | number
    no_comment?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type upozillasCreateInput = {
    district_id: number
    division_id: number
    upozilla_name: string
    upozilla_name_bn: string
    upozilla_title?: string | null
    upozilla_slug: string
    meta_description?: string | null
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type upozillasUncheckedCreateInput = {
    upozilla_id?: number
    district_id: number
    division_id: number
    upozilla_name: string
    upozilla_name_bn: string
    upozilla_title?: string | null
    upozilla_slug: string
    meta_description?: string | null
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type upozillasUpdateInput = {
    district_id?: IntFieldUpdateOperationsInput | number
    division_id?: IntFieldUpdateOperationsInput | number
    upozilla_name?: StringFieldUpdateOperationsInput | string
    upozilla_name_bn?: StringFieldUpdateOperationsInput | string
    upozilla_title?: NullableStringFieldUpdateOperationsInput | string | null
    upozilla_slug?: StringFieldUpdateOperationsInput | string
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type upozillasUncheckedUpdateInput = {
    upozilla_id?: IntFieldUpdateOperationsInput | number
    district_id?: IntFieldUpdateOperationsInput | number
    division_id?: IntFieldUpdateOperationsInput | number
    upozilla_name?: StringFieldUpdateOperationsInput | string
    upozilla_name_bn?: StringFieldUpdateOperationsInput | string
    upozilla_title?: NullableStringFieldUpdateOperationsInput | string | null
    upozilla_slug?: StringFieldUpdateOperationsInput | string
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type upozillasCreateManyInput = {
    upozilla_id?: number
    district_id: number
    division_id: number
    upozilla_name: string
    upozilla_name_bn: string
    upozilla_title?: string | null
    upozilla_slug: string
    meta_description?: string | null
    deletable?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type upozillasUpdateManyMutationInput = {
    district_id?: IntFieldUpdateOperationsInput | number
    division_id?: IntFieldUpdateOperationsInput | number
    upozilla_name?: StringFieldUpdateOperationsInput | string
    upozilla_name_bn?: StringFieldUpdateOperationsInput | string
    upozilla_title?: NullableStringFieldUpdateOperationsInput | string | null
    upozilla_slug?: StringFieldUpdateOperationsInput | string
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type upozillasUncheckedUpdateManyInput = {
    upozilla_id?: IntFieldUpdateOperationsInput | number
    district_id?: IntFieldUpdateOperationsInput | number
    division_id?: IntFieldUpdateOperationsInput | number
    upozilla_name?: StringFieldUpdateOperationsInput | string
    upozilla_name_bn?: StringFieldUpdateOperationsInput | string
    upozilla_title?: NullableStringFieldUpdateOperationsInput | string | null
    upozilla_slug?: StringFieldUpdateOperationsInput | string
    meta_description?: NullableStringFieldUpdateOperationsInput | string | null
    deletable?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateInput = {
    name: string
    designation?: string | null
    username: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    two_factor_secret?: string | null
    two_factor_recovery_codes?: string | null
    role: number
    bn_cat_ids?: string | null
    status?: number
    visibility?: number
    deletable?: number
    remember_token?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usersUncheckedCreateInput = {
    id?: number
    name: string
    designation?: string | null
    username: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    two_factor_secret?: string | null
    two_factor_recovery_codes?: string | null
    role: number
    bn_cat_ids?: string | null
    status?: number
    visibility?: number
    deletable?: number
    remember_token?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usersUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_recovery_codes?: NullableStringFieldUpdateOperationsInput | string | null
    role?: IntFieldUpdateOperationsInput | number
    bn_cat_ids?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    visibility?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_recovery_codes?: NullableStringFieldUpdateOperationsInput | string | null
    role?: IntFieldUpdateOperationsInput | number
    bn_cat_ids?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    visibility?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateManyInput = {
    id?: number
    name: string
    designation?: string | null
    username: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    two_factor_secret?: string | null
    two_factor_recovery_codes?: string | null
    role: number
    bn_cat_ids?: string | null
    status?: number
    visibility?: number
    deletable?: number
    remember_token?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usersUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_recovery_codes?: NullableStringFieldUpdateOperationsInput | string | null
    role?: IntFieldUpdateOperationsInput | number
    bn_cat_ids?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    visibility?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_recovery_codes?: NullableStringFieldUpdateOperationsInput | string | null
    role?: IntFieldUpdateOperationsInput | number
    bn_cat_ids?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    visibility?: IntFieldUpdateOperationsInput | number
    deletable?: IntFieldUpdateOperationsInput | number
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type counterCreateInput = {
    counter_name: string
    counter_time: string
    time?: string | null
    date?: string | null
    status?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type counterUncheckedCreateInput = {
    id?: number
    counter_name: string
    counter_time: string
    time?: string | null
    date?: string | null
    status?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type counterUpdateInput = {
    counter_name?: StringFieldUpdateOperationsInput | string
    counter_time?: StringFieldUpdateOperationsInput | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type counterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    counter_name?: StringFieldUpdateOperationsInput | string
    counter_time?: StringFieldUpdateOperationsInput | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type counterCreateManyInput = {
    id?: number
    counter_name: string
    counter_time: string
    time?: string | null
    date?: string | null
    status?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type counterUpdateManyMutationInput = {
    counter_name?: StringFieldUpdateOperationsInput | string
    counter_time?: StringFieldUpdateOperationsInput | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type counterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    counter_name?: StringFieldUpdateOperationsInput | string
    counter_time?: StringFieldUpdateOperationsInput | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type migrationsCreateInput = {
    migration: string
    batch: number
  }

  export type migrationsUncheckedCreateInput = {
    id?: number
    migration: string
    batch: number
  }

  export type migrationsUpdateInput = {
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type migrationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type migrationsCreateManyInput = {
    id?: number
    migration: string
    batch: number
  }

  export type migrationsUpdateManyMutationInput = {
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type migrationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type authorsCountOrderByAggregateInput = {
    author_id?: SortOrder
    author_type?: SortOrder
    author_name?: SortOrder
    author_name_bn?: SortOrder
    author_slug?: SortOrder
    author_initial?: SortOrder
    author_initial_bn?: SortOrder
    author_bio?: SortOrder
    author_bio_bn?: SortOrder
    img_path?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type authorsAvgOrderByAggregateInput = {
    author_id?: SortOrder
    author_type?: SortOrder
    deletable?: SortOrder
  }

  export type authorsMaxOrderByAggregateInput = {
    author_id?: SortOrder
    author_type?: SortOrder
    author_name?: SortOrder
    author_name_bn?: SortOrder
    author_slug?: SortOrder
    author_initial?: SortOrder
    author_initial_bn?: SortOrder
    author_bio?: SortOrder
    author_bio_bn?: SortOrder
    img_path?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type authorsMinOrderByAggregateInput = {
    author_id?: SortOrder
    author_type?: SortOrder
    author_name?: SortOrder
    author_name_bn?: SortOrder
    author_slug?: SortOrder
    author_initial?: SortOrder
    author_initial_bn?: SortOrder
    author_bio?: SortOrder
    author_bio_bn?: SortOrder
    img_path?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type authorsSumOrderByAggregateInput = {
    author_id?: SortOrder
    author_type?: SortOrder
    deletable?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type bn_adsCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    page?: SortOrder
    position?: SortOrder
    dfp_header_code?: SortOrder
    code?: SortOrder
    desktop_image_path?: SortOrder
    mobile_image_path?: SortOrder
    external_link?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_adsAvgOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    page?: SortOrder
    position?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type bn_adsMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    page?: SortOrder
    position?: SortOrder
    dfp_header_code?: SortOrder
    code?: SortOrder
    desktop_image_path?: SortOrder
    mobile_image_path?: SortOrder
    external_link?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_adsMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    page?: SortOrder
    position?: SortOrder
    dfp_header_code?: SortOrder
    code?: SortOrder
    desktop_image_path?: SortOrder
    mobile_image_path?: SortOrder
    external_link?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_adsSumOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    page?: SortOrder
    position?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type bn_breaking_newsCountOrderByAggregateInput = {
    id?: SortOrder
    news_title?: SortOrder
    news_link?: SortOrder
    position?: SortOrder
    hours?: SortOrder
    user_id?: SortOrder
    expired_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_breaking_newsAvgOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    hours?: SortOrder
    user_id?: SortOrder
  }

  export type bn_breaking_newsMaxOrderByAggregateInput = {
    id?: SortOrder
    news_title?: SortOrder
    news_link?: SortOrder
    position?: SortOrder
    hours?: SortOrder
    user_id?: SortOrder
    expired_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_breaking_newsMinOrderByAggregateInput = {
    id?: SortOrder
    news_title?: SortOrder
    news_link?: SortOrder
    position?: SortOrder
    hours?: SortOrder
    user_id?: SortOrder
    expired_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_breaking_newsSumOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    hours?: SortOrder
    user_id?: SortOrder
  }

  export type bn_categoriesCountOrderByAggregateInput = {
    cat_id?: SortOrder
    cat_type?: SortOrder
    cat_name?: SortOrder
    cat_name_bn?: SortOrder
    cat_slug?: SortOrder
    cat_title?: SortOrder
    cat_meta_keyword?: SortOrder
    cat_meta_description?: SortOrder
    cat_position?: SortOrder
    top_menu?: SortOrder
    footer_menu?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_categoriesAvgOrderByAggregateInput = {
    cat_id?: SortOrder
    cat_type?: SortOrder
    cat_position?: SortOrder
    top_menu?: SortOrder
    footer_menu?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type bn_categoriesMaxOrderByAggregateInput = {
    cat_id?: SortOrder
    cat_type?: SortOrder
    cat_name?: SortOrder
    cat_name_bn?: SortOrder
    cat_slug?: SortOrder
    cat_title?: SortOrder
    cat_meta_keyword?: SortOrder
    cat_meta_description?: SortOrder
    cat_position?: SortOrder
    top_menu?: SortOrder
    footer_menu?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_categoriesMinOrderByAggregateInput = {
    cat_id?: SortOrder
    cat_type?: SortOrder
    cat_name?: SortOrder
    cat_name_bn?: SortOrder
    cat_slug?: SortOrder
    cat_title?: SortOrder
    cat_meta_keyword?: SortOrder
    cat_meta_description?: SortOrder
    cat_position?: SortOrder
    top_menu?: SortOrder
    footer_menu?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_categoriesSumOrderByAggregateInput = {
    cat_id?: SortOrder
    cat_type?: SortOrder
    cat_position?: SortOrder
    top_menu?: SortOrder
    footer_menu?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type bn_content_positionsCountOrderByAggregateInput = {
    position_id?: SortOrder
    position_name?: SortOrder
    position_slug?: SortOrder
    cat_id?: SortOrder
    special_cat_id?: SortOrder
    subcat_id?: SortOrder
    content_ids?: SortOrder
    total_content?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_content_positionsAvgOrderByAggregateInput = {
    position_id?: SortOrder
    cat_id?: SortOrder
    special_cat_id?: SortOrder
    subcat_id?: SortOrder
    total_content?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type bn_content_positionsMaxOrderByAggregateInput = {
    position_id?: SortOrder
    position_name?: SortOrder
    position_slug?: SortOrder
    cat_id?: SortOrder
    special_cat_id?: SortOrder
    subcat_id?: SortOrder
    content_ids?: SortOrder
    total_content?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_content_positionsMinOrderByAggregateInput = {
    position_id?: SortOrder
    position_name?: SortOrder
    position_slug?: SortOrder
    cat_id?: SortOrder
    special_cat_id?: SortOrder
    subcat_id?: SortOrder
    content_ids?: SortOrder
    total_content?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_content_positionsSumOrderByAggregateInput = {
    position_id?: SortOrder
    cat_id?: SortOrder
    special_cat_id?: SortOrder
    subcat_id?: SortOrder
    total_content?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type bn_contentsCountOrderByAggregateInput = {
    content_id?: SortOrder
    content_type?: SortOrder
    cat_id?: SortOrder
    subcat_id?: SortOrder
    special_cat_id?: SortOrder
    country_id?: SortOrder
    division_id?: SortOrder
    district_id?: SortOrder
    upozilla_id?: SortOrder
    content_heading?: SortOrder
    content_sub_heading?: SortOrder
    author_slugs?: SortOrder
    author_name?: SortOrder
    content_brief?: SortOrder
    content_details?: SortOrder
    img_xs_path?: SortOrder
    img_sm_path?: SortOrder
    img_sm_caption?: SortOrder
    img_bg_path?: SortOrder
    og_image?: SortOrder
    img_bg_caption?: SortOrder
    related_ids?: SortOrder
    photo_ids?: SortOrder
    video_type?: SortOrder
    video_id?: SortOrder
    uploader_id?: SortOrder
    reporter_id?: SortOrder
    tags?: SortOrder
    meta_keywords?: SortOrder
    timeline_tag?: SortOrder
    podcast_id?: SortOrder
    status?: SortOrder
    scroll?: SortOrder
    total_hit?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_contentsAvgOrderByAggregateInput = {
    content_id?: SortOrder
    content_type?: SortOrder
    cat_id?: SortOrder
    subcat_id?: SortOrder
    special_cat_id?: SortOrder
    country_id?: SortOrder
    division_id?: SortOrder
    district_id?: SortOrder
    upozilla_id?: SortOrder
    video_type?: SortOrder
    uploader_id?: SortOrder
    reporter_id?: SortOrder
    status?: SortOrder
    scroll?: SortOrder
    total_hit?: SortOrder
    deletable?: SortOrder
  }

  export type bn_contentsMaxOrderByAggregateInput = {
    content_id?: SortOrder
    content_type?: SortOrder
    cat_id?: SortOrder
    subcat_id?: SortOrder
    special_cat_id?: SortOrder
    country_id?: SortOrder
    division_id?: SortOrder
    district_id?: SortOrder
    upozilla_id?: SortOrder
    content_heading?: SortOrder
    content_sub_heading?: SortOrder
    author_slugs?: SortOrder
    author_name?: SortOrder
    content_brief?: SortOrder
    content_details?: SortOrder
    img_xs_path?: SortOrder
    img_sm_path?: SortOrder
    img_sm_caption?: SortOrder
    img_bg_path?: SortOrder
    og_image?: SortOrder
    img_bg_caption?: SortOrder
    related_ids?: SortOrder
    photo_ids?: SortOrder
    video_type?: SortOrder
    video_id?: SortOrder
    uploader_id?: SortOrder
    reporter_id?: SortOrder
    tags?: SortOrder
    meta_keywords?: SortOrder
    timeline_tag?: SortOrder
    podcast_id?: SortOrder
    status?: SortOrder
    scroll?: SortOrder
    total_hit?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_contentsMinOrderByAggregateInput = {
    content_id?: SortOrder
    content_type?: SortOrder
    cat_id?: SortOrder
    subcat_id?: SortOrder
    special_cat_id?: SortOrder
    country_id?: SortOrder
    division_id?: SortOrder
    district_id?: SortOrder
    upozilla_id?: SortOrder
    content_heading?: SortOrder
    content_sub_heading?: SortOrder
    author_slugs?: SortOrder
    author_name?: SortOrder
    content_brief?: SortOrder
    content_details?: SortOrder
    img_xs_path?: SortOrder
    img_sm_path?: SortOrder
    img_sm_caption?: SortOrder
    img_bg_path?: SortOrder
    og_image?: SortOrder
    img_bg_caption?: SortOrder
    related_ids?: SortOrder
    photo_ids?: SortOrder
    video_type?: SortOrder
    video_id?: SortOrder
    uploader_id?: SortOrder
    reporter_id?: SortOrder
    tags?: SortOrder
    meta_keywords?: SortOrder
    timeline_tag?: SortOrder
    podcast_id?: SortOrder
    status?: SortOrder
    scroll?: SortOrder
    total_hit?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_contentsSumOrderByAggregateInput = {
    content_id?: SortOrder
    content_type?: SortOrder
    cat_id?: SortOrder
    subcat_id?: SortOrder
    special_cat_id?: SortOrder
    country_id?: SortOrder
    division_id?: SortOrder
    district_id?: SortOrder
    upozilla_id?: SortOrder
    video_type?: SortOrder
    uploader_id?: SortOrder
    reporter_id?: SortOrder
    status?: SortOrder
    scroll?: SortOrder
    total_hit?: SortOrder
    deletable?: SortOrder
  }

  export type bn_mobile_adsCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    page?: SortOrder
    position?: SortOrder
    dfp_header_code?: SortOrder
    code?: SortOrder
    mobile_image_path?: SortOrder
    external_link?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_mobile_adsAvgOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    page?: SortOrder
    position?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type bn_mobile_adsMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    page?: SortOrder
    position?: SortOrder
    dfp_header_code?: SortOrder
    code?: SortOrder
    mobile_image_path?: SortOrder
    external_link?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_mobile_adsMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    page?: SortOrder
    position?: SortOrder
    dfp_header_code?: SortOrder
    code?: SortOrder
    mobile_image_path?: SortOrder
    external_link?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_mobile_adsSumOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    page?: SortOrder
    position?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type bn_position_fixedCountOrderByAggregateInput = {
    id?: SortOrder
    position_number?: SortOrder
    news_id?: SortOrder
    is_fixed?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_position_fixedAvgOrderByAggregateInput = {
    id?: SortOrder
    position_number?: SortOrder
    news_id?: SortOrder
    is_fixed?: SortOrder
  }

  export type bn_position_fixedMaxOrderByAggregateInput = {
    id?: SortOrder
    position_number?: SortOrder
    news_id?: SortOrder
    is_fixed?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_position_fixedMinOrderByAggregateInput = {
    id?: SortOrder
    position_number?: SortOrder
    news_id?: SortOrder
    is_fixed?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_position_fixedSumOrderByAggregateInput = {
    id?: SortOrder
    position_number?: SortOrder
    news_id?: SortOrder
    is_fixed?: SortOrder
  }

  export type bn_subcategoriesCountOrderByAggregateInput = {
    subcat_id?: SortOrder
    cat_id?: SortOrder
    subcat_name?: SortOrder
    subcat_name_bn?: SortOrder
    subcat_slug?: SortOrder
    subcat_meta_keyword?: SortOrder
    subcat_meta_description?: SortOrder
    subcat_position?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_subcategoriesAvgOrderByAggregateInput = {
    subcat_id?: SortOrder
    cat_id?: SortOrder
    subcat_position?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type bn_subcategoriesMaxOrderByAggregateInput = {
    subcat_id?: SortOrder
    cat_id?: SortOrder
    subcat_name?: SortOrder
    subcat_name_bn?: SortOrder
    subcat_slug?: SortOrder
    subcat_meta_keyword?: SortOrder
    subcat_meta_description?: SortOrder
    subcat_position?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_subcategoriesMinOrderByAggregateInput = {
    subcat_id?: SortOrder
    cat_id?: SortOrder
    subcat_name?: SortOrder
    subcat_name_bn?: SortOrder
    subcat_slug?: SortOrder
    subcat_meta_keyword?: SortOrder
    subcat_meta_description?: SortOrder
    subcat_position?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_subcategoriesSumOrderByAggregateInput = {
    subcat_id?: SortOrder
    cat_id?: SortOrder
    subcat_position?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type bn_tagsCountOrderByAggregateInput = {
    tag_id?: SortOrder
    tag_type?: SortOrder
    tag_name?: SortOrder
    tag_slug?: SortOrder
    description?: SortOrder
    img_path?: SortOrder
    approval?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_tagsAvgOrderByAggregateInput = {
    tag_id?: SortOrder
    tag_type?: SortOrder
    approval?: SortOrder
    deletable?: SortOrder
  }

  export type bn_tagsMaxOrderByAggregateInput = {
    tag_id?: SortOrder
    tag_type?: SortOrder
    tag_name?: SortOrder
    tag_slug?: SortOrder
    description?: SortOrder
    img_path?: SortOrder
    approval?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_tagsMinOrderByAggregateInput = {
    tag_id?: SortOrder
    tag_type?: SortOrder
    tag_name?: SortOrder
    tag_slug?: SortOrder
    description?: SortOrder
    img_path?: SortOrder
    approval?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_tagsSumOrderByAggregateInput = {
    tag_id?: SortOrder
    tag_type?: SortOrder
    approval?: SortOrder
    deletable?: SortOrder
  }

  export type bn_video_categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    name_bn?: SortOrder
    meta_keywords?: SortOrder
    meta_description?: SortOrder
    og_img_path?: SortOrder
    position?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_video_categoriesAvgOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type bn_video_categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    name_bn?: SortOrder
    meta_keywords?: SortOrder
    meta_description?: SortOrder
    og_img_path?: SortOrder
    position?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_video_categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    name_bn?: SortOrder
    meta_keywords?: SortOrder
    meta_description?: SortOrder
    og_img_path?: SortOrder
    position?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_video_categoriesSumOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type bn_video_positionsCountOrderByAggregateInput = {
    position_id?: SortOrder
    position_name?: SortOrder
    cat_id?: SortOrder
    subcat_id?: SortOrder
    video_ids?: SortOrder
    total_video?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_video_positionsAvgOrderByAggregateInput = {
    position_id?: SortOrder
    cat_id?: SortOrder
    subcat_id?: SortOrder
    total_video?: SortOrder
    deletable?: SortOrder
  }

  export type bn_video_positionsMaxOrderByAggregateInput = {
    position_id?: SortOrder
    position_name?: SortOrder
    cat_id?: SortOrder
    subcat_id?: SortOrder
    video_ids?: SortOrder
    total_video?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_video_positionsMinOrderByAggregateInput = {
    position_id?: SortOrder
    position_name?: SortOrder
    cat_id?: SortOrder
    subcat_id?: SortOrder
    video_ids?: SortOrder
    total_video?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_video_positionsSumOrderByAggregateInput = {
    position_id?: SortOrder
    cat_id?: SortOrder
    subcat_id?: SortOrder
    total_video?: SortOrder
    deletable?: SortOrder
  }

  export type bn_videosCountOrderByAggregateInput = {
    id?: SortOrder
    cat_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    code?: SortOrder
    img_bg_path?: SortOrder
    img_sm_path?: SortOrder
    img_xs_path?: SortOrder
    link?: SortOrder
    meta_keywords?: SortOrder
    meta_description?: SortOrder
    user_id?: SortOrder
    target?: SortOrder
    is_live?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_videosAvgOrderByAggregateInput = {
    id?: SortOrder
    cat_id?: SortOrder
    type?: SortOrder
    user_id?: SortOrder
    target?: SortOrder
    is_live?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type bn_videosMaxOrderByAggregateInput = {
    id?: SortOrder
    cat_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    code?: SortOrder
    img_bg_path?: SortOrder
    img_sm_path?: SortOrder
    img_xs_path?: SortOrder
    link?: SortOrder
    meta_keywords?: SortOrder
    meta_description?: SortOrder
    user_id?: SortOrder
    target?: SortOrder
    is_live?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_videosMinOrderByAggregateInput = {
    id?: SortOrder
    cat_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    code?: SortOrder
    img_bg_path?: SortOrder
    img_sm_path?: SortOrder
    img_xs_path?: SortOrder
    link?: SortOrder
    meta_keywords?: SortOrder
    meta_description?: SortOrder
    user_id?: SortOrder
    target?: SortOrder
    is_live?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bn_videosSumOrderByAggregateInput = {
    id?: SortOrder
    cat_id?: SortOrder
    type?: SortOrder
    user_id?: SortOrder
    target?: SortOrder
    is_live?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type countriesCountOrderByAggregateInput = {
    country_id?: SortOrder
    country_name?: SortOrder
    country_name_bn?: SortOrder
    country_slug?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type countriesAvgOrderByAggregateInput = {
    country_id?: SortOrder
    deletable?: SortOrder
  }

  export type countriesMaxOrderByAggregateInput = {
    country_id?: SortOrder
    country_name?: SortOrder
    country_name_bn?: SortOrder
    country_slug?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type countriesMinOrderByAggregateInput = {
    country_id?: SortOrder
    country_name?: SortOrder
    country_name_bn?: SortOrder
    country_slug?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type countriesSumOrderByAggregateInput = {
    country_id?: SortOrder
    deletable?: SortOrder
  }

  export type districtsCountOrderByAggregateInput = {
    district_id?: SortOrder
    division_id?: SortOrder
    district_name?: SortOrder
    district_name_bn?: SortOrder
    district_slug?: SortOrder
    district_title?: SortOrder
    meta_description?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type districtsAvgOrderByAggregateInput = {
    district_id?: SortOrder
    division_id?: SortOrder
    deletable?: SortOrder
  }

  export type districtsMaxOrderByAggregateInput = {
    district_id?: SortOrder
    division_id?: SortOrder
    district_name?: SortOrder
    district_name_bn?: SortOrder
    district_slug?: SortOrder
    district_title?: SortOrder
    meta_description?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type districtsMinOrderByAggregateInput = {
    district_id?: SortOrder
    division_id?: SortOrder
    district_name?: SortOrder
    district_name_bn?: SortOrder
    district_slug?: SortOrder
    district_title?: SortOrder
    meta_description?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type districtsSumOrderByAggregateInput = {
    district_id?: SortOrder
    division_id?: SortOrder
    deletable?: SortOrder
  }

  export type divisionsCountOrderByAggregateInput = {
    division_id?: SortOrder
    division_name?: SortOrder
    division_name_bn?: SortOrder
    division_slug?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type divisionsAvgOrderByAggregateInput = {
    division_id?: SortOrder
    deletable?: SortOrder
  }

  export type divisionsMaxOrderByAggregateInput = {
    division_id?: SortOrder
    division_name?: SortOrder
    division_name_bn?: SortOrder
    division_slug?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type divisionsMinOrderByAggregateInput = {
    division_id?: SortOrder
    division_name?: SortOrder
    division_name_bn?: SortOrder
    division_slug?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type divisionsSumOrderByAggregateInput = {
    division_id?: SortOrder
    deletable?: SortOrder
  }

  export type electionsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    total_center?: SortOrder
    casted_center?: SortOrder
    party_one_name?: SortOrder
    party_two_name?: SortOrder
    party_three_name?: SortOrder
    party_four_name?: SortOrder
    party_one_logo?: SortOrder
    party_two_logo?: SortOrder
    party_three_logo?: SortOrder
    party_four_logo?: SortOrder
    party_one_votes?: SortOrder
    party_two_votes?: SortOrder
    party_three_votes?: SortOrder
    party_four_votes?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type electionsAvgOrderByAggregateInput = {
    id?: SortOrder
    total_center?: SortOrder
    casted_center?: SortOrder
    party_one_votes?: SortOrder
    party_two_votes?: SortOrder
    party_three_votes?: SortOrder
    party_four_votes?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type electionsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    total_center?: SortOrder
    casted_center?: SortOrder
    party_one_name?: SortOrder
    party_two_name?: SortOrder
    party_three_name?: SortOrder
    party_four_name?: SortOrder
    party_one_logo?: SortOrder
    party_two_logo?: SortOrder
    party_three_logo?: SortOrder
    party_four_logo?: SortOrder
    party_one_votes?: SortOrder
    party_two_votes?: SortOrder
    party_three_votes?: SortOrder
    party_four_votes?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type electionsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    total_center?: SortOrder
    casted_center?: SortOrder
    party_one_name?: SortOrder
    party_two_name?: SortOrder
    party_three_name?: SortOrder
    party_four_name?: SortOrder
    party_one_logo?: SortOrder
    party_two_logo?: SortOrder
    party_three_logo?: SortOrder
    party_four_logo?: SortOrder
    party_one_votes?: SortOrder
    party_two_votes?: SortOrder
    party_three_votes?: SortOrder
    party_four_votes?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type electionsSumOrderByAggregateInput = {
    id?: SortOrder
    total_center?: SortOrder
    casted_center?: SortOrder
    party_one_votes?: SortOrder
    party_two_votes?: SortOrder
    party_three_votes?: SortOrder
    party_four_votes?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type epaper_pagesCountOrderByAggregateInput = {
    id?: SortOrder
    epaper_id?: SortOrder
    img_path?: SortOrder
    img_thumb_path?: SortOrder
    img_large_path?: SortOrder
    page_no?: SortOrder
    user_id?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type epaper_pagesAvgOrderByAggregateInput = {
    id?: SortOrder
    epaper_id?: SortOrder
    page_no?: SortOrder
    user_id?: SortOrder
    deletable?: SortOrder
  }

  export type epaper_pagesMaxOrderByAggregateInput = {
    id?: SortOrder
    epaper_id?: SortOrder
    img_path?: SortOrder
    img_thumb_path?: SortOrder
    img_large_path?: SortOrder
    page_no?: SortOrder
    user_id?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type epaper_pagesMinOrderByAggregateInput = {
    id?: SortOrder
    epaper_id?: SortOrder
    img_path?: SortOrder
    img_thumb_path?: SortOrder
    img_large_path?: SortOrder
    page_no?: SortOrder
    user_id?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type epaper_pagesSumOrderByAggregateInput = {
    id?: SortOrder
    epaper_id?: SortOrder
    page_no?: SortOrder
    user_id?: SortOrder
    deletable?: SortOrder
  }

  export type epapersCountOrderByAggregateInput = {
    id?: SortOrder
    paper_date?: SortOrder
    total_page?: SortOrder
    meta_keywords?: SortOrder
    meta_description?: SortOrder
    og_img_path?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type epapersAvgOrderByAggregateInput = {
    id?: SortOrder
    total_page?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type epapersMaxOrderByAggregateInput = {
    id?: SortOrder
    paper_date?: SortOrder
    total_page?: SortOrder
    meta_keywords?: SortOrder
    meta_description?: SortOrder
    og_img_path?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type epapersMinOrderByAggregateInput = {
    id?: SortOrder
    paper_date?: SortOrder
    total_page?: SortOrder
    meta_keywords?: SortOrder
    meta_description?: SortOrder
    og_img_path?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type epapersSumOrderByAggregateInput = {
    id?: SortOrder
    total_page?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type magazine_pagesCountOrderByAggregateInput = {
    id?: SortOrder
    magazine_id?: SortOrder
    img_path?: SortOrder
    img_thumb_path?: SortOrder
    img_large_path?: SortOrder
    counter?: SortOrder
    user_id?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type magazine_pagesAvgOrderByAggregateInput = {
    id?: SortOrder
    magazine_id?: SortOrder
    counter?: SortOrder
    user_id?: SortOrder
    deletable?: SortOrder
  }

  export type magazine_pagesMaxOrderByAggregateInput = {
    id?: SortOrder
    magazine_id?: SortOrder
    img_path?: SortOrder
    img_thumb_path?: SortOrder
    img_large_path?: SortOrder
    counter?: SortOrder
    user_id?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type magazine_pagesMinOrderByAggregateInput = {
    id?: SortOrder
    magazine_id?: SortOrder
    img_path?: SortOrder
    img_thumb_path?: SortOrder
    img_large_path?: SortOrder
    counter?: SortOrder
    user_id?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type magazine_pagesSumOrderByAggregateInput = {
    id?: SortOrder
    magazine_id?: SortOrder
    counter?: SortOrder
    user_id?: SortOrder
    deletable?: SortOrder
  }

  export type magazinesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    total_page?: SortOrder
    meta_keywords?: SortOrder
    meta_description?: SortOrder
    og_img_path?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type magazinesAvgOrderByAggregateInput = {
    id?: SortOrder
    total_page?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type magazinesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    total_page?: SortOrder
    meta_keywords?: SortOrder
    meta_description?: SortOrder
    og_img_path?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type magazinesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    total_page?: SortOrder
    meta_keywords?: SortOrder
    meta_description?: SortOrder
    og_img_path?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type magazinesSumOrderByAggregateInput = {
    id?: SortOrder
    total_page?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type manual_documentsCountOrderByAggregateInput = {
    doc_id?: SortOrder
    doc_path?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type manual_documentsAvgOrderByAggregateInput = {
    doc_id?: SortOrder
    deletable?: SortOrder
  }

  export type manual_documentsMaxOrderByAggregateInput = {
    doc_id?: SortOrder
    doc_path?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type manual_documentsMinOrderByAggregateInput = {
    doc_id?: SortOrder
    doc_path?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type manual_documentsSumOrderByAggregateInput = {
    doc_id?: SortOrder
    deletable?: SortOrder
  }

  export type manual_photosCountOrderByAggregateInput = {
    photo_id?: SortOrder
    img_path?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type manual_photosAvgOrderByAggregateInput = {
    photo_id?: SortOrder
    deletable?: SortOrder
  }

  export type manual_photosMaxOrderByAggregateInput = {
    photo_id?: SortOrder
    img_path?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type manual_photosMinOrderByAggregateInput = {
    photo_id?: SortOrder
    img_path?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type manual_photosSumOrderByAggregateInput = {
    photo_id?: SortOrder
    deletable?: SortOrder
  }

  export type mis_usersCountOrderByAggregateInput = {
    user_id?: SortOrder
    user_type?: SortOrder
    admin_id?: SortOrder
    dept_type?: SortOrder
    user_name?: SortOrder
    user_name_bn?: SortOrder
    user_slug?: SortOrder
    user_initial?: SortOrder
    user_initial_bn?: SortOrder
    user_bio?: SortOrder
    user_bio_bn?: SortOrder
    img_path?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type mis_usersAvgOrderByAggregateInput = {
    user_id?: SortOrder
    user_type?: SortOrder
    admin_id?: SortOrder
    dept_type?: SortOrder
    deletable?: SortOrder
  }

  export type mis_usersMaxOrderByAggregateInput = {
    user_id?: SortOrder
    user_type?: SortOrder
    admin_id?: SortOrder
    dept_type?: SortOrder
    user_name?: SortOrder
    user_name_bn?: SortOrder
    user_slug?: SortOrder
    user_initial?: SortOrder
    user_initial_bn?: SortOrder
    user_bio?: SortOrder
    user_bio_bn?: SortOrder
    img_path?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type mis_usersMinOrderByAggregateInput = {
    user_id?: SortOrder
    user_type?: SortOrder
    admin_id?: SortOrder
    dept_type?: SortOrder
    user_name?: SortOrder
    user_name_bn?: SortOrder
    user_slug?: SortOrder
    user_initial?: SortOrder
    user_initial_bn?: SortOrder
    user_bio?: SortOrder
    user_bio_bn?: SortOrder
    img_path?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type mis_usersSumOrderByAggregateInput = {
    user_id?: SortOrder
    user_type?: SortOrder
    admin_id?: SortOrder
    dept_type?: SortOrder
    deletable?: SortOrder
  }

  export type monthly_foldersCountOrderByAggregateInput = {
    folder_id?: SortOrder
    folder_name?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type monthly_foldersAvgOrderByAggregateInput = {
    folder_id?: SortOrder
    deletable?: SortOrder
  }

  export type monthly_foldersMaxOrderByAggregateInput = {
    folder_id?: SortOrder
    folder_name?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type monthly_foldersMinOrderByAggregateInput = {
    folder_id?: SortOrder
    folder_name?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type monthly_foldersSumOrderByAggregateInput = {
    folder_id?: SortOrder
    deletable?: SortOrder
  }

  export type p_album_positionsCountOrderByAggregateInput = {
    position_id?: SortOrder
    position_name?: SortOrder
    position_slug?: SortOrder
    cat_id?: SortOrder
    special_cat_id?: SortOrder
    subcat_id?: SortOrder
    content_ids?: SortOrder
    total_content?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p_album_positionsAvgOrderByAggregateInput = {
    position_id?: SortOrder
    cat_id?: SortOrder
    special_cat_id?: SortOrder
    subcat_id?: SortOrder
    total_content?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type p_album_positionsMaxOrderByAggregateInput = {
    position_id?: SortOrder
    position_name?: SortOrder
    position_slug?: SortOrder
    cat_id?: SortOrder
    special_cat_id?: SortOrder
    subcat_id?: SortOrder
    content_ids?: SortOrder
    total_content?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p_album_positionsMinOrderByAggregateInput = {
    position_id?: SortOrder
    position_name?: SortOrder
    position_slug?: SortOrder
    cat_id?: SortOrder
    special_cat_id?: SortOrder
    subcat_id?: SortOrder
    content_ids?: SortOrder
    total_content?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p_album_positionsSumOrderByAggregateInput = {
    position_id?: SortOrder
    cat_id?: SortOrder
    special_cat_id?: SortOrder
    subcat_id?: SortOrder
    total_content?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type p_albumsCountOrderByAggregateInput = {
    album_id?: SortOrder
    cat_id?: SortOrder
    subcat_id?: SortOrder
    album_name?: SortOrder
    short_description?: SortOrder
    album_details?: SortOrder
    photographer_name?: SortOrder
    tag?: SortOrder
    status?: SortOrder
    total_hit?: SortOrder
    deletable?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p_albumsAvgOrderByAggregateInput = {
    album_id?: SortOrder
    cat_id?: SortOrder
    subcat_id?: SortOrder
    status?: SortOrder
    total_hit?: SortOrder
    deletable?: SortOrder
    user_id?: SortOrder
  }

  export type p_albumsMaxOrderByAggregateInput = {
    album_id?: SortOrder
    cat_id?: SortOrder
    subcat_id?: SortOrder
    album_name?: SortOrder
    short_description?: SortOrder
    album_details?: SortOrder
    photographer_name?: SortOrder
    tag?: SortOrder
    status?: SortOrder
    total_hit?: SortOrder
    deletable?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p_albumsMinOrderByAggregateInput = {
    album_id?: SortOrder
    cat_id?: SortOrder
    subcat_id?: SortOrder
    album_name?: SortOrder
    short_description?: SortOrder
    album_details?: SortOrder
    photographer_name?: SortOrder
    tag?: SortOrder
    status?: SortOrder
    total_hit?: SortOrder
    deletable?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p_albumsSumOrderByAggregateInput = {
    album_id?: SortOrder
    cat_id?: SortOrder
    subcat_id?: SortOrder
    status?: SortOrder
    total_hit?: SortOrder
    deletable?: SortOrder
    user_id?: SortOrder
  }

  export type p_categoriesCountOrderByAggregateInput = {
    cat_id?: SortOrder
    cat_name?: SortOrder
    cat_name_bn?: SortOrder
    cat_slug?: SortOrder
    cat_meta_keyword?: SortOrder
    cat_meta_description?: SortOrder
    cat_position?: SortOrder
    top_menu?: SortOrder
    footer_menu?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p_categoriesAvgOrderByAggregateInput = {
    cat_id?: SortOrder
    cat_position?: SortOrder
    top_menu?: SortOrder
    footer_menu?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type p_categoriesMaxOrderByAggregateInput = {
    cat_id?: SortOrder
    cat_name?: SortOrder
    cat_name_bn?: SortOrder
    cat_slug?: SortOrder
    cat_meta_keyword?: SortOrder
    cat_meta_description?: SortOrder
    cat_position?: SortOrder
    top_menu?: SortOrder
    footer_menu?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p_categoriesMinOrderByAggregateInput = {
    cat_id?: SortOrder
    cat_name?: SortOrder
    cat_name_bn?: SortOrder
    cat_slug?: SortOrder
    cat_meta_keyword?: SortOrder
    cat_meta_description?: SortOrder
    cat_position?: SortOrder
    top_menu?: SortOrder
    footer_menu?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p_categoriesSumOrderByAggregateInput = {
    cat_id?: SortOrder
    cat_position?: SortOrder
    top_menu?: SortOrder
    footer_menu?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type p_galleriesCountOrderByAggregateInput = {
    id?: SortOrder
    album_id?: SortOrder
    photo?: SortOrder
    photo_capture?: SortOrder
    feature_image?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p_galleriesAvgOrderByAggregateInput = {
    id?: SortOrder
    album_id?: SortOrder
  }

  export type p_galleriesMaxOrderByAggregateInput = {
    id?: SortOrder
    album_id?: SortOrder
    photo?: SortOrder
    photo_capture?: SortOrder
    feature_image?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p_galleriesMinOrderByAggregateInput = {
    id?: SortOrder
    album_id?: SortOrder
    photo?: SortOrder
    photo_capture?: SortOrder
    feature_image?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p_galleriesSumOrderByAggregateInput = {
    id?: SortOrder
    album_id?: SortOrder
  }

  export type p_subcategoriesCountOrderByAggregateInput = {
    subcat_id?: SortOrder
    cat_id?: SortOrder
    subcat_name?: SortOrder
    subcat_name_bn?: SortOrder
    subcat_slug?: SortOrder
    subcat_meta_keyword?: SortOrder
    subcat_meta_description?: SortOrder
    subcat_position?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p_subcategoriesAvgOrderByAggregateInput = {
    subcat_id?: SortOrder
    cat_id?: SortOrder
    subcat_position?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type p_subcategoriesMaxOrderByAggregateInput = {
    subcat_id?: SortOrder
    cat_id?: SortOrder
    subcat_name?: SortOrder
    subcat_name_bn?: SortOrder
    subcat_slug?: SortOrder
    subcat_meta_keyword?: SortOrder
    subcat_meta_description?: SortOrder
    subcat_position?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p_subcategoriesMinOrderByAggregateInput = {
    subcat_id?: SortOrder
    cat_id?: SortOrder
    subcat_name?: SortOrder
    subcat_name_bn?: SortOrder
    subcat_slug?: SortOrder
    subcat_meta_keyword?: SortOrder
    subcat_meta_description?: SortOrder
    subcat_position?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type p_subcategoriesSumOrderByAggregateInput = {
    subcat_id?: SortOrder
    cat_id?: SortOrder
    subcat_position?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type site_settingsCountOrderByAggregateInput = {
    id?: SortOrder
    site_name?: SortOrder
    favicon?: SortOrder
    logo?: SortOrder
    logo_header?: SortOrder
    logo_footer?: SortOrder
    title?: SortOrder
    meta_keywords?: SortOrder
    meta_description?: SortOrder
    og_image?: SortOrder
    post_ogimage?: SortOrder
    social_links?: SortOrder
    facebook?: SortOrder
    twitter?: SortOrder
    google_plus?: SortOrder
    youtube?: SortOrder
    instagram?: SortOrder
    linkedin?: SortOrder
    editor_meta?: SortOrder
    address?: SortOrder
    copyright?: SortOrder
    show_special?: SortOrder
    special_title?: SortOrder
    special_link?: SortOrder
    show_live_tv?: SortOrder
    show_video_live_tv?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type site_settingsAvgOrderByAggregateInput = {
    id?: SortOrder
    logo_header?: SortOrder
    logo_footer?: SortOrder
    show_special?: SortOrder
    show_live_tv?: SortOrder
    show_video_live_tv?: SortOrder
  }

  export type site_settingsMaxOrderByAggregateInput = {
    id?: SortOrder
    site_name?: SortOrder
    favicon?: SortOrder
    logo?: SortOrder
    logo_header?: SortOrder
    logo_footer?: SortOrder
    title?: SortOrder
    meta_keywords?: SortOrder
    meta_description?: SortOrder
    og_image?: SortOrder
    post_ogimage?: SortOrder
    social_links?: SortOrder
    facebook?: SortOrder
    twitter?: SortOrder
    google_plus?: SortOrder
    youtube?: SortOrder
    instagram?: SortOrder
    linkedin?: SortOrder
    editor_meta?: SortOrder
    address?: SortOrder
    copyright?: SortOrder
    show_special?: SortOrder
    special_title?: SortOrder
    special_link?: SortOrder
    show_live_tv?: SortOrder
    show_video_live_tv?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type site_settingsMinOrderByAggregateInput = {
    id?: SortOrder
    site_name?: SortOrder
    favicon?: SortOrder
    logo?: SortOrder
    logo_header?: SortOrder
    logo_footer?: SortOrder
    title?: SortOrder
    meta_keywords?: SortOrder
    meta_description?: SortOrder
    og_image?: SortOrder
    post_ogimage?: SortOrder
    social_links?: SortOrder
    facebook?: SortOrder
    twitter?: SortOrder
    google_plus?: SortOrder
    youtube?: SortOrder
    instagram?: SortOrder
    linkedin?: SortOrder
    editor_meta?: SortOrder
    address?: SortOrder
    copyright?: SortOrder
    show_special?: SortOrder
    special_title?: SortOrder
    special_link?: SortOrder
    show_live_tv?: SortOrder
    show_video_live_tv?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type site_settingsSumOrderByAggregateInput = {
    id?: SortOrder
    logo_header?: SortOrder
    logo_footer?: SortOrder
    show_special?: SortOrder
    show_live_tv?: SortOrder
    show_video_live_tv?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type surveysCountOrderByAggregateInput = {
    survey_id?: SortOrder
    title?: SortOrder
    from_date?: SortOrder
    to_date?: SortOrder
    ha?: SortOrder
    na?: SortOrder
    no_comment?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type surveysAvgOrderByAggregateInput = {
    survey_id?: SortOrder
    ha?: SortOrder
    na?: SortOrder
    no_comment?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type surveysMaxOrderByAggregateInput = {
    survey_id?: SortOrder
    title?: SortOrder
    from_date?: SortOrder
    to_date?: SortOrder
    ha?: SortOrder
    na?: SortOrder
    no_comment?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type surveysMinOrderByAggregateInput = {
    survey_id?: SortOrder
    title?: SortOrder
    from_date?: SortOrder
    to_date?: SortOrder
    ha?: SortOrder
    na?: SortOrder
    no_comment?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type surveysSumOrderByAggregateInput = {
    survey_id?: SortOrder
    ha?: SortOrder
    na?: SortOrder
    no_comment?: SortOrder
    status?: SortOrder
    deletable?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type upozillasCountOrderByAggregateInput = {
    upozilla_id?: SortOrder
    district_id?: SortOrder
    division_id?: SortOrder
    upozilla_name?: SortOrder
    upozilla_name_bn?: SortOrder
    upozilla_title?: SortOrder
    upozilla_slug?: SortOrder
    meta_description?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type upozillasAvgOrderByAggregateInput = {
    upozilla_id?: SortOrder
    district_id?: SortOrder
    division_id?: SortOrder
    deletable?: SortOrder
  }

  export type upozillasMaxOrderByAggregateInput = {
    upozilla_id?: SortOrder
    district_id?: SortOrder
    division_id?: SortOrder
    upozilla_name?: SortOrder
    upozilla_name_bn?: SortOrder
    upozilla_title?: SortOrder
    upozilla_slug?: SortOrder
    meta_description?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type upozillasMinOrderByAggregateInput = {
    upozilla_id?: SortOrder
    district_id?: SortOrder
    division_id?: SortOrder
    upozilla_name?: SortOrder
    upozilla_name_bn?: SortOrder
    upozilla_title?: SortOrder
    upozilla_slug?: SortOrder
    meta_description?: SortOrder
    deletable?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type upozillasSumOrderByAggregateInput = {
    upozilla_id?: SortOrder
    district_id?: SortOrder
    division_id?: SortOrder
    deletable?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    designation?: SortOrder
    username?: SortOrder
    email?: SortOrder
    email_verified_at?: SortOrder
    password?: SortOrder
    two_factor_secret?: SortOrder
    two_factor_recovery_codes?: SortOrder
    role?: SortOrder
    bn_cat_ids?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    deletable?: SortOrder
    remember_token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    deletable?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    designation?: SortOrder
    username?: SortOrder
    email?: SortOrder
    email_verified_at?: SortOrder
    password?: SortOrder
    two_factor_secret?: SortOrder
    two_factor_recovery_codes?: SortOrder
    role?: SortOrder
    bn_cat_ids?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    deletable?: SortOrder
    remember_token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    designation?: SortOrder
    username?: SortOrder
    email?: SortOrder
    email_verified_at?: SortOrder
    password?: SortOrder
    two_factor_secret?: SortOrder
    two_factor_recovery_codes?: SortOrder
    role?: SortOrder
    bn_cat_ids?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    deletable?: SortOrder
    remember_token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    deletable?: SortOrder
  }

  export type counterCountOrderByAggregateInput = {
    id?: SortOrder
    counter_name?: SortOrder
    counter_time?: SortOrder
    time?: SortOrder
    date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type counterAvgOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type counterMaxOrderByAggregateInput = {
    id?: SortOrder
    counter_name?: SortOrder
    counter_time?: SortOrder
    time?: SortOrder
    date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type counterMinOrderByAggregateInput = {
    id?: SortOrder
    counter_name?: SortOrder
    counter_time?: SortOrder
    time?: SortOrder
    date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type counterSumOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type migrationsCountOrderByAggregateInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
  }

  export type migrationsAvgOrderByAggregateInput = {
    id?: SortOrder
    batch?: SortOrder
  }

  export type migrationsMaxOrderByAggregateInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
  }

  export type migrationsMinOrderByAggregateInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
  }

  export type migrationsSumOrderByAggregateInput = {
    id?: SortOrder
    batch?: SortOrder
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use authorsDefaultArgs instead
     */
    export type authorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = authorsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bn_adsDefaultArgs instead
     */
    export type bn_adsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bn_adsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bn_breaking_newsDefaultArgs instead
     */
    export type bn_breaking_newsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bn_breaking_newsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bn_categoriesDefaultArgs instead
     */
    export type bn_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bn_categoriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bn_content_positionsDefaultArgs instead
     */
    export type bn_content_positionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bn_content_positionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bn_contentsDefaultArgs instead
     */
    export type bn_contentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bn_contentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bn_mobile_adsDefaultArgs instead
     */
    export type bn_mobile_adsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bn_mobile_adsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bn_position_fixedDefaultArgs instead
     */
    export type bn_position_fixedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bn_position_fixedDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bn_subcategoriesDefaultArgs instead
     */
    export type bn_subcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bn_subcategoriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bn_tagsDefaultArgs instead
     */
    export type bn_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bn_tagsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bn_video_categoriesDefaultArgs instead
     */
    export type bn_video_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bn_video_categoriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bn_video_positionsDefaultArgs instead
     */
    export type bn_video_positionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bn_video_positionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bn_videosDefaultArgs instead
     */
    export type bn_videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bn_videosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use countriesDefaultArgs instead
     */
    export type countriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = countriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use districtsDefaultArgs instead
     */
    export type districtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = districtsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use divisionsDefaultArgs instead
     */
    export type divisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = divisionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use electionsDefaultArgs instead
     */
    export type electionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = electionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use epaper_pagesDefaultArgs instead
     */
    export type epaper_pagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = epaper_pagesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use epapersDefaultArgs instead
     */
    export type epapersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = epapersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use magazine_pagesDefaultArgs instead
     */
    export type magazine_pagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = magazine_pagesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use magazinesDefaultArgs instead
     */
    export type magazinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = magazinesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use manual_documentsDefaultArgs instead
     */
    export type manual_documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = manual_documentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use manual_photosDefaultArgs instead
     */
    export type manual_photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = manual_photosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mis_usersDefaultArgs instead
     */
    export type mis_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = mis_usersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use monthly_foldersDefaultArgs instead
     */
    export type monthly_foldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = monthly_foldersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use p_album_positionsDefaultArgs instead
     */
    export type p_album_positionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = p_album_positionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use p_albumsDefaultArgs instead
     */
    export type p_albumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = p_albumsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use p_categoriesDefaultArgs instead
     */
    export type p_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = p_categoriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use p_galleriesDefaultArgs instead
     */
    export type p_galleriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = p_galleriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use p_subcategoriesDefaultArgs instead
     */
    export type p_subcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = p_subcategoriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use site_settingsDefaultArgs instead
     */
    export type site_settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = site_settingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use surveysDefaultArgs instead
     */
    export type surveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = surveysDefaultArgs<ExtArgs>
    /**
     * @deprecated Use upozillasDefaultArgs instead
     */
    export type upozillasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = upozillasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use counterDefaultArgs instead
     */
    export type counterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = counterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use migrationsDefaultArgs instead
     */
    export type migrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = migrationsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}